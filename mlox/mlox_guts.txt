------------------------------------------------------------
o What mlox does, operational details

[TBD - this section is in the midst of being re-written]
TBD - explain why I always redate all plugins. 

You can skip this section if the nitty gritty details are not of
interest. :)

mlox does two main things, which are outlined here and explained
below:

1) mlox sorts your load order, based on the observation that
* orderings for plugins make up a partially ordered set.
* A partially ordered set can be sorted by a topological sort.
* A topological sort requires a DAG (Directed Acyclic Graph).
** So we need to avoid putting cycles in our graph.
* A topological sort can have many valid solutions. 
** So we try to pick the solution we'd most like to see.
*** by root picking (nearstart, nearend)
*** maintaining previous order (pseudo-rules)

2) mlox gives warnings
** about plugin conflicts
** and missing requirements

-----

1) mlox sorts your load order, based on the observation that
* orderings for plugins make up a partially ordered set.

Let's say we have plugins A, B and C. We may know that A needs to
precede B. But A and B have nothing to do with C, so it doesn't matter
if A and B come before or after C. This is the essence of a partial
ordering. And we can represent the ordering relationships in a graph,
where "->" is called an "edge" and A -> B means that "A comes before
B".

* A partially ordered set can be sorted by a topological sort.

(See: http://en.wikipedia.org/wiki/Topological_sorting)

* A topological sort requires a DAG (Directed Acyclic Graph).
** So we need to avoid putting cycles in our graph.

In our example, we have:
A -> B
C

If we were to add the edge: B -> A, this would produce a cycle,
meaning that if you follow the edges from A -> B -> A, you've come
back to your starting point.

To avoid cycles, all we have to do while building our graph from the
input rules is to check before we add an edge to see if it will
produce a cycle, and if so, we discard it. When mlox does its
add_edge(X, Y) function (which adds X -> Y), it first checks to see if
we can already reach Y from X (i.e. that some path of edges exists,
such that Y -> ... -> X) using a depth first search. If so, adding X
-> Y would produce a cycle, and so that edge is discarded.

* A topological sort can have many valid solutions. 

Back to our example, if we know the ordering:
A -> B

and we sort the set of A,B,C by topological sort, the following
solutions are valid:

Solution 1: C, A, B
Solution 2: A, C, B
Solution 3: A, B, C

** So we try to pick the solution we'd most like to see.

Well, it turns out that human beings dislike change :) so since the
user of mlox is a human being, we want to ensure that the sorted load
order differs no more from the original sort order than is necessarily
dictated by the ordering rules in our rule-base.

Returning to our example, if the original order was: B, A, C, and our
ordering rule is: A -> B, then a nice result would be: A, B, C, even
though the other solutions we enumerate above are just as valid.

mlox tries to achieve this by using the original order as a set of
"pseudo-rules", which, for our example would be: A -> B, and B -> C.

So, putting it all together, what mlox does is:

First, reads rules from the user rule-base (mlox_user.txt), then the
main rule-base (mlox_base.txt), and finally applies pseudo-rules from
the original load order. And of course, it does the cycle detection
and discarding as we procede along.

So we take the defined rule first:

A -> B

then add the next rule from the pseudo-rules: 

A -> B
B -> A

But that is a cycle, so we chuck the B -> A, then add the next
pseudo-rule:

A -> B
B -> C

And if we apply those to the set B, A, C, we end up with:

A, B, C

*** by root picking (nearstart, nearend)
*** maintaining previous order (pseudo-rules)

2) mlox gives warnings
** about plugin conflicts
** and missing requirements

The design of mlox's load order sorting feature follows as a natural
consequence of these observations, 
The sorting that mlox does is based on the notion of "partially
ordered sets". 

-----
(we'll represent this as a graph,
like this A -> B -> C, where "->" is called an "edge")
-----

If you have a set of A, B and C, and you know that A
comes before B which comes before C, then you have a "total ordering".
If you have the same set, but only know that A -> C, then the
following results of a sort are valid:

Solution 1: A, B, C
Solution 2: A, C, B
Solution 3: B, A, C

because in all three solutions, A comes before C. In contrast, with a
total ordering, there is only one solution.

In this small example, A and B are called "roots". This is because
they have no incoming edges in the graph.

-----

