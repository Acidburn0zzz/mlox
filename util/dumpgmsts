#!/usr/bin/perl

use Getopt::Std;
use strict;

# read the GMSTs from MW/TB, and dump them as ascii blobs, for use in esplint.

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant HELP => grep(/^(?:-h|-?-help)$/, @ARGV);
    use constant DBG => grep(/^(?:-d|-?-debug)$/, @ARGV);
}

$::opt_v = 0;			# verbose

my $Usage = qq{dumpgmsts [OPTIONS] plugin...

OPTIONS
 -d   debug output (vast output)

};

getopts('d') or die $Usage;

my @BMGMSTs = qw(
		    fCombatDistanceWerewolfMod
		    fFleeDistance
		    fWereWolfAcrobatics
		    fWereWolfAgility
		    fWereWolfAlchemy
		    fWereWolfAlteration
		    fWereWolfArmorer
		    fWereWolfAthletics
		    fWereWolfAxe
		    fWereWolfBlock
		    fWereWolfBluntWeapon
		    fWereWolfBounty
		    fWereWolfConjuration
		    fWereWolfDestruction
		    fWereWolfEnchant
		    fWereWolfEndurance
		    fWereWolfFatigue
		    fWereWolfFightMod
		    fWereWolfFleeMod
		    fWereWolfHandtoHand
		    fWereWolfHealth
		    fWereWolfHeavyArmor
		    fWereWolfIllusion
		    fWereWolfIntelligence
		    fWereWolfLeveltoAttack
		    fWereWolfLightArmor
		    fWereWolfLongBlade
		    fWereWolfLuck
		    fWereWolfMagicka
		    fWereWolfMarksman
		    fWereWolfMediumArmor
		    fWereWolfMercantile
		    fWereWolfMysticism
		    fWereWolfPersonaltiy
		    fWereWolfRestoration
		    fWereWolfRunMult
		    fWereWolfSecurity
		    fWereWolfShortBlade
		    fWereWolfSilverWeaponDamageMult
		    fWereWolfSneak
		    fWereWolfSpear
		    fWereWolfSpeechcraft
		    fWereWolfSpeed
		    fWereWolfStrength
		    fWereWolfUnarmored
		    fWereWolfWillPower
		    fWereWolfIntellegence
		    fWereWolfMerchantile
		    fWereWolfPersonality
		    iWereWolfBounty
		    iWereWolfFightmod
		    iWereWolfFleemod
		    iWereWolfLevelToAttack
		    sEditNote
		    sEffectSummonCreature01
		    sEffectSummonCreature02
		    sEffectSummonCreature03
		    sEffectSummonCreature04
		    sEffectSummonCreature05
		    sMagicCreature01ID
		    sMagicCreature02ID
		    sMagicCreature03ID
		    sMagicCreature04ID
		    sMagicCreature05ID
		    sWereWolfAlarmMessage
		    sWereWolfPopup
		    sWereWolfRefusal
		    sWereWolfRestMessage
	       );

my @TBGMSTs =  qw(sCompanionShare
		  sCompanionWarningButtonOne
		  sCompanionWarningButtonTwo
		  sCompanionWarningMessage
		  sDeleteNote
		  sEffectSummonFabricant
		  sLevitateDisabled
		  sMagicFabricantID
		  sMaxSale
		  sProfitValue
		  sTeleportDisabled);

my %EVILTB = ();
foreach my $g (@TBGMSTs) { $EVILTB{lc($g)}++; }
my %EVILBM = ();
foreach my $g (@BMGMSTs) { $EVILBM{lc($g)}++; }

my $hdr_size = 16;
sub read_rec {
    my($expected_type) = @_;
    my $rec_hdr = "";
    my $n_read = sysread(INP, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef, undef);
    }
    if ($n_read != $hdr_size) {
	warn "Error(hdr): asked for $hdr_size bytes, got $n_read\n";
	return(undef, undef);
    }
    my($rec_type, $rec_len, $flags) = unpack("a4Lx[L]L", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rec_type) {
	warn "Error: Expected: $expected_type, got: $rec_type\n";
	return(undef, undef);
    }
    my $rec = "";
    $n_read = sysread(INP, $rec, $rec_len);
    if ($n_read != $rec_len) {
	warn "Error(rec): asked for $rec_len bytes, got $n_read\n";
	return(undef, undef);
    }
    return($rec_type, $rec, $flags);
}

sub parse_subrec {
    my($rec) = @_;
    my %r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4I", substr($rec, $p));
	$p += 8;
	push(@{$r{$subrec_type}}, substr($rec, $p, $subrec_len));
	$p += $subrec_len;
    }
    return(\%r);
}

sub get_subrec {
    my($rec, $subtype) = @_;
    my @r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4I", substr($rec, $p));
	$p += 8;
	push(@r, substr($rec, $p, $subrec_len))
	    if ($subrec_type eq $subtype);
	$p += $subrec_len;
    }
    return(\@r);
}

sub gmstval {
    my($rec) = @_;
    my $r = parse_subrec($rec);
    my $name = lc($r->{NAME}[0]);
    delete $r->{NAME};
    my @keys = keys(%$r);
    if (scalar(@keys) > 1) {
	warn "Error, too many keys for $name: @keys\n";
    }
    my $type = $keys[0];
    my $val = $r->{$type}[0];
    return($name, unpack("h*", "$type $val"));
}

sub scan {
    my($plugin) = @_;
    warn "### Scanning $plugin\n" if ($::opt_v);
    unless(open(INP, "<$plugin")) {
	warn "Error opening $plugin for input ($!)\n";
	return;
    }
    my $expected = "TES3";
    while (my($rec_type, $rec, $flags) = read_rec($expected)) {
	$expected = undef;
	last if not defined $rec_type;
	if ($flags & 0x1000) {
	    print "REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	print "REC=$rec_type\n" if (DBG);
	if ($rec_type eq "GMST") {
	    my($name, $val) = gmstval($rec);
	    if ($EVILTB{$name}) {
		print qq{TB $name $val\n};
	    } elsif ($EVILBM{$name}) {
		print qq{BM $name $val\n};
	    } else {
		print qq{XX $name $val\n};
	    }
	}
    }
    close(INP);
}

for my $plugin (@ARGV) {
    scan($plugin);
}

