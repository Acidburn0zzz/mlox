#!/usr/bin/perl
#Version: 0.5
# tes3lint - a diagnostic tool for TES3/Morrowind plugins
# Copyright 2008 by John Moonsugar
# Distributed as part of the mlox project:
#   http://code.google.com/p/mlox/
# under the MIT License:
#   http://code.google.com/p/mlox/source/browse/trunk/License.txt

# TBD: OVR-REC specials: PGRD.????

use Cwd;
use Data::Dumper;
use Storable;
use Getopt::Std;
use strict;

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug code into the program when it it actually needed.
    use constant DBG => grep(/^(?:-D)$/, @ARGV);
}

$::opt_a = 0;			# "all" output options
$::opt_e = 0;			# "error" output options
$::opt_f = "";			# which specific flags to turn on
$::opt_n = 0;			# "normal" output options
$::opt_r = 0;			# "recommended" output options
$::opt_v = 0;			# verbose
$::opt_w = 999;			# record output field width

my %OPTFLAG = ();		# output flag options

my $CHK_DUPLICATE_INFO = 0;	# DUP-INF
my $CHK_FOG_DENSITY = 0;	# FOGBUG & FOGSYNC
my $CHK_NO_EXPANSION_FUNS = 0;	# !TB-FUN & !BM-FUN
my $CHK_GETSOUNDPLAYING = 0;	# GETSND
my $CHK_HEADER_FIELDS = 0;	# MISSAUT, MISSDSC, MISSVER
my $CHK_CHANGED_INFO_IDS = 0;	# MOD-IID
my $CHK_DEPRECATED_LISTFUN = 0;	# DEP-LST
my $CHK_MODIFIED_INFO = 0;	# MOD-INF
my $CHK_OVERRIDDEN_REC = 0;	# OVR-REC
my $CHK_AUTOCALCED_SPELLS = 0;	# AUTOSPL
my $CHK_SCRIPTED_DOORS = 0;	# SCRDOOR
my $CHK_DUP_REC = 0;		# DUP-REC
my $CHK_EXPANSION_FUNCTIONS = 0; # BM-DEP & EXP-DEP

my $Usage = qq{tes3lint [OPTIONS] plugin...

OPTIONS
 -D        debug output (vast)
 -f flags  specify which flags (in a comma delimited list) to print.
 -v        verbose (possibly more output)

The following are shortcuts for printing recommended lists of flags:
 -a  all output flags on. (slowest, but most comprehensive option).
 -n  "normal" output flags on (performs relatively speedily):
      (EVLGMST, FOGBUG/FOGSYNC, MOD-IID, JUNKCEL, DUP-REC)
     this option omits some flags for the sake of speed and relevancy.
 -r  "recommended" output flags on (performs relatively slower):
      (CLEAN, EVLGMST, FOGBUG/FOGSYNC, MISSAUT, MISSDSC, MISSVER, MOD-IID,
      JUNKCEL, DEP-LST, DUP-REC, BM-DEP/EXP-DEP)
      This adds some checks that perform slowly due to massive regular
      expression matching. This is the default output flag option that
      selected if no others are specified.

Examples:

# print out selected flags (just: AUTOSPL and MENUMOD):
tes3lint -f autospl,menumod plugin.esp

# print out all flags for a bunch of plugins:
tes3lint -a plugin1.esp plugin2.esp ... pluginN.esp

# print out only the most important flags
tes3lint -r plugin.esp

[Note: tes3lint wants to be able to find Masters for a given plugin, so it
needs to run somewhere under your Morrowind directory, but it does not
necessarily have to be in your Data Files directory.]

tes3lint normally only prints output for interesting things it finds. If it
finds nothing for a plugin, no output is generated unless the CLEAN flag is
given. When something interesting is found, a flag is printed after the plugin
name. On following lines, an indented report is printed that gives more detail
about the flagged items.

 The following flags are defined:

    AUTOSPL: The plugin defines autocalc'ed spells.

    BM-DEP:  The plugin uses Bloodmoon specific functions, so it needs version
             1.6.1820, but the plugin does not list Bloodmoon.esm in its list
             of Masters. This is similar to the EXP-DEP flag, but it is for
             Bloodmoon only.

    CELL00:  This means that an apparently dirty copy of cell (0, 0) is
             included in the plugin. This cell is often accidentally modified
             since it is the default cell displayed in the cell view window.

    CLEAN:   If this flag is used, then a plugin that is not flagged with any of
             the flags below will be flagged "CLEAN". It really just means:
             "found nothing of interest".

    DEP-LST: This flag indicates that the plugin makes deprecated use of
             scripting functions to modify standard Bethesda Leveled Lists.
             This is bad because these lists will then be stored in the user's
             savegame just like any other changed object. Since savegames load
             after all plugins (including "Mashed Lists.esp" which contains
             merged leveled lists), this means that merged leveled lists will
             be ignored. Note that this warning only applies to changes to
             Bethesda lists. Changes to leveled lists specific to the mod will
             not be flagged. For more about the problem of using scripting
             functions to modify Bethesda lists see:
             http://www.uesp.net/wiki/Tes3Mod:Leveled_Lists

    DUP-INF: indicates the exact INFO dialog with the same ID, text and filter
             exists in one of the masters of this plugin. This may be a
             problem, or maybe not. Sometimes duplicate dialog is intentional
             in order for dialog sorting to be correct. It's only a mistake
             if it really was unintentional.

    DUP-REC: These are records in the plugin that are exact duplicates of
             records that occur in one of the masters. These are sometimes
             referred to as "dirty" or "unclean" entries.

    EXP-DEP: The plugin requires either Tribunal or Bloodmoon because it uses
             engine features not present in the original Morrowind such as
             startup scripts or Tribunal functions, but the plugin has not
             listed any expansions in its list of Masters. This is not
             necessarily a problem, but it may contradict the Readme for the
             mod sometimes.

    EVLGMST: You know this one! This means that some of the "72 Evil GMSTs" are
             present in this plugin and that they have the same exact value as
             the original GMST in the master .esm. Other GMSTs not in the list
             of known Evil GMSTs or GMSTs that have been modified from their
             original values are not flagged. Note that it is also possible to
             have other GMSTs show up in the DUP-REC list, but those are not
             from the list of 72 GMSTs that would get introduced by the
             Construction Set.

    FOGBUG:  The plugin has an interior CELL with a fog density of 0.0, and the
             cell is not marked to "behave as exterior". This circumstance can
             trigger the "fog bug" in some graphics cards, resulting in the
             cell being rendered as a black or featureless blank screen.

    FOGSYNC: This flag indicates that for some reason that the fog density
             setting in the CELL.DATA subrecord is not equal to the fog
             density setting in the CELL.AMBI subrecord. This is unusual, it's
             probably caused by editing the plugin in Enchanted Editor, and
             it's probably harmless, but you can resync the values by editing
             that cell in the Construction Set.

    GETSND:  The plugin appears to use the scripting function GetSoundPlaying
             to detect events (as opposed to managing the playing of sound
             files). GetSoundPlaying fails consistently on a small number of
             users' systems, so these users will encounter problems with these
             scripts. Note that tes3lint uses regular expressions to detect the
             purpose for using GetSoundPlaying, and it will sometimes get
             false positives. For more about the GetSoundPlaying problem see:
             http://sites.google.com/site/johnmoonsugar/Home/morrowind-scripting-tips

    JUNKCEL: These are bogus external CELL records that crop up in many
             plugins, possibly due to a Construction Set bug. They contain
             only NAME, DATA and sometimes RGNN subrecords, and the flags in
             the DATA subrecord are unchanged from the flags in the Master.

    MENUMOD: The plugin contains scripts that do not check menumode. Each script
             will be printed in the details section. This may or may not be
             intentional, so the flag is optional and only included in the -a
             switch.

    MISSAUT: The plugin header is missing the Author field. It is strongly
             recommended that authors put their name or handle in the Author
             field.

    MISSDSC: The plugin header is missing a description field. It is strongly
             recommended that a short description of the plugin is entered in
             this field.

    MISSVER: The plugin header description field is missing a "Version: X.Y"
             string. It is strongly recommended that the version number be
             added to the description. This version number is very helpful in
             documenting which version of the plugin a user is using. This
             information is used by tools such as Wrye Mash and mlox. The
             regular expression pattern used by Wrye Mash to match the version
             is: "^(Version:?) *([-0-9\\.]*\\+?) *\\r?\$". (mlox will match a
             much wider variety of version number formats). It is safest to
             use a string of the format: "Version: X.Y", on a line by itself.

    MOD-INF: indicates that an INFO dialog with the same ID exists in the
	     master, but this plugin has modified the text or the filter. This
	     is quite common when a plugin intentionally modifies a master's
	     dialog, but it often a problem when due to unintentional changes.
	     A MOD-INF flag may have an associated MOD-IID flag. The modified
	     Info record is dumped in a very cursory fashion (the binary bits
	     are just trimmed out) in order to give a quick identification.

    MOD-IID: indicates that the exact same INFO dialog text exists in this
	     plugin as in a master, but under a different ID. When associated
	     with a MOD-INF, this situation may be due to creating new dialog
	     by copying the original, and then accidentally editing the
	     original instead of the copy which may cause bad dialog problems
	     and should probably be investigated further.

    OVR-REC: The plugin contains record(s) that override the record with the
             same ID in one of its masters.

    SCRDOOR: The plugin adds scripts to Bethesda doors, which has the potential
             to break any script in the same cell that uses the CellChanged
             function. CellChanged in that cell will always return 0 from now on.
             See: http://sites.google.com/site/johnmoonsugar/Home/morrowind-scripting-tips

    !BM-FUN: Bloodmoon.esm is listed as a master, but tes3lint did not detect
             any usage of Bloodmoon functions. (Note that there may be other
             reasons for listing Bloodmoon as a master).

    !TB-FUN: Tribunal.esm is listed as a master, but tes3lint did not detect
             any usage of Tribunal functions. (Note that there may be other
             reasons for listing Tribunal as a master).
};

getopts('aDef:nrvw') or die $Usage;

# by default choose -r (recommended flags) if no other output option selected:
$::opt_r = 1 unless ($::opt_a or $::opt_f or $::opt_n or $::opt_r);

my %DEFINED_FLAGS = (); $DEFINED_FLAGS{$_}++ foreach (qw(CLEAN DUP-INF
EVLGMST FOGBUG FOGSYNC '!TB-FUN' '!BM-FUN' GETSND MENUMOD MISSAUT MISSDSC
MISSVER MOD-IID JUNKCEL DEP-LST MOD-INF OVR-REC AUTOSPL SCRDOOR DUP-REC BM-DEP
EXP-DEP));

if ($::opt_f) {
    my @unknown_flags = ();
    foreach my $flag (map {uc} split(/\s*,\s*/, $::opt_f)) {
	if ($DEFINED_FLAGS{$flag}){
	    $OPTFLAG{$flag}++;
	} else {
	    push(@unknown_flags, $flag);
	}
    }
    if (@unknown_flags) {
	my $pl = (scalar(@unknown_flags) > 1) ? "s" : "";
	die "Error: unknown flag$pl: @unknown_flags\n";
    }
}

if ($::opt_a) {
    %OPTFLAG = %DEFINED_FLAGS;
    $::opt_v = 1;
} elsif ($::opt_e) {
    $OPTFLAG{$_}++ foreach (qw(CELL00 EVLGMST FOGBUG FOGSYNC MOD-IID DEP-LST BM-DEP EXP-DEP));
} elsif ($::opt_n) {
    $OPTFLAG{$_}++ foreach (qw(EVLGMST FOGBUG FOGSYNC MOD-IID JUNKCEL DUP-REC));
} elsif ($::opt_r) {
    $OPTFLAG{$_}++ foreach (qw(CLEAN EVLGMST FOGBUG FOGSYNC MISSAUT MISSDSC MISSVER MOD-IID JUNKCEL DEP-LST DUP-REC BM-DEP EXP-DEP));
}

$CHK_DUPLICATE_INFO = 1       if ($OPTFLAG{'DUP-INF'});
$CHK_FOG_DENSITY = 1	      if ($OPTFLAG{FOGBUG} or $OPTFLAG{FOGSYNC});
$CHK_NO_EXPANSION_FUNS = 1    if ($OPTFLAG{'!TB-FUN'} or $OPTFLAG{'!BM-FUN'});
$CHK_GETSOUNDPLAYING = 1      if ($OPTFLAG{GETSND});
$CHK_HEADER_FIELDS = 1	      if ($OPTFLAG{MISSAUT} or $OPTFLAG{MISSDSC} or $OPTFLAG{MISSVER});
$CHK_CHANGED_INFO_IDS = 1     if ($OPTFLAG{'MOD-IID'});
$CHK_DEPRECATED_LISTFUN = 1   if ($OPTFLAG{'DEP-LST'});
$CHK_MODIFIED_INFO = 1	      if ($OPTFLAG{'MOD-INF'} or $OPTFLAG{'MOD-IID'});
$CHK_OVERRIDDEN_REC = 1       if ($OPTFLAG{'OVR-REC'});
$CHK_AUTOCALCED_SPELLS = 1    if ($OPTFLAG{AUTOSPL});
$CHK_SCRIPTED_DOORS = 1       if ($OPTFLAG{SCRDOOR});
$CHK_DUP_REC = 1	      if ($OPTFLAG{'DUP-REC'});
$CHK_EXPANSION_FUNCTIONS = 1  if ($OPTFLAG{'BM-DEP'} or $OPTFLAG{'EXP-DEP'});

my %STD_OBJECT = qw(CLAS FACT RACE REGN BSGN DOOR MISC WEAP CONT SPEL CREA
		    LIGH NPC_ ARMO CLOT REPA ACTI APPA LOCK PROB INGR ALCH);

# BEGIN: globals loaded from __DATA__ segment at end of script
my $RE_BMFUN;
my $RE_TBFUN;
my $RE_DEPLST;
my %TB_EVIL;
my %BM_EVIL;
my %BETHDOOR;
# END: globals loaded from __DATA__ segment at end of script

# regular expressions used for finding getSoundPlaying usage
my $RE_GETSOUND = "\\bgetSoundPlaying\\b[^\n]+\n([^\n]+)\n";
my $RE_SOUND = '\b(?:PlayLoopSound3D(?:VP)?|PlaySound(?:3D|3DVP|VP)?|Say(?:Done)?|StopSound|StreamMusic)\b';
my $RE_IGNORE = "^[ \t]*(?:;[^\n]+)*\n"; # for removing comments and blank lines

# regular expressions used for finding menumode usage
my $RE_MENUMODE = '\bmenumode\b';

# globals used for caching data when scanning multiple plugins at once
my @MASTERS = ();		# reset in scan() for each new plugin
my %MASTER_INFO;		# reused from plugin to plugin
my %MASTER_INFTXT;		# reused from plugin to plugin
my %MASTER_REC;			# reused from plugin to plugin
my %MASTER_ID;			# reused from plugin to plugin

# remove the nulls from the end of string value retrieved from a plugin record
sub chop_nulls {
    my($str) = @_;
    $str =~ tr/\000//d;
    return($str);
}

# load a section of data from the DATA pseudo-filedescriptor at the end of this script
sub load_data_list {
    my @datalist = ();
    my $title = scalar(<DATA>);
    print "Loading: $title" if (DBG);
    while (<DATA>) {
	chomp;
	last if (/^# END-OF-LIST/);
	push(@datalist, $_);
    }
    return(\@datalist);
}

# load all data sections from the DATA segment at the end of this script
sub load_data {
    $RE_TBFUN = '^[^;]*?\b(' . join("|", @{load_data_list()}) . ')\b';
    $RE_BMFUN = '^[^;]*?\b(' . join("|", @{load_data_list()}) . ')\b';
    $RE_DEPLST = '^[^;]*?\b((?:addto|removefrom)lev(?:item|creature)\W+(?:' . join("|", @{load_data_list()}) . ')\b\"?).*$';
    foreach my $g (@{load_data_list()}) {
	my($name, $val) = split(" ", $g);
	$TB_EVIL{$name} = $val;
    }
    foreach my $g (@{load_data_list()}) {
	my($name, $val) = split(" ", $g);
	$BM_EVIL{$name} = $val;
    }
    foreach my $door (@{load_data_list()}) {
	$BETHDOOR{$door}++;
    }
    if (not $OPTFLAG{EVLGMST}) {
	undef %TB_EVIL;
	undef %BM_EVIL;
    }
    if (DBG) {
	print "\nTBFUN regexp: $RE_TBFUN\n";
	print "\nBMFUN regexp: $RE_BMFUN\n";
	print "\nDEPLST regexp: $RE_DEPLST\n";
    }
}

# return a dictionary of all the files found in the given directory.
# keys are lowercased for caseless file finding.
sub list_files {
    my($dir) = @_;
    my %files = ();
    if (opendir(DH, $dir)) {
	while (my $file = readdir(DH)) {
	    next if (($file eq '.') or ($file eq '..'));
	    $files{lc $file} = $file;
	}
	closedir(DH);
    } else {
	warn qq{ERROR opening "$dir" ($!)\n};
    }
    return(\%files);
}

# sort list of files by their modification date
sub sort_by_date {
    my($dir, @files) = @_;
    my $dirlist = list_files($dir);
    my @sorted = sort { (-M "$dir/$dirlist->{$a}") <=> (-M "$dir/$dirlist->{$b}") } @files;
    print "DBG: sorted files: @sorted\n" if (DBG);
    return(@sorted);
}

# assuming the program is run somewhere under the Morrowind game directory, find the
# location of the "Data Files" directory by walking up the hierarchy.
sub find_datadir {
    my $dirlist = list_files(".");
    if ($dirlist->{"morrowind.esm"}) {
	return(".");
    }
    my $dir = Cwd::getcwd();
    print "DBG: checking for data dir in: $dir\n" if (DBG);
    while (($dir =~ m!\bmorrowind\b!i) and (-d $dir)) {
	my $datadir = list_files($dir)->{"data files"};
	if ($datadir) {
	    print "DBG: found datadir: $dir/$datadir\n" if (DBG);
	    return("$dir/$datadir");
	}
	my @parts = split(m![\\/]!, $dir);
	pop(@parts);
	$dir = join("/", @parts);
	print "DBG: checking for data dir in: $dir\n" if (DBG);
    }
    warn qq{Can't find "Data Files" directory. Won't be able to find masters\n};
    return(undef);		# not running under morrowind directory
}

sub ext_cell_name {
    my($r) = @_;
    my($x, $y) = unpack("x[L]ll", $r->{DATA}[0]);
    my $rgnn = chop_nulls($r->{RGNN}[0]) || "Wilderness";
    return("$rgnn ($x, $y)", $x, $y);
}

sub rec_id {
    my($r, $rec_type) = @_;
    if ($rec_type eq "CELL") {
	my $name = chop_nulls($r->{NAME}[0]);
	my $data = $r->{DATA}[0];
	my($flags) = unpack("L", $data);
	if ($flags & 1) {	# interior
	    return($name);
	} else {		# exterior
	    my($xname, $x, $y) = ext_cell_name($r);
	    return(($name) ? "$name ($x, $y)" : $xname);
	}
    } elsif ($rec_type eq "SCPT") {
	my $script = $r->{SCTX}->[0];
	my $name = ($script =~ m!^[^;]*?\bbegin\s+(\S+)!im) ? $1 : "unknown";
	return(lc($name));
    } elsif (defined $r->{NAME}) {
	return(lc(chop_nulls($r->{NAME}->[0])));
    } elsif (defined $r->{INDX}) {
	return(unpack("L", $r->{INDX}->[0]));
    } elsif ($rec_type eq "LAND") {
	my($x, $y) = unpack("ll", $r->{INTV}->[0]);
	return("($x, $y)");
    }
    return(undef);
}

# load all the records from a master .esm into a dictionary.
my %LOADED_ESM;		# reused from plugin to plugin
sub load_master {
    my($datadir, $esm, $label) = @_;
    if (defined $LOADED_ESM{$esm}) {
	print "DBG: re-using master data: $esm\n" if (DBG);
	return;
    }
    my $dirlist = list_files($datadir);
    $esm = $dirlist->{lc($esm)};
    print "DBG: loading $datadir/$esm\n" if (DBG);
    #TBD try finding master in same directory as plugin first, then in datadir
    unless(open(INP, "<$datadir/$esm")) {
	warn "Error opening $label $datadir/$esm for loading ($!)\n";
	return;
    }
    unless (binmode(INP)) {
	warn "Error setting binmode on $label $datadir/$esm ($!)\n";
	close(INP);
	return;
    }
    $LOADED_ESM{$esm}++;
    my $read_info = ($CHK_CHANGED_INFO_IDS or $CHK_DUPLICATE_INFO or $CHK_MODIFIED_INFO);
    while(my($rec_type, $rec, $flags) = read_rec(undef)) {
	last if not defined $rec_type;
	if ($flags & 0x1000) {
	    print "Master($esm) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	print "DBG: rec_type = $rec_type\n" if (DBG);
	if ($read_info and $rec_type eq "INFO") {
	    my $r = parse_subrec_hash($rec);
	    my $id = chop_nulls($r->{INAM}[0]);
	    # use the chunk of the record following "NNAM" as the value of the INFO record.
	    # this ignores the INAM, PNAM, NNAM subrec which are used for dialog sorting.
	    my $val = (split(/NNAM....\d*\000/, $rec, 2))[1];
	    $MASTER_INFO{$esm}->{$id} = $val;
	    $MASTER_INFTXT{$esm}->{$id} = $r->{NAME}[0];
	    print "DBG: INFO($esm) $id = $val\n" if (DBG);
	} else {
	    if ($CHK_OVERRIDDEN_REC) {
		my $id = rec_id(parse_subrec_hash($rec), $rec_type);
		if (defined $id) {
		    $MASTER_ID{$esm}->{$rec_type}->{$id} = 1;
		}
	    }
	    $MASTER_REC{$esm}->{$rec_type}->{$rec} = 1;
	}
    }
    close(INP);
}

# load all the masters into memory
sub load_all_masters {
    my $datadir = find_datadir();
    print "DBG: loading masters, datadir = $datadir\n" if (DBG);
    @MASTERS = sort_by_date($datadir, @MASTERS);
    foreach my $master (@MASTERS) {
	load_master($datadir, $master, "Master");
    }
}

# read next TES3 record from a plugin
my $hdr_size = 16;
sub read_rec {
    my($expected_type) = @_;
    my $rec_hdr = "";
    my $n_read = sysread(INP, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef);
    }
    if ($n_read != $hdr_size) {
	warn "Error(hdr): asked for $hdr_size bytes, got $n_read\n";
	return(undef);
    }
    my($rec_type, $rec_len, $flags) = unpack("a4Lx[L]L", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rec_type) {
	warn "Error: Expected: $expected_type, got: $rec_type\n";
	return(undef);
    }
    my $rec = "";
    $n_read = sysread(INP, $rec, $rec_len);
    if ($n_read != $rec_len) {
	warn "Error(rec): asked for $rec_len bytes, got $n_read\n";
	return(undef);
    }
    return($rec_type, $rec, $flags);
}

# this version takes a little longer to execute
sub parse_subrec_hash_long {
    my($rec) = @_;
    my %r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@{$r{$subrec_type}}, $val) if (defined $val);
	$p += $subrec_len;
    }
    return(\%r);
}

sub parse_subrec_hash {
    my($rec) = @_;
    my %r = ();
    my @parts = eval { unpack("(a4L/a*)*", $rec); };
    return(parse_subrec_hash_long($rec)) if ($@);
    while (@parts) {
	my $subrec_type = shift(@parts);
	my $subrec_val = shift(@parts);
	push(@{$r{$subrec_type}}, $subrec_val)
	    if (defined $subrec_val);
    }
    return(\%r);
}

# return only the given type of sub-records from the given record as a list ref.
sub get_subrec {
    my($rec, $subtype) = @_;
    my @r = ();
    my(@parts) = unpack("(a4L/a*)*", $rec);
    while (@parts) {
	my $subrec_type = shift(@parts);
	my $subrec_val = shift(@parts);
	push(@r, $subrec_val)
	    if ($subrec_type eq $subtype);
    }
    return(\@r);
}

# scan the script text for various function usage.
my %tbfun;
my %bmfun;
my %deplst;
my %getsound;
my %menumode;
sub scan_script {
    my($script, $label) = @_;
    print "SCRIPT:\n$script\n\n" if (DBG and $::opt_v);
    # remove comments and blank lines from the script
    $script =~ s/$RE_IGNORE//gm;
    if ($CHK_EXPANSION_FUNCTIONS or $CHK_NO_EXPANSION_FUNS) {
	while ($script =~ m!$RE_TBFUN!gim) {
	    print "TBFUN($label): $1\n" if (DBG);
	    $tbfun{"$label\t".lc($1)}++;
	}
	while ($script =~ m!$RE_BMFUN!gim) {
	    print "BMFUN($label): $1\n" if (DBG);
	    $bmfun{"$label\t".lc($1)}++;
	}
    }
    if ($CHK_DEPRECATED_LISTFUN) {
	while ($script =~ m!$RE_DEPLST!gim) {
	    print "DEPLST($label): $1\n" if (DBG);
	    $deplst{"$label\t".lc($1)}++;
	}
    }
    if ($CHK_GETSOUNDPLAYING) {
	while ($script =~ m!$RE_GETSOUND!gis) {
	    my $next_line = $1;
	    if ($next_line !~ m!$RE_SOUND!i) {
		$getsound{$label}++;
	    }
	}
    }
    if ($label !~ /^INFO/ and $OPTFLAG{MENUMOD} and ($script !~ m!$RE_MENUMODE!gis)) {
	$menumode{$label}++;
    }
}

# chop up a GMST record and return the value portion in hexified string form
# this is used to compare against known Evil GMST records similarly hexified
# which are stored in the DATA segment of this script.
sub gmstval {
    my($rec, $plugin_path) = @_;
    my $r = parse_subrec_hash($rec);
    my $id = rec_id($r, "GMST");
    delete $r->{NAME};
    my @keys = keys %$r;
    if (scalar(@keys) > 1) {
	warn "$plugin_path: Error, too many keys for GMST $id: @{[Dumper($r)]}\n";
    }
    my $type = $keys[0];
    my $val = $r->{$type}[0];
    return($id, unpack("h*", "$type $val"));
}

# format a simple report for the given items
sub report {
    my($items, $label) = @_;
    my @itemlist = sort keys %$items;
    if (@itemlist) {
	my $format = "\t%-35s  %s\n";
	print "    $label:\n";
	foreach (@itemlist) {
	    my($name, $val) = split(/\t/, $_, 2);
	    if ($val) {
		printf $format, $name, $val;
	    } else {
		print "\t$name\n";
	    }
	}
    }
}

sub report_recs {
    my($recs, $title) = @_;
    if (%{$recs}) {
	my @output = ();
	my $format = "\t%-16s    %4s    %s\n";
	foreach my $rec_type (sort keys %{$recs}) {
	    foreach my $name (sort { lc($a) cmp lc($b) } keys %{$recs->{$rec_type}}) {
		my $master = $recs->{$rec_type}->{$name};
		push(@output, sprintf $format, $master, $rec_type, $name);
	    }
	}
	if (@output) {
	    print "    $title:\n";
	    printf $format, "From Master", "Type", "Name";
	    print sort @output;
	}
    }
}

sub pprec {
    my($rec, $subtype) = @_;
    print "DBG: pprec($rec)\n" if (DBG);
    my $recstr = join(":", grep(!/[^[:print:]]/, map { s/[\000]+$//gm; tr/\r\n/ /; $_; } split(/\000?([A-Z][A-Z_][A-Z_][A-Z_\d])...\000/, $rec)));
    $recstr =~ s/^:$subtype:.*?:// if ($subtype);
    $recstr =~ s/:([A-Z][A-Z_][A-Z_][A-Z_\d])/|$1/g;
    return(substr($recstr, 0, $::opt_w));
}

# this is the main routine that scans a plugin for potential problems.
sub scan {
    my($plugin_path) = @_;
    my $plugin = (split(m![\\/]!, $plugin_path))[-1];
    warn "### Scanning $plugin_path\n" if ($::opt_v);
    unless(open(INP, "<$plugin_path")) {
	warn "Error opening $plugin_path for input ($!)\n";
	return;
    }
    unless (binmode(INP, ':raw')) {
	warn "Error setting binmode on $plugin_path ($!)\n";
	close(INP);
	return;
    }
    @MASTERS = ();
    # the following are globals used by scan_script
    %tbfun = ();
    %bmfun = ();
    %deplst = ();
    %getsound = ();
    %menumode = ();
    # locals
    my %evil = ();
    my $evil_tb = 0;
    my $evil_bm = 0;
    my @fogsync = ();
    my @autospl = ();
    my %fogbug = ();
    my %myinf = ();
    my %myinftxt = ();
    my %myrec = ();
    my %myid = ();
    my %door = ();
    my %myjunk = ();
    my $missauth = 0;
    my $missdesc = 0;
    my $missver = 0;
    my @sscr = ();
    my $mastbm = 0;
    my $masttb = 0;
    my $cell00 = undef;
    my $expected = "TES3";
    my $cur_dial;
    my $read_info = ($CHK_CHANGED_INFO_IDS or $CHK_DUPLICATE_INFO or $CHK_MODIFIED_INFO);
    my $read_scpt = ($CHK_EXPANSION_FUNCTIONS or $CHK_NO_EXPANSION_FUNS or $CHK_DEPRECATED_LISTFUN or $CHK_GETSOUNDPLAYING or $OPTFLAG{MENUMOD});
    my $read_gmsts = ($OPTFLAG{EVLGMST} or $CHK_DUP_REC or $CHK_OVERRIDDEN_REC);
    my $read_cell = ($OPTFLAG{JUNKCEL} or $CHK_FOG_DENSITY or $CHK_DUP_REC);
    my %dial_info = ();
    while (my($rec_type, $rec, $flags) = read_rec($expected)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	if ($flags & 0x1000) {
	    print "REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	if ($rec_type eq "TES3") {
	    my $r = parse_subrec_hash($rec);
	    if ($CHK_HEADER_FIELDS) {
		my $hedr = $r->{HEDR}[0];
		my($hedrver, $auth, $desc, $nrec) = unpack("fx[L]a32a256L", $hedr);
		printf "DBG: TES3.HEDR.version = %0.3f  NumRecords = %d\n", $hedrver, $nrec if (DBG);
		$auth = chop_nulls($auth);
		$missauth++ if (length($auth) == 0);
		$desc = chop_nulls($desc);
		if (length($desc) == 0) {
		    $missdesc = $missver = 1;
		} elsif ($desc !~ /^(Version:?) *([-0-9\.]*\+?) *\r?$/m) {
		    $missver++;
		}
	    }
	    for my $mast (@{$r->{MAST}}) {
		$mast = chop_nulls($mast);
		push(@MASTERS, $mast);
		print "Master: $mast\n" if (DBG);
		$mastbm++ if (lc($mast) eq 'bloodmoon.esm');
		$masttb++ if (lc($mast) eq 'tribunal.esm');
	    }
	} elsif ($read_gmsts and $rec_type eq "GMST") {
	    # check for evil GMSTs
	    my($name, $val) = gmstval($rec, $plugin_path);
	    print "DBG: GMST=$name val=$val tb=$TB_EVIL{$name} bm=$BM_EVIL{$name}\n" if (DBG);
	    if ($val eq $TB_EVIL{$name}) {
		$evil{"TB $name"}++;
		$evil_tb++;
	    } elsif ($val eq $BM_EVIL{$name}) {
		$evil{"BM $name"}++;
		$evil_bm++;
	    } else {
		$myrec{$rec} = $name if ($CHK_DUP_REC);
	    }
	    $myid{$rec_type}->{$name}++ if ($CHK_OVERRIDDEN_REC);
	} elsif ($CHK_EXPANSION_FUNCTIONS and $rec_type eq "SSCR") {
	    # check for startup script dependency
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    push(@sscr, $id);
	    $myid{$rec_type}->{$id}++ if ($CHK_OVERRIDDEN_REC);
	} elsif ($read_info and $rec_type eq "INFO") {
	    # check for tribunal/bloodmoon function dependency in infos
	    my $r = parse_subrec_hash($rec);
	    my $id = $r->{INAM}[0];
	    $id = chop_nulls($id);
	    my $script = $r->{BNAM}[0];
	    scan_script($script, "INFO($id)") if ($read_scpt);
	    $myinf{$id} = (split(/NNAM....\d*\000/s, $rec, 2))[1];
	    #print "\nDBG: myinf{$id}=$myinf{$id}\n  rec=$rec\n" if ($rec =~ /ra'virr/);
	    print "DBG: MYINF($plugin) $id = $myinf{$id}\n" if (DBG);
	    push(@{$myinftxt{$r->{NAME}[0]}}, $id);
	    $dial_info{$cur_dial}->{$id} = 0;
	} elsif ($rec_type eq "SCPT") {
	    # check for tribunal/bloodmoon function dependency in scripts
	    my $script = get_subrec($rec, "SCTX")->[0];
	    my $name = ($script =~ m!^[^;]*?\bbegin\s+(\S+)!im) ? $1 : "unknown";
	    scan_script($script, "SCPT($name)") if ($read_scpt);
	    $myrec{$rec} = $name if ($CHK_DUP_REC);
	    $myid{$rec_type}->{lc($name)}++ if ($CHK_OVERRIDDEN_REC);
	} elsif ($read_cell and $rec_type eq "CELL") {
	    # check for fogbugs in cells
	    my $r = parse_subrec_hash($rec);
	    my $name = chop_nulls($r->{NAME}[0]);
	    my $data = $r->{DATA}[0];
	    my($flags, $fog_den_data) = unpack("Lx[L]f", $data);
	    my $fogsync;
	    if ($flags & 1) {	# interior cells
		if ($CHK_FOG_DENSITY and not $flags & 128) { # behave like exterior
		    my $ambi = $r->{AMBI}[0];
		    if (length($ambi) == 16) {
			my $fog_den_ambi = unpack("x[L3]f", $ambi);
			$fogbug{$name}++ if ($fog_den_ambi == 0.0);
			$fogsync = sprintf("DATA:%0.2f  !=  AMBI:%0.2f", $fog_den_data, $fog_den_ambi)
			    if ($fog_den_ambi != $fog_den_data);
		    } else {
			print "DBG: Error: CELL($name), AMBI subrecord length is @{[length($ambi)]}, not 16)\n" if (DBG);
			$fogbug{$name}++ if ($fog_den_data == 0.0);
		    }
		}
		$myrec{$rec} = $name if ($CHK_DUP_REC);
	    } else {		# exterior cells
		my($xname, $x, $y) = ext_cell_name($r);
		$name = ($name) ? "$name ($x, $y)" : $xname;
		if ($x == 0 and $y == 0) {
		    print "DBG: CELL00: $rec\n" if (DBG);
		    my $frmr = (defined $r->{FRMR}) ? scalar(@{$r->{FRMR}}) : 0;
		    $cell00 = "Refcount of CELL == 155" if ($frmr == 155);
		}
		my $nkeys = scalar(keys %$r);
		if (($nkeys == 2) or ($nkeys == 3)) {
		    $myjunk{$name} = $flags if ($OPTFLAG{JUNKCEL});
		} else {
		    $myrec{$rec} = $name if ($CHK_DUP_REC);
		}
	    }
	    if (defined $fogsync) {
		push(@fogsync, sprintf "%-35s  %s", $name, $fogsync);
	    }
	} elsif ($CHK_AUTOCALCED_SPELLS and ($rec_type eq "SPEL")) {
	    my $r = parse_subrec_hash($rec);
	    my $spdt = $r->{SPDT}[0];
	    if (my $autocalc = (unpack("x[L2]L", $spdt) & 1)) {
		my $id = rec_id($r, $rec_type);
		my $name = chop_nulls($r->{FNAM}[0]);
		push(@autospl, sprintf("%-30s %s", $id, $name));
		$myid{$rec_type}->{$id}++ if ($CHK_OVERRIDDEN_REC);
	    }
	} elsif ($rec_type eq "DOOR") {
	    my $r = parse_subrec_hash($rec);
	    my $id = rec_id($r, $rec_type);
	    if ($CHK_SCRIPTED_DOORS) {
		my $scri = chop_nulls($r->{SCRI}[0]);
		if ($scri and $BETHDOOR{$id}) {
		    $door{"$id\t$scri"}++;
		}
	    }
	    $myrec{$rec} = $id if ($CHK_DUP_REC);
	    $myid{$rec_type}->{$id}++ if ($CHK_OVERRIDDEN_REC);
	} elsif ($rec_type eq "DIAL") {
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    $cur_dial = $id;
	    if (defined $id) {
		$myid{$rec_type}->{$id}++ if ($CHK_OVERRIDDEN_REC);
	    }
	} else {
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    if (defined $id) {
		$myrec{$rec} = $id if ($CHK_DUP_REC);
		$myid{$rec_type}->{$id}++ if ($CHK_OVERRIDDEN_REC);
	    }
	}
    }
    close(INP);
    my $dup_inf = 0;
    my $mod_inf = 0;
    my $mod_iid = 0;
    my $inf_out = "";
    my %junkcell = ();
    if (%myjunk) {
	load_all_masters();
	foreach my $master (keys %MASTER_REC) {
	    my $cell_recs = $MASTER_REC{$master}->{CELL};
	    foreach my $rec (keys %{$cell_recs}) {
		my $r = parse_subrec_hash($rec);
		my($oldflags) = unpack("L", $r->{DATA}[0]);
		if (not ($oldflags & 1)) {
		    my($name) = ext_cell_name($r);
		    if ($myjunk{$name} and ($oldflags == $myjunk{$name})) {
			$junkcell{$name} = $oldflags;
		    }
		}
	    }
	}
    }
    my %dup_recs = ();
    if (%myrec) {		# find records duplicated from masters
	load_all_masters();
	while (my($master, $all_recs) = each %MASTER_REC) {
	    while (my($rec_type, $type_recs) = each %{$all_recs}) {
		while (my($rec, $id) = each %myrec) {
		    if ($type_recs->{$rec}) {
			next if ($rec_type eq "DIAL");
			next if (($rec_type eq "GMST") and ($TB_EVIL{$id} or $BM_EVIL{$id}));
			$dup_recs{$rec_type}->{$id} = $master;
		    }
		}
	    }
	}
    }
    my %ovr_recs = ();
    if (%myid) {
	load_all_masters();
	while (my($rec_type, $ids) = each %myid) {
	    foreach my $id (keys %{$ids}) {
		foreach my $master (keys %MASTER_ID) {
		    if ($MASTER_ID{$master}->{$rec_type}->{$id}) {
			unless($dup_recs{$rec_type}->{$id} or ($rec_type eq "DIAL")) {
			    $ovr_recs{$rec_type}->{$id} = $master;
			}
		    }
		}
	    }
	}
    }
    my %info_master = ();
    if (%myinf) {		# analyze info problems
	load_all_masters();
	my %master_inf = ();
	my %inf_master = ();	# map back to the master the info came from.
	foreach my $master (@MASTERS) {
	    my $master_info = $MASTER_INFO{$master};
	    while (my($id, $inf) = each %{$master_info}) {
		$master_inf{$id} = $inf;
		$inf_master{"$id$inf"} = $master;
	    }
	}
	my %rev_master = ();
	while (my($id, $inf) = each %master_inf) {
	    $rev_master{$inf} = $id;
	}
	foreach my $id (sort {$a <=> $b} keys %myinf) {
	    my $inf = $myinf{$id};
	    my $inf_str = pprec($inf);
	    if (defined($master_inf{$id})) { # when the master contains an info with the same ID as in the plugin
		if ($master_inf{$id} eq $inf) {
		    # infos in plugin that are duplicates of info from a master
		    foreach my $dial_id (keys %dial_info) {
			$dial_info{$dial_id}->{$id}++;
		    }
		    if ($CHK_DUPLICATE_INFO) {
			$dup_inf++;
			$inf_out .= "\n[DUP-INF]: ID=$id\n";
			$inf_out .= "  $inf_str\n";
		    }
		} else {
		    # infos in plugin that are modifications info from a master
		    if ($CHK_MODIFIED_INFO) {
			my $mod_out = "";
			my $mast_inf_str = pprec($master_inf{$id});
			my $master = $inf_master{"$id$master_inf{$id}"};
			my $maxlen = (length($plugin) > length($master)) ? length($plugin) : length($master);
			my $plugin_pref = $plugin . "-"x($maxlen - length($plugin));
			my $master_pref = $master . "-"x($maxlen - length($master));
			$mod_out .= "\n[MOD-INF]: ID=$id\n";
			$mod_out .= "  ${master_pref}->$mast_inf_str\n";
			$mod_out .= "  ${plugin_pref}->$inf_str\n";
			if ($OPTFLAG{'MOD-INF'}) {
			    $mod_inf++;
			    $inf_out .= $mod_out;
			}
			if ($CHK_CHANGED_INFO_IDS) {
			    my $inftxt = $MASTER_INFTXT{$master}->{$id};
			    my @ids = ();
			    foreach my $id (grep(($_ ne $id and not $MASTER_INFTXT{$master}->{$_}), @{$myinftxt{$inftxt}})) {
				my $r = parse_subrec_hash($myinf{$id});
				my $disp = (length($r->{DATA}[0]) > 7) ? unpack("x[L]L", $r->{DATA}[0]) : 0;
				push(@ids, $id) if ($disp == 0 and not defined $r->{BNAM});
			    }
			    if ($myinftxt{$inftxt} and @ids) {
				$mod_iid++;
				my $pl = (scalar(@ids) > 1) ? "s" : "";
				$inf_out .= $mod_out;
				$inf_out .= "[MOD-IID]: ID$pl=@{[join(',', @ids)]}\n";
				$inf_out .= "  ${plugin_pref}->$inftxt\n";
			    }
			}
		    }
		}
	    }
	}
    }
    my %dup_dial = ();
    if (%dial_info) {
	foreach my $dial_id (%dial_info) {
	    foreach my $master (keys %MASTER_ID) {
		if ($MASTER_ID{$master}->{DIAL}->{$dial_id}) {
		    # for every DIAL id that also is in the master ...
		    my $all_infos_duped = 1;
		    foreach my $info_id (keys %{$dial_info{$dial_id}}) {
			if ($dial_info{$dial_id}->{$info_id} == 0) {
			    $all_infos_duped = 0;
			    last;
			}
		    }
		    if ($all_infos_duped) {
			# all of the infos for this dial were duped from the master
			$dup_dial{DIAL}->{$dial_id} = $master;
		    } else {
			$ovr_recs{DIAL}->{$dial_id} = $master;
		    }
		}
	    }
	}
    }
    # create a summary line of things we have discovered.
    my $found = "";
    $found .= " AUTOSPL" if (@autospl);
    $found .= " CELL00"  if ($cell00);
    $found .= " BM-DEP"  if ((not $mastbm) and %bmfun);
    $found .= " DEP-LST" if (%deplst);
    $found .= " DUP-INF" if ($dup_inf);
    $found .= " DUP-REC" if (%dup_recs);
    $found .= " EXP-DEP" if (not $masttb and not $mastbm and (@sscr or %tbfun));
    $found .= " FOGBUG"  if ($OPTFLAG{FOGBUG} and %fogbug);
    $found .= " FOGSYNC" if ($OPTFLAG{FOGSYNC} and @fogsync);
    $found .= " GETSND"  if (%getsound);
    $found .= " EVLGMST" if (%evil);
    $found .= " JUNKCEL" if (%junkcell);
    $found .= " MENUMOD" if (%menumode);
    $found .= " MISSAUT" if ($OPTFLAG{MISSAUT} and $missauth);
    $found .= " MISSDSC" if ($OPTFLAG{MISSDSC} and $missdesc);
    $found .= " MISSVER" if ($OPTFLAG{MISSVER} and $missver);
    $found .= " MOD-INF" if ($mod_inf and $OPTFLAG{'MOD-INF'});
    $found .= " MOD-IID" if ($mod_iid);
    $found .= " OVR-REC" if (%ovr_recs);
    $found .= " SCRDOOR" if (%door);
    if ($CHK_NO_EXPANSION_FUNS) {
	$found .= " !BM-FUN" if ($OPTFLAG{'!BM-FUN'} and $mastbm and not(%bmfun or @sscr));
	$found .= " !TB-FUN" if ($OPTFLAG{'!TB-FUN'} and $masttb and not(%tbfun or %bmfun or @sscr));
    }
    if ($found) {
	print "$plugin_path:$found\n";
    } else {
	print "$plugin_path: CLEAN\n" if ($OPTFLAG{CLEAN});
	return;
    }
    ##################################################
    # now print out verbose detail, if applicable
    ##################################################
    if (@autospl) {
	print "    [AUTOSPL] Auto-calced Spells:\n";
	foreach my $spell (@autospl) {
	    print "\t$spell\n";
	}
    }
    if ($cell00) {
	print "    [CELL00]: $cell00\n";
    }
    if (@sscr and not $masttb and not $mastbm) {
	my $pl = (scalar(@sscr) > 1) ? "s" : "";
	print "    [EXP-DEP] Expansion Dependency: Startup Script$pl: ", join(", ", @sscr), "\n";
    }
    report(\%tbfun, "[EXP-DEP] Expansion Dependency: Tribunal Functions") if (not $masttb and not $mastbm);
    report(\%bmfun, "[BM-DEP] Bloodmoon Dependency: Bloodmoon Functions") if ($OPTFLAG{'BM-DEP'} and not $mastbm);
    report(\%deplst, "[DEP-LST] Deprecated use of Leveled List functions on Bethesda Lists");
    report(\%evil, "[EVLGMST]" . (($evil_tb > 0)? " Tribunal($evil_tb)" : "") . (($evil_bm > 0)? " Bloodmoon($evil_bm)" : ""));
    if (%fogbug) {
	print "    [FOGBUG]: Cells with zero fog density setting:\n";
	print "\t$_\n" foreach (sort keys %fogbug);
    }
    if (@fogsync) {
	print "    [FOGSYNC]: Fog density settings unsynced:\n";
	foreach my $cell (@fogsync) {
	    print "\t$cell\n";
	}
    }
    report(\%getsound, "[GETSND] GetSoundPlaying possibly used to detect events");
    report(\%menumode, "[MENUMOD] Scripts not checking menumode");
    report(\%door, "[SCRDOOR] Bethesda doors that have had scripts attached to them");
    if (%junkcell) {
	if ($::opt_v) {
	    print "    [JUNKCEL] Junk Cells:                        Flags\n";
	} else {
	    print "    [JUNKCEL] Junk Cells:\n";
	}
	my $format = "\t%-36s     0x%02x\n";
	foreach my $name (sort keys %junkcell) {
	    if ($::opt_v) {
		my $flags = $junkcell{$name};
		printf $format, $name, $flags;
	    } else {
		printf "\t$name\n";
	    }
	}
    }
    report_recs(\%dup_dial, "[DUP-DIAL] Duplicate Dialog Records");
    report_recs(\%dup_recs, "[DUP-REC] Duplicate Records");
    report_recs(\%ovr_recs, "[OVR-REC] Overridden Records");
    $| = 1;			# flush STDOUT
    print $inf_out;
    if (open(STAT, "/proc/$$/status")) {
	while (<STAT>) {
	    if (/^VmRSS:\s*(\d+)/) {
		my $vmsize = $1 / 1024;
		warn "### tes3lint($plugin) Memory Usage: $vmsize (MB)\n" if ($::opt_v);
	    }
	}
	close(STAT);
    }
    $| = 0;
}

# run the program.
load_data();
for my $plugin (@ARGV) {
    eval { scan($plugin); };
    warn "$plugin: Error scanning: $@\n" if ($@);
}

# Data segment follows.
__DATA__
# Tribunal Functions
AddToLevCreature
AddToLevItem
ClearForceJump
ClearForceMoveJump
ClearForceRun
DisableLevitation
EnableLevitation
ExplodeSpell
ForceJump
ForceMoveJump
ForceRun
GetCollidingActor
GetCollidingPC
GetForceJump
GetForceMoveJump
GetForceRun
GetPCJumping
GetPCRunning
GetPCSneaking
GetScale
GetSpellReadied
GetSquareRoot
GetWaterLevel
GetWeaponDrawn
GetWeaponType
HasItemEquipped
ModScale
ModWaterLevel
PlaceItem
PlaceItemCell
RemoveFromLevCreature
RemoveFromLevItem
SetDelete
SetScale
SetWaterLevel
# END-OF-LIST for Tribunal functions
# Bloodmoon Functions
BecomeWerewolf
GetPCInJail
GetPCTraveling
GetWerewolfKills
IsWerewolf
PlaceAtMe
SetWerewolfAcrobatics
TurnMoonRed
TurnMoonWhite
UndoWerewolf
# END-OF-LIST for Bloodmoon Functions
# Standard Bethesda Leveled Lists
BM_Imperial Guard Random Weapon
Imperial Guard Random Helmet
Imperial Guard Random LPauldron
Imperial Guard Random RPauldron
Imperial Guard Random Shield
Imperial Guard Random Skirt
Imperial Guard Random Weapon
bm_ex_berserkers
bm_ex_felcoast
bm_ex_felcoast_40
bm_ex_felcoast_60
bm_ex_felcoast_sleep
bm_ex_hirforest
bm_ex_hirforest_40
bm_ex_hirforest_60
bm_ex_hirforest_sleep
bm_ex_horker_h20
bm_ex_horker_lake
bm_ex_isinplains
bm_ex_isinplains_40
bm_ex_isinplains_60
bm_ex_isinplains_sleep
bm_ex_moemountains
bm_ex_moemountains_40
bm_ex_moemountains_60
bm_ex_moemountains_sleep
bm_ex_reaver_archers
bm_ex_reavers
bm_ex_rieklingpatrols
bm_ex_rieklingpatrols_20
bm_ex_rieklingpatrols_40
bm_ex_rieklingpatrols_60
bm_ex_smugglers
bm_ex_wolfpack
bm_ex_wolfpack_20
bm_ex_wolfpack_40
bm_ex_wolfpack_60
bm_frysehag_all
bm_in_berserker_20
bm_in_berserker_40
bm_in_berserker_60
bm_in_frysehag_20
bm_in_frysehag_40
bm_in_frysehag_8
bm_in_icecaves
bm_in_icecaves_40
bm_in_icecaves_60
bm_in_nordburial
bm_in_nordburial_40
bm_in_nordburial_60
bm_random_nordictomb
bm_random_nordsilver
bm_random_riekling_loot
bm_randomboots_smugglers
bm_randomcuirass_smugglers
bm_randomgreaves_smugglers
bm_randomhealth_smugglers
bm_randomhelmet_smugglers
bm_randomleft_smugglers
bm_randomloot_smugglers
bm_randomright_smugglers
bm_randomshield_smugglers
bm_randomweapon_berserker
bm_randomwpn_smugglers
bm_werewolf_Connor
bm_werewolf_wilderness01
bm_werewolf_wilderness02
bm_werewolf_wilderness03
bm_werewolf_wilderness04
bm_werewolf_wilderness05
bm_werewolf_wilderness06
bm_werewolf_wilderness07
bm_werewolf_wilderness08
bm_werewolf_wilderness09
db_assassins
ex_RedMtn_all_lev[+]0
ex_RedMtn_all_lev[+]2
ex_RedMtn_all_lev-2
ex_RedMtn_all_sleep
ex_ascadianisles_lev[+]0
ex_ascadianisles_lev[+]2
ex_ascadianisles_lev-1
ex_ascadianisles_sleep
ex_azurascoast_lev[+]0
ex_azurascoast_lev[+]2
ex_azurascoast_lev-1
ex_azurascoast_sleep
ex_bittercoast_lev[+]0
ex_bittercoast_lev[+]2
ex_bittercoast_lev-1
ex_bittercoast_sleep
ex_grazelands_lev[+]0
ex_grazelands_lev[+]2
ex_grazelands_lev-1
ex_grazelands_sleep
ex_molagmar_lev[+]0
ex_molagmar_lev[+]2
ex_molagmar_lev-1
ex_molagmar_sleep
ex_sheogorad_lev[+]0
ex_sheogorad_lev[+]2
ex_sheogorad_lev-1
ex_sheogorad_sleep
ex_shore_all_lev[+]0
ex_shore_all_lev[+]2
ex_shore_all_lev-2
ex_shore_cliffracer_lev[+]0
ex_shore_cliffracer_lev[+]2
ex_shore_cliffracer_lev-2
ex_shore_mudcrab
ex_westgash_lev[+]0
ex_westgash_lev[+]2
ex_westgash_lev-1
ex_westgash_sleep
ex_wild_all_lev[+]0
ex_wild_all_lev[+]2
ex_wild_all_lev-1
ex_wild_all_sleep
ex_wild_netch_lev[+]0
ex_wild_netch_lev[+]2
ex_wild_netch_lev-1
ex_wild_rat_lev[+]0
ex_wild_rat_lev[+]2
ex_wild_rat_lev-2
goblin_health
goblin_weapons_random
h2o_all_lev[+]0
h2o_all_lev[+]2
h2o_all_lev-2
h2o_slaughterfish
in_6th_all_lev[+]0
in_6th_all_lev[+]2
in_6th_all_lev-2
in_6th_ash_lev[+]0
in_6th_ash_lev[+]2
in_6th_ash_lev-2
in_cave_alit_lev[+]0
in_cave_alit_lev[+]2
in_cave_alit_lev-1
in_cave_all_lev[+]0
in_cave_all_lev[+]2
in_cave_all_lev-1
in_cave_kagouti_lev[+]0
in_cave_kagouti_lev[+]2
in_cave_kagouti_lev-1
in_cave_nix_lev[+]0
in_cave_nix_lev[+]2
in_cave_nix_lev-1
in_dae_all_lev[+]0
in_dae_all_lev[+]2
in_dae_all_lev-2
in_dae_atronach_lev[+]0
in_dae_atronach_lev[+]2
in_dae_atronach_lev-2
in_dae_clanfear_lev[+]0
in_dae_clanfear_lev[+]2
in_dae_clanfear_lev-2
in_dae_dremora_lev[+]0
in_dae_dremora_lev[+]2
in_dae_dremora_lev-2
in_durzogs
in_dwe_all_lev[+]0
in_dwe_all_lev[+]2
in_dwe_all_lev-2
in_dwe_all_tribunal
in_dwe_cent_lev[+]0
in_dwe_cent_lev[+]2
in_dwe_cent_lev-2
in_egg_all_lev[+]0
in_egg_all_lev[+]2
in_egg_all_lev-1
in_egg_kwama_blight_lev[+]0
in_egg_kwama_blight_lev[+]2
in_egg_kwama_blight_lev-1
in_egg_kwama_lev[+]0
in_egg_kwama_lev[+]2
in_egg_kwama_lev-1
in_egg_kwama_mined
in_egg_scrib_lev[+]0
in_egg_scrib_lev[+]2
in_egg_scrib_lev-1
in_goblins
in_tomb_all_lev[+]0
in_tomb_all_lev[+]2
in_tomb_all_lev-2
in_tomb_all_lev_trib
in_tomb_bone_lev[+]0
in_tomb_bone_lev[+]2
in_tomb_bone_lev-2
in_tomb_skele_lev[+]0
in_tomb_skele_lev[+]2
in_tomb_skele_lev-2
in_vamp_cattle
in_vamp_cattle_aun
in_vamp_cattle_ber
in_vamp_cattle_qua
l_b_Bandit_goods
l_b_amulets
l_b_loot_tomb
l_b_loot_tomb01
l_b_loot_tomb02
l_b_loot_tomb03
l_b_rings
l_m_amulets
l_m_armor
l_m_armor_boots
l_m_armor_bracers
l_m_armor_cuirass
l_m_armor_gauntlet
l_m_armor_helmet
l_m_armor_shields
l_m_belts
l_m_enchantitem_hlaalu_rank0
l_m_enchantitem_hlaalu_rank4
l_m_enchantitem_hlaalu_rank6
l_m_enchantitem_imperial_rank0
l_m_enchantitem_redoran_rank2
l_m_enchantitem_redoran_rank4
l_m_enchantitem_redoran_rank6
l_m_enchantitem_redoran_rank8
l_m_enchantitem_telvanni_rank01
l_m_enchantitem_telvanni_rank6
l_m_enchantitem_telvanni_rank8
l_m_enchantitem_temple_rank0_1
l_m_enchantitem_temple_rank0_2
l_m_enchantitem_temple_rank4
l_m_enchantitem_temple_rank6
l_m_enchantitem_temple_rank8_1
l_m_enchantitem_temple_rank8_2
l_m_potion
l_m_potion_h
l_m_rings
l_m_wpn_melee
l_m_wpn_melee_axe
l_m_wpn_melee_blunt
l_m_wpn_melee_long blade
l_m_wpn_melee_short blade
l_m_wpn_melee_spear
l_m_wpn_missle
l_m_wpn_missle_arrow
l_m_wpn_missle_bolt
l_n_amulet
l_n_apparatus
l_n_armor
l_n_armor_boots
l_n_armor_bracers
l_n_armor_cuirass
l_n_armor_gauntlet
l_n_armor_greaves
l_n_armor_helmet
l_n_armor_pauldron
l_n_armor_shields
l_n_lockpicks
l_n_probe
l_n_repair item
l_n_rings
l_n_smuggled_goods
l_n_soul gem
l_n_wpn_melee
l_n_wpn_melee_axe
l_n_wpn_melee_blunt
l_n_wpn_melee_long blade
l_n_wpn_melee_short blade
l_n_wpn_melee_spear
l_n_wpn_melee_tomb
l_n_wpn_missle
l_n_wpn_missle_arrow
l_n_wpn_missle_bolt
l_n_wpn_missle_bow
l_n_wpn_missle_thrown
l_n_wpn_missle_xbow
l_vamp_cattle
misc_com_redware_bowl
random ashlander weapon
random ebony weapon
random excellent melee weapon
random gold
random gold_lev_05
random gold_lev_10
random gold_lev_15
random gold_lev_20
random orcish armor
random_Golden_saint_shield
random_Golden_saint_weapon
random_adamantium
random_alchemy_diff
random_alit_hide
random_ampoule_pod
random_armor_bonemold
random_armor_chitin
random_armor_fur
random_armor_glass
random_armor_iron
random_armor_netch_leather
random_armor_steel
random_ash_salts
random_ash_yam
random_bear_pelt
random_belladonna_plant
random_belladonna_spriggan
random_bittergreen_petals
random_black_anther
random_black_lichen
random_boar_leather
random_bonemeal
random_book_dunmer
random_book_imperial_dunmer
random_book_imperial_hlaalu
random_book_skill
random_book_wizard_all
random_book_wizard_evil
random_bulbs
random_bunglers_bane
random_cabbage
random_chokeweed
random_coda_flower
random_com_kitchenware
random_comberry
random_common_de_fclothes_01
random_common_de_mclothes_01
random_coprinus
random_corkbulb_root
random_cornberry
random_corprus_weepings
random_crab_meat
random_daedra_heart
random_daedra_skin
random_daedric_weapon
random_de_blueware_01
random_de_cheapfood_01_nc
random_de_cheapfood_01_ne
random_de_pants
random_de_pos_01
random_de_pos_01_nc
random_de_robe
random_de_shirt
random_de_shoes_common
random_de_weapon
random_diamond
random_dreugh_wax
random_drinks_01
random_drinks_nord
random_drinksndrugs_imp
random_dwarven_all
random_dwarven_ingredients
random_dwarven_misc
random_dwemer_armor
random_dwemer_coins
random_dwemer_weapon
random_ebony
random_ectoplasm
random_expensive_de_fclothes_02
random_expensive_de_mclothes_02
random_exquisite_de_fclothes1
random_exquisite_de_mclothes1
random_extravagant_de_fclothes1
random_extravagant_de_mclothes1
random_fire_petal
random_fire_salts
random_food
random_frost_salts
random_gem
random_ghoul_heart
random_glass_weapon
random_gold_kanet
random_golden_sedge
random_gravetar
random_green_lichen
random_guar_hide
random_hackle-lo_leaf
random_heartwood
random_heather
random_holly
random_horker_tusk
random_hound_meat
random_hypha_facia
random_imp_armor
random_imp_silverware
random_imp_weapon
random_ingredient
random_ingredient_diff
random_iron_fur_armor
random_iron_weapon
random_kagouti_hide
random_kresh_fiber
random_kwama egg
random_kwama_cuttle
random_loot_bonewalker
random_loot_bonewalker_greater
random_loot_special
random_marshmerrow
random_moon_sugar
random_muck
random_netch_leather
random_noble_sedge
random_nordic_weapons
random_nordictomb_rare
random_orcish_weapons
random_pearl
random_pos
random_potion_bad
random_racer_plumes
random_rat_meat
random_rawglass
random_red_guard_cloth_01
random_red_lichen
random_riekling_loot
random_roobrush
random_russula
random_rye
random_saltrice
random_scales
random_scamp_skin
random_scathecraw
random_scrap_metal
random_scrib_jelly
random_scroll_all
random_shalk_resin
random_silver_weapon
random_skooma
random_smuggler_1-5
random_smuggler_11[+]
random_smuggler_6-10
random_snowbear_pelt
random_snowwolf_pelt
random_spines
random_stalks
random_steel_weapon
random_stoneflower_petals
random_sweetpulp
random_timsa
random_trama_root
random_vampire_dust
random_void_salts
random_weapon_melee_basic
random_wickwheat
random_willow_anther
random_wolf_pelt
# END-OF-LIST for Bethesda lists
# Evil GMSTs Tribunal (values are hexencoded)
scompanionshare 354525650234f6d60716e696f6e6023586162756
scompanionwarningbuttonone 3545256502c456470247865602d656273656e61627970217579647e2
scompanionwarningbuttontwo 35452565022556475727e60247f60234f6d60716e696f6e60235861627560246963707c61697e2
scompanionwarningmessage 354525650295f6572702d656273656e61627970296370207f6f627562702e6f67702478616e602778656e60286560236f6e64727163647564602779647860297f657e2020295f6572702d656273656e6162797027796c6c602175796470296660297f6570246f602e6f6470276966756028696d60276f6c64602f6270276f6f646370247f602262796e67602869637020527f6669647026516c657560247f602160207f6379647966756026716c65756e2
sdeletenote 35452565024456c656475602e4f64756f3
seffectsummonfabricant 3545256502375466665636473557d6d6f6e664162627963616e647
slevitatedisabled 3545256502c456679647164796f6e602d6167696360246f6563702e6f6470277f627b60286562756e2
smagicfabricantid 354525650264162627963616e647
smaxsale 3545256502d41687023516c656
sprofitvalue 35452565020527f6669647026516c65756
steleportdisabled 35452565024556c65607f62747164796f6e602d6167696360246f6563702e6f6470277f627b60286562756e2
# END-OF-LIST for Evil GMSTs Tribunal
# Evil GMSTs Bloodmoon (values are hexencoded)
fcombatdistancewerewolfmod 64c4456502a99999e3
ffleedistance 64c44565020008b354
fwerewolfacrobatics 64c445650200006134
fwerewolfagility 64c445650200006134
fwerewolfalchemy 64c4456502000008f3
fwerewolfalteration 64c4456502000008f3
fwerewolfarmorer 64c4456502000008f3
fwerewolfathletics 64c445650200006134
fwerewolfaxe 64c4456502000008f3
fwerewolfblock 64c4456502000008f3
fwerewolfbluntweapon 64c4456502000008f3
fwerewolfconjuration 64c4456502000008f3
fwerewolfdestruction 64c4456502000008f3
fwerewolfenchant 64c4456502000008f3
fwerewolfendurance 64c445650200006134
fwerewolffatigue 64c445650200008c34
fwerewolfhandtohand 64c445650200008c24
fwerewolfhealth 64c445650200000004
fwerewolfheavyarmor 64c4456502000008f3
fwerewolfillusion 64c4456502000008f3
fwerewolfintellegence 64c4456502000008f3
fwerewolflightarmor 64c4456502000008f3
fwerewolflongblade 64c4456502000008f3
fwerewolfluck 64c4456502000008f3
fwerewolfmagicka 64c445650200008c24
fwerewolfmarksman 64c4456502000008f3
fwerewolfmediumarmor 64c4456502000008f3
fwerewolfmerchantile 64c4456502000008f3
fwerewolfmysticism 64c4456502000008f3
fwerewolfpersonality 64c4456502000008f3
fwerewolfrestoration 64c4456502000008f3
fwerewolfrunmult 64c445650200000cf3
fwerewolfsecurity 64c4456502000008f3
fwerewolfshortblade 64c4456502000008f3
fwerewolfsilverweapondamagemult 64c445650200000cf3
fwerewolfsneak 64c4456502000008f3
fwerewolfspear 64c4456502000008f3
fwerewolfspeechcraft 64c4456502000008f3
fwerewolfspeed 64c445650200006134
fwerewolfstrength 64c445650200006134
fwerewolfunarmored 64c445650200008c24
fwerewolfwillpower 64c4456502000008f3
iwerewolfbounty 94e445650201720000
iwerewolffightmod 94e445650246000000
iwerewolffleemod 94e445650246000000
iwerewolfleveltoattack 94e445650241000000
seditnote 35452565025446964702e4f64756
seffectsummoncreature01 3545256502375466665636473557d6d6f6e634275616475727560313
seffectsummoncreature02 3545256502375466665636473557d6d6f6e634275616475727560323
seffectsummoncreature03 3545256502375466665636473557d6d6f6e634275616475727560333
seffectsummoncreature04 3545256502375466665636473557d6d6f6e634275616475727560343
seffectsummoncreature05 3545256502375466665636473557d6d6f6e634275616475727560353
smagiccreature01id 354525650237d416769636342756164757275603139444
smagiccreature02id 354525650237d416769636342756164757275603239444
smagiccreature03id 354525650237d416769636342756164757275603339444
smagiccreature04id 354525650237d416769636342756164757275603439444
smagiccreature05id 354525650237d416769636342756164757275603539444
swerewolfalarmmessage 354525650295f657028616675602265656e602465647563647564602368616e67696e676026627f6d60216027756275677f6c666023747164756e2
swerewolfpopup 35452565027556275677f6c666
swerewolfrefusal 354525650295f657023616e6e6f6470246f602478696370216370216027756275677f6c666e2
swerewolfrestmessage 354525650295f657023616e6e6f64702275637470296e6027756275677f6c6660266f627d6e2
# END-OF-LIST for Evil GMSTs Bloodmoon
# Standard Bethesda doors
BM_IC_door_01
BM_IC_door_pelt
BM_IC_door_pelt_dark
BM_IC_door_pelt_wolf
BM_KA_door
BM_KA_door_dark
BM_KA_door_dark_02
BM_KA_door_dark_SG
BM_KA_door_dark_udyr
BM_KarstCav_Door
BM_kartaag_Door
BM_mazegate_01
BM_mazegate_02
BM_mazegate_03
CharGen Exit Door
CharGen_cabindoor
CharGen_ship_trapdoor
EX_MH_door_02
EX_MH_door_02_ignatius
EX_MH_door_02_sadri
EX_MH_door_02_velas
EX_MH_temple_door_01
EX_MH_temple_door_01_ch
Ex_BM_tomb_door_01
Ex_BM_tomb_door_02
Ex_BM_tomb_door_03
Ex_BM_tomb_door_skaalara
Ex_Cave_Door_01_Koal
Ex_DE_ship_cabindoor
Ex_Dae_door_static
Ex_De_SN_Gate
Ex_De_Shack_Door
Ex_MH_Door_01
Ex_MH_Palace_gate
Ex_MH_Pav_Gate_Door
Ex_MH_Pav_Ladder_01
Ex_MH_sewer_trapdoor_01
Ex_MH_sewer_trapdoor_sadri
Ex_MH_swr_trapdr_blkd
Ex_S_door
Ex_S_door_double
Ex_S_door_double_GH
Ex_S_door_double_fixed
Ex_S_door_double_fixing
Ex_S_door_rigmor
Ex_S_door_rigmor2
Ex_V_cantondoor_01
Ex_V_palace_grate_02
Ex_co_ship_cabindoor
Ex_colony_bardoor
Ex_colony_door01.NIF
Ex_colony_door01_1B.NIF
Ex_colony_door02
Ex_colony_door02_1
Ex_colony_door02_2
Ex_colony_door02b_2
Ex_colony_door03
Ex_colony_door03 int
Ex_colony_door03_1
Ex_colony_door03_1_uryn
Ex_colony_door03_2
Ex_colony_door03_4
Ex_colony_door03_4a
Ex_colony_door03_int
Ex_colony_door04
Ex_colony_door04_1
Ex_colony_door04_2
Ex_colony_door04_2b
Ex_colony_door04_3
Ex_colony_door04b_3
Ex_colony_door04c_3
Ex_colony_door05
Ex_colony_door05_2
Ex_colony_door05_3
Ex_colony_door05_int
Ex_colony_door05_int_a
Ex_colony_door05_int_b
Ex_colony_door05_int_c
Ex_colony_door05a_4
Ex_colony_door05b_4
Ex_colony_door05c_4
Ex_colony_door06
Ex_colony_door07
Ex_colony_door08
Ex_colony_minedoor
Ex_imp_loaddoor_02
Ex_redoran_hut_01_a
In_DB_door01
In_DB_door_oval
In_DB_door_oval_02
In_DB_door_oval_relvel
In_DE_LLshipdoor_Large
In_De_Shack_Trapdoor
In_De_Shack_Trapdoor_01
In_Hlaalu_Door_01
In_MH_Pav_Ladder
In_MH_door_01
In_MH_door_01_velas
In_MH_door_02
In_MH_door_02_bar1_uni
In_MH_door_02_bar2_uni
In_MH_door_02_bar3_uni
In_MH_door_02_bar4_uni
In_MH_door_02_chapel
In_MH_door_02_hels_uni
In_MH_door_02_play
In_MH_door_02_throne1
In_MH_door_02_throne2
In_MH_jaildoor_01
In_MH_trapdoor_01
In_M_sewer_door_01
In_OM_door_round
In_S_door
In_impsmall_d_hidden_01
In_thirsk_door
In_thirsk_door_main_1
In_thirsk_door_main_1_b
In_thirsk_door_main_2
In_thirsk_door_main_2_b
Indalen_closet_door
PrisonMarker
Rent_Ghost_Dusk_Door
Rent_MH_Guar_Door
Rent_colony_door
Velothi_Sewer_Door
chargen customs door
chargen door captain
chargen door exit
chargen door hall
chargen_shipdoor
chargendoorjournal
clutter_whouse_door_01
clutter_whouse_door_02
door_cavern_doors00
door_cavern_doors00_velas
door_cavern_doors10
door_cavern_doors20
door_cavern_vassir_un
door_dwe_00_exp
door_dwrv_double00
door_dwrv_double01
door_dwrv_inner00
door_dwrv_load00
door_dwrv_loaddown00
door_dwrv_loadup00
door_dwrv_main00
door_load_darkness00
door_ravenrock_mine
door_sotha_imp_door
door_sotha_load
door_sotha_mach_door
door_sotha_mach_door2
door_sotha_pre_load
ex_BM_ringdoor
ex_S_door_rounded
ex_S_fence_gate
ex_S_fence_gate_uni
ex_ashl_door_01
ex_ashl_door_02
ex_cave_door_01
ex_co_ship_trapdoor
ex_common_door_01
ex_common_door_balcony
ex_dae_door_load_oval
ex_de_ship_trapdoor
ex_emp_tower_01_a
ex_emp_tower_01_b
ex_h_pcfort_exdoor_ 01
ex_h_pcfort_exdoor_ 02
ex_h_pcfort_exdoor_ 03
ex_h_pcfort_exdoor_ 03-3
ex_h_pcfort_trapdoor_01-2
ex_h_trapdoor_01
ex_imp_loaddoor_01
ex_imp_loaddoor_03
ex_nord_door_01
ex_nord_door_01-back
ex_nord_door_01_ignatius
ex_nord_door_01_ignatius1
ex_nord_door_02
ex_nord_door_gyldenhul
ex_nord_door_lair
ex_nord_door_wolf
ex_r_pcfort_d_01
ex_r_pcfort_d_01-2
ex_r_pcfort_d_01-3
ex_r_pcfort_d_02
ex_r_trapdoor_01
ex_redoran_barracks_door
ex_t_door_01
ex_t_door_01_pc_hold_a
ex_t_door_01_pc_hold_b
ex_t_door_02
ex_t_door_02_pc_hold_a
ex_t_door_02_pc_hold_b
ex_t_door_slavepod_01
ex_t_door_sphere_01
ex_t_door_stone_large
ex_v_palace_grate_01
ex_velothi_loaddoor_01
ex_velothi_loaddoor_02
ex_velothicave_door_01
ex_velothicave_door_03
ex_vivec_grate_01
hlaal_loaddoor_01
hlaalu_loaddoor_ 02
hlaalu_loaddoor_ 02_balyn
in_ar_door_01
in_ashl_door_01
in_ashl_door_02
in_ashl_door_02_sha
in_c_door_arched
in_c_door_wood_square
in_ci_door_01
in_ci_door_01_indoor
in_com_trapbottom_01
in_com_traptop_01
in_dae_door_01
in_de_shack_door
in_de_ship_cabindoor
in_de_shipdoor_toplevel
in_h_trapdoor_01
in_hlaalu_door
in_hlaalu_door_uni
in_hlaalu_loaddoor_01
in_hlaalu_loaddoor_02
in_impsmall_d_cave_01
in_impsmall_door_01
in_impsmall_door_01_shrine
in_impsmall_door_jail_01
in_impsmall_loaddoor_01
in_impsmall_trapdoor_01a
in_m_sewer_trapdoor_01
in_m_sewer_trapdoor_01_blkd
in_r_s_door_01
in_r_trapdoor_01
in_redoran_barrack_door
in_redoran_hut_door_01
in_redoran_ladder_01
in_strong_vaultdoor00
in_strong_vaultdoor_tela_UNIQUE
in_t_door_small
in_t_door_small_load
in_t_housepod_door_exit
in_t_l_door_01
in_t_s_plain_door
in_v_s_jaildoor_01
in_v_s_jaildoor_frelene
in_v_s_trapdoor_01
in_v_s_trapdoor_02
in_velothismall_ndoor_01
in_velothismall_ndoor_01_jeanne
in_velothismall_ndoor_agrippina
in_vivec_grate_door_01
pelagiad_halfway_room
rent_balmora_council_door
rent_balmora_eight_door
rent_balmora_lucky_door
rent_balmora_south_door
rent_caldera_shenk_door
rent_ebon_six_door
rent_maargan_andus_door
rent_vivec_black_door
rent_vivec_flower_door
rent_vivec_lizard_door
smora_fara_door
vivec_grate_door_02
# END-OF-LIST Standard Bethesda Doors
