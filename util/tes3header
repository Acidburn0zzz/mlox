#!/usr/bin/perl

use Getopt::Std;
use strict;

# read/write the TES3 header fields for author/description

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant DBG => grep(/^(?:-D)$/, @ARGV);
}

$::opt_v = 0;
$::opt_a = "";
$::opt_d = "";
$::opt_m = undef;
$::opt_v = 0.0;

my $AUTH_OFFSET = 32;
my $AUTH_LENGTH = 32;
my $DESC_OFFSET = $AUTH_OFFSET + $AUTH_LENGTH;
my $DESC_LENGTH = 256;

my $Usage = q{tes3header OPTIONS plugin...

OPTIONS
 -D      turn on debug output
 -a XXX  set the Author field to XXX
 -d YYY  set the Desciption field to YYY
 -m      multiline output for listing field contents.

When -a and -d are not given, the current Author/Description field contents
are printed.

Field values are normally replaced by the given string. But if the string
begins with a "+", the field is appended with the new value.

If a field value contains the string \\n, it will be replaced by a CRLF.

If the value supplied won't fit into the plugin header field, you will be
warned.

Examples:
# Show the Author/Description fields for a plugin:
tes3header plugin.esp
# Set the Author field to "john.moonsugar":
tes3header -a john.moonsugar plugin.esp
# Append " and friends" to the Author field:
tes3header -a "+ and friends" plugin.esp
# Add a Version number to a plugin Description field:
tes3header -d "+\nVersion: 1.0" plugin.esp
};

getopts('Da:d:mv:') or die $Usage;

scalar(@ARGV) or die "Error: You must provide a plugin on the command line\n$Usage";

sub chop_nulls {
    my($str) = @_;
    $str =~ tr/\000//d;
    return($str);
}

sub writefield {
    my($plugin, $origval, $val, $label, $offset, $fieldlen) = @_;
    if ($val =~ /^\+(.*)$/) {
	$val = $origval . $1;
    }
    $val =~ s/(\\r|\r)?(\\n|\n)/\r\n/g;
    # create an empty null padded field
    my $valz = "\000" x $fieldlen;
    # truncate $val to fit in the field, if necessary
    my $origlen = length($val);
    $val = substr($val, 0, $fieldlen - 1);
    if (length($val) < $origlen) {
	warn "Warning, input $label truncated because it exceeded field length of: $fieldlen\n";
    }
    # and plop the given string value into it, with at least one ending null
    substr($valz, 0, length($val)) = $val;
    unless(seek(PLUG, $offset, 0)) {
	warn "$plugin: Error seeking to start of $label field at offset: $offset ($!)\n";
	return(undef);
    }
    my $len = length($valz);
    my $nwritten = syswrite(PLUG, $valz);
    if ($nwritten != $len) {
	warn "$plugin: Error incomplete write to $label field ( ($!)\n";
	return(undef);
    }
    print qq{$plugin: $label set to: "$val"\n};
    return(1);
}

sub process_plugin {
    my($plugin) = @_;
    unless(open(PLUG, "+<$plugin")) {
	warn "Error opening $plugin for read/write ($!)\n";
	return;
    }
    unless(binmode(PLUG)) {
	warn "Error setting binmode on $plugin ($!)\n";
	close(PLUG);
	return;
    }
    my $block;
    my $nread = read(PLUG, $block, 4096);
    if ($nread == 0) {
	warn "$plugin: Error on intial read ($!)\n";
	close(PLUG);
	return;
    }
    my $magic = substr($block, 0, 4);
    if ($magic eq "TES3") {
	if ($nread >= 362) { 	# minimum TES3 plugin size
	    my $auth = chop_nulls(substr($block, $AUTH_OFFSET, $AUTH_LENGTH));
	    my $desc = chop_nulls(substr($block, $DESC_OFFSET, $DESC_LENGTH));
	    if ($::opt_a or $::opt_d) {
		if ($::opt_a) {
		    if (not defined writefield($plugin, $auth, $::opt_a, "AUTHOR", $AUTH_OFFSET, $AUTH_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
		if ($::opt_d) {
		    if (not defined writefield($plugin, $desc, $::opt_d, "DESCRIPTION", $DESC_OFFSET, $DESC_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
	    } else {
		if ($::opt_m) {
		    print "$plugin:\n  AUTH=$auth\n  DESC=$desc\n";
		} else {
		    print "$plugin: AUTH=$auth DESC=$desc\n";
		}
	    }
	}
    } elsif ($magic eq "TES4") {
	warn "This function is not yet implemented for TES4 files\n";
    } else {
	warn "$plugin: Error, this does not appear to be an elder scrolls plugin\n";
    }
    close(PLUG);
}

for my $plugin (@ARGV) {
    process_plugin($plugin);
}
