#!/usr/bin/perl

use Getopt::Std;
use strict;

# dump the names of all records of given type

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant DBG => grep(/^(?:-D)$/, @ARGV);
}

$::opt_v = 0;			# verbose
$::opt_l = 0;			# verbose

my $Usage = qq{dumpcell [OPTIONS] plugin...

dumps CELL records

OPTIONS
 -d   debug output (vast output)
 -l   list plugin name first
};

getopts('Ddlv') or die $Usage;

sub chop_nulls {
    my($str) = @_;
    $str =~ tr/\000//d;
    return($str);
}

my $hdr_size = 16;
sub read_rec {
    my($expected_type) = @_;
    my $rec_hdr = "";
    my $n_read = sysread(INP, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef, undef);
    }
    if ($n_read != $hdr_size) {
	warn "Error(hdr): asked for $hdr_size bytes, got $n_read\n";
	return(undef, undef);
    }
    my($rec_type, $rec_len, $flags) = unpack("a4Lx[L]L", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rec_type) {
	warn "Error: Expected: $expected_type, got: $rec_type\n";
	return(undef, undef);
    }
    my $rec = "";
    $n_read = sysread(INP, $rec, $rec_len);
    if ($n_read != $rec_len) {
	warn "Error(rec): asked for $rec_len bytes, got $n_read\n";
	return(undef, undef);
    }
    return($rec_type, $rec, $flags);
}

sub get_subrec {
    my($rec, $subtype) = @_;
    my @r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4I", substr($rec, $p));
	$p += 8;
	push(@r, substr($rec, $p, $subrec_len))
	    if ($subrec_type eq $subtype);
	$p += $subrec_len;
    }
    return(\@r);
}

sub parse_subrec {
    my($rec) = @_;
    my %r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4I", substr($rec, $p));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@{$r{$subrec_type}}, $val) if (defined $val);
	$p += $subrec_len;
    }
    return(\%r);
}

sub ext_cell_name {
    my($r) = @_;
    my($x, $y) = unpack("x[L]ll", $r->{DATA}[0]);
    my $rgnn = chop_nulls($r->{RGNN}[0]) || "Wilderness";
    return("$rgnn ($x, $y)", $x, $y);
}

sub scan {
    my($plugin) = @_;
    my $plug = ($::opt_l) ? "$plugin: " : "";
    print "\n$plugin: CELLDUMP:\n" unless ($::opt_l);
    unless(open(INP, "<$plugin")) {
	warn "Error opening $plugin for input ($!)\n";
	return;
    }
    my $expected = "TES3";
    while (my($rec_type, $rec, $flags) = read_rec($expected)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	if ($flags & 0x1000) {
	    print "REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	if ($rec_type eq "CELL") {
	    # check for fogbugs in cells
	    my $r = parse_subrec($rec);
	    my $len = length($rec);
	    my $name = chop_nulls($r->{NAME}[0]);
	    my $data = $r->{DATA}[0];
	    my($flags, $fog_density) = unpack("Lx[L]f", $data);
	    my $type;
	    my $nsub = scalar(keys %$r);
	    my $fogbug = "";
	    my $frmr = (defined $r->{FRMR}) ? scalar(@{$r->{FRMR}}) : 0;
	    if ($flags & 1) { 	# interior cell
		$type = "INT";
		$fogbug = " FOGBUG" if (($fog_density == 0.0 and not ($flags & 128)));
	    } else {		# exterior cell
		$type = "EXT";
		my($xname, $x, $y) = ext_cell_name($r);
		$name = ($name) ? "$name ($x, $y)" : $xname;
	    }
	    printf "$plug%3s %-35s  flags:%02x  frmr:%3d  len:%5d  nsub:%3d$fogbug\n",
		$type, $name, $flags, $frmr, $len, $nsub;
	    print "  DBG: rec=$rec\n" if (DBG);
	}
    }
    close(INP);
}

for my $plugin (@ARGV) {
    scan($plugin);
}
