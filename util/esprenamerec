#!/usr/bin/perl

use Getopt::Std;
use strict;

# batch rename records in an esp

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant DBG => grep(/^(?:-D)$/, @ARGV);
}

$::opt_v = 0;
$::opt_l = 0;
$::opt_i = 0;
$::opt_e = 0;

my $Usage = qq{esprenamerec [-D] RECTYPE.SUBTYPE FROM TO plugin...

This first form of the command renames all records of type RECTYPE, replacing
the Perl regular expression FROM with the value of TO (which may contain
backreferences). The rename only happens if the CELL.NAME subrecord matches
the given FROM regular expression.

esprenamerec -l RECTYPE.SUBTYPE plugin...

When the -l switch is given, records of the given type are only listed.

OPTIONS
 -D   turn on debug output
 -i   only rename if the record is an interior CELL.
 -e   only rename if the record is an exterior CELL.
 -l   just list the records, do not rename them.

The original input file is never modified, the changes are made in a new file
"<plugin_name>_new.esp".

Examples:

# rename all exterior cells to the null string:
esprenamerec -e CELL.NAME '.*' ''

# do a caseless comparison:
esprenamerec cell.name '(?i)pelagaid' 'Pelagiad'
(This would rename any name that has the string "pelagaid" in it with any form
of capitalization, to "Pelagiad").

# substitute backreferences:
esprenamerec npc_.fnam '^(\S+)\s(\S+)$' '$2 $1'
(This would swap the first and last name of all NPCs).
};

getopts('Deilv') or die $Usage;

my @valid_types = qw(GMST.NAME CLAS.NAME CLAS.FNAM FACT.NAME FACT.FNAM RACE.NAME RACE.FNAM
		     SOUN.NAME SOUN.FNAM REGN.NAME REGN.FNAM BSGN.NAME BSGN.FNAM STAT.NAME
		     DOOR.NAME DOOR.FNAM MISC.NAME MISC.FNAM WEAP.NAME WEAP.FNAM CONT.NAME
		     CONT.FNAM SPEL.NAME SPEL.FNAM CREA.NAME CREA.FNAM LIGH.NAME LIGH.FNAM
		     ENCH.NAME NPC_.NAME NPC_.FNAM ARMO.NAME ARMO.FNAM CLOT.NAME CLOT.FNAM
		     REPA.NAME REPA.FNAM ACTI.NAME ACTI.FNAM APPA.NAME APPA.FNAM LOCK.NAME
		     LOCK.FNAM PROB.NAME PROB.FNAM INGR.NAME INGR.FNAM BOOK.NAME BOOK.FNAM
		     ALCH.NAME ALCH.FNAM LEVI.NAME CELL.NAME DIAL.NAME);
my %VALID_TYPES;
$VALID_TYPES{$_}++ foreach (@valid_types);
my $type = uc(shift(@ARGV)) or die "Missing required RECTYPE.SUBTYPE\n$Usage";
die "Error: Invalid record type.subtype requested: $type\n" unless ($VALID_TYPES{$type});
my($TYPE, $SUBTYPE) = split(/\./, $type);


my($FROM, $TO);
unless ($::opt_l) {
    $FROM = shift(@ARGV) or die "Missing required FROM\n$Usage";
    $TO = shift(@ARGV) or die "Missing required TO\n$Usage";
}

sub chop_nulls {
    my($str) = @_;
    $str =~ tr/\000//d;
    return($str);
}

my $hdr_size = 16;
sub read_rec {
    my($expected_type) = @_;
    my $rec_hdr = "";
    my $n_read = sysread(INP, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef);
    }
    if ($n_read != $hdr_size) {
	warn "Error(hdr): asked for $hdr_size bytes, got $n_read\n";
	return(undef);
    }
    my($rec_type, $rec_len, $unk, $flags) = unpack("a4LLL", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rec_type) {
	warn "Error: Expected: $expected_type, got: $rec_type\n";
	return(undef);
    }
    my $rec = "";
    $n_read = sysread(INP, $rec, $rec_len);
    if ($n_read != $rec_len) {
	warn "Error(rec): asked for $rec_len bytes, got $n_read\n";
	return(undef);
    }
    return($rec_type, $rec, $unk, $flags);
}

sub write_rec {
    my($rec_type, $rec, $unk, $flags) = @_;
    print OUT pack("a4LLLa*", $rec_type, length($rec), $unk, $flags, $rec);
}

sub parse_subrec {
    my($rec) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @subrecs = ();
    my $name_idx;
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$name_idx = scalar(@subrecs) if ((not defined $name_idx) and ($subrec_type eq $SUBTYPE));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@subrecs, [$subrec_type, $val]) if (defined $val);
	$p += $subrec_len;
    }
    return(\@subrecs, $name_idx);
}

sub new_rec {
    my($sub_recs) = @_;
    my @rec;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	my $len = length($val);
	push(@rec, pack("a4La*", $type, $len, $val));
    }
    return(join("", @rec));
}

sub allowed_cell_type {
    my($sub_recs) = @_;
    return 1 unless ($::opt_i or $::opt_e);
    my $data;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	if ($type eq "DATA") {
	    $data = $val;
	    last;
	}
    }
    my($flags) = unpack("L", $data);
    if ($::opt_i) {
	return($flags & 1);	# is interior
    } else {			# opt_e
	return(not($flags & 1)); # is exterior
    }
}

sub do_rename {
    my($plugin) = @_;
    my $newplugin = $plugin;
    $newplugin =~ s/(\.es[mp])$/_new$1/i;
    if ($newplugin eq $plugin) {
	warn "Error, $plugin name does not end in .esm or .esp?\n";
	return;
    }
    print "\n$plugin: RENAMING CELLS:\n" unless ($::opt_l);
    unless(open(INP, "<$plugin")) {
	warn "Error opening $plugin for input ($!)\n";
	return;
    }
    unless($::opt_l) {
	unless(open(OUT, ">$newplugin")) {
	    warn "Error opening $newplugin for output ($!)\n";
	    return;
	}
    }
    my $expected = "TES3";
    while (my($rec_type, $rec, $unk, $flags) = read_rec($expected)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	if ($rec_type eq $TYPE) {
	    my $renamed = 0;
	    my($subrecs, $name_idx) = parse_subrec($rec);
	    if (defined($name_idx) and
		my $name = $subrecs->[$name_idx]->[1]) {
		$name = chop_nulls($name);
		if ($::opt_l) {	# only list records
		    print "\t$rec_type    $name\n";
		} else {	# rename records
		    my $do_rename = 1;
		    $do_rename = 0 if ($rec_type eq "CELL" and not allowed_cell_type($subrecs));
		    if ($do_rename) {
			my $newname;
			eval qq{(\$newname = \$name) =~ s!$FROM!$TO!g};
			if ($name ne $newname) {
			    $subrecs->[$name_idx]->[1] = "$newname\000";
			    $renamed = 1;
			    printf qq{    Renaming: $TYPE %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			}
		    }
		}
	    } else {
		print "Error, Record has no $SUBTYPE subrecord: $rec\n";
	    }
	    $rec = new_rec($subrecs) if $renamed;
	}
	write_rec($rec_type, $rec, $unk, $flags) unless($::opt_l);
    }
    close(INP) unless $::opt_l;
    close(OUT);
    print "Output saved in: $newplugin\n";
}

for my $plugin (@ARGV) {
    do_rename($plugin);
}
