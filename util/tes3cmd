#!/usr/bin/perl
$::VERSION = "0.37f";
# tes3cmd: command line tool to do various hackage on a TES3 plugin
# Copyright 2010 by John Moonsugar
# Distributed as part of the mlox project:
#   http://code.google.com/p/mlox/
# under the MIT License:
#   http://code.google.com/p/mlox/source/browse/trunk/License.txt
# Documentation:
#   http://code.google.com/p/mlox/wiki/Tes3cmd

# TBD:
# cleanup .tmp if die
# rewrite "modify", "rename" commands to use the "process" subroutines?
# and add more examples, esp. "modify"
# write some tests
# switch pretty printer to use new recdefs
# GUI
# clean up the TOSTR stuff (for pretty print command) so it uses the codec defs
# reformat overdial output? just list each topic once, with list of plugins that have it
# implement script compiler
# add new commands:
# * "undump" (text to record, can't undump from wrong version)
# * "combine" (merge listed plugins into one plugin)
# * "conflict" (detailed report, toggle mergeable records from report)
# * "lint" (splice in tes3lint functionality)
# * "multipatch", to include:
# ** --activate switch to add it to [Game Files]
# ** undo spurious AMBI/WHGT reversion
# ** generate book rotate scripts.
# ** generate multimark scripts.
# ** gmst/global tweaks: (timescale, fCombatAngleXY)
# ** import faces/hairs (avoid conflicts by dropping rest of object definition)
# ** merged leveled lists
# ** merged objects (add mergeable flag to record defs)
# ** summoned creatures persists patch
# ** turn-off auto-calced spells.

use Cwd;
use IO::Handle;
use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
use File::Basename;
use File::Spec;
use File::Copy;
use Getopt::Long qw(:config auto_abbrev);
use Data::Dumper;
use Storable;
use strict;

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant DBG => grep(/^(?:-d|-?-debug)$/, @ARGV);
}

### CONSTANTS

use constant {
    QUIET => 1,
    MIN_TES3_PLUGIN_SIZE => 324,
};

###GLOBALS (Miscellaneous)

my $R = {};			# current decoded record (for modify)
my $DUMP_VERSION = "0.1";	# so undump won't use wrong format version
my $DATADIR;			# where "Data Files" lives.
my $TES3CMD_DIR;		# tes3cmd directory under "Data Files" (for cache, ...)
my $MASTER_ID;			# data loaded from masters
my $GLOBCHARS = '*?';		# for filename matching
my $RECTYPE_LEN = 4;
my $HDR_AUTH_LENGTH = 32;
my $HDR_DESC_LENGTH = 256;

# common Options
our $opt_debug = 0;		# (use the magic constant DBG instead)
our $opt_cell_object_match;
our $opt_cell_object_no_match;
our $opt_exterior;
our $opt_interior;
our $opt_list;
our $opt_match;
our $opt_no_banner;
our $opt_no_cache;
our $opt_no_match;
our $opt_output_dir;
our $opt_overwrite;
our $opt_report_only;
our $opt_separator;
our $opt_sub_match;
our $opt_sub_no_match;
our @opt_flag;
our @opt_id = ();
our @opt_type = ();

###USAGES

my $RECOVER_USAGE = q{Usage: tes3cmd recover OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

DESCRIPTION:

Attempts to recover readable records from a damaged plugin. You should only
use this when Morrowind gives the following type of error on your plugin:

"Trying to load a bad form in TES3File::NextForm"

The main reason you would get this error is if the file has been physically
corrupted, where records have been overwritten with random binary junk, or
if the file has been truncated, or otherwise damaged.

This is not for fixing what is commonly referred to as "savegame corruption",
which is not actually corruption but bad data.

In any case, you will get detailed output on what tes3cmd finds damaged.

EXAMPLE(S):

# fix my damaged plugin:
tes3cmd recover "my plugin.esp"
};

sub opts_recover {
    $_[0] && do { die $RECOVER_USAGE; };
    GetOptions('debug|d') or die $RECOVER_USAGE;
}

my $CLEAN_USAGE = q{Usage: tes3cmd clean OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --cell-objects
	clean objects from cells when duped from masters

 --cell-params
	clean cell subrecords AMBI,WHGT duped from masters
 --dups
	clean other complete records duped from masters

 --gmsts
	clean Evil GMSTs

 --junk-cells
	clean junk cells (no new info from definition in masters)

 --no-cache
	do not create cache files (used for speedier cleaning)

 --output-dir <dir>
	set output directory to <dir> (default is where input plugin is)

 --replace
	replace original plugin with clean version (original is backed up)

DESCRIPTION:

Cleans plugins of various junk. If no cleaning options are selected, the
default is to assume the options:

  --cell-objects --cell-params --dups --gmsts --junk-cells

The goal of the "clean" command is that it should always be safe to use it
with no options to get the default cleaning behavior. The different cleaning
operations are explained below:

Cell Objects (--cell-objects)

  The clean command will clean objects in the plugin that match objects in any
  of its masters. Objects in cells are defined as byte sequences starting in
  the subrecord following a FRMR subrecord, and match only if this is the same
  byte sequence as in the master, along with the same Object-Index from the
  FRMR. NAM0 subrecords are not part of cell objects, and if objects are
  deleted from a cell, the NAM0 subrecord for the cell is updated to reflect
  any changing object count.

Cell Params (--cell-params)

  The subrecords for AMBI (ambient lighting) and WHGT (water height) for
  interior cells are often duplicated from the master of a plugin when the
  plugin is saved in the Construction Set.

Duplicate Records (--dups)

  Object definitions for various record types defined in a master are
  sometimes unnecessarily duplicated in dependent plugins, and this option
  will safely clean them. Only objects that have identical flags and byte
  sequences will be cleaned.

Evil GMSTs (--gmsts)

  An Evil GMST is defined as a GMST from the list of 11 Tribunal GMSTs or 61
  Bloodmoon GMSTs that are inadvertently introduced to a plugin by the
  Construction Set with specific values. Other GMSTs or GMSTs from those lists
  that do not have the specific Evil Values are NOT cleaned by this function.
  For details on Evil GMSTs, see: http://www.wikihost.org/w/mlox/evil_gmsts/

  To clean GMSTs that are not Evil, you can use the command:
    "tes3cmd delete --type gmst"

Junk Cells (--junk-cells)

  Junk cells are bogus external CELL records that crop up in many plugins due
  to a Construction Set bug. They contain only NAME, DATA and sometimes RGNN
  subrecords with data identical to the master. (In addition, interior cells
  will also be removed if they do not introduce any new information).

Cache Files Feature

  tes3cmd will normally create cached data files for your masters in the
  subdirectory: "Data Files/tes3cmd". If you do not wish tes3cmd to create
  cache files, you can use the --no-cache option. (But it is recommended you
  do use them for speedier cleaning).

EXAMPLES:

# clean my plugin of only Evil GMSTs:
tes3cmd clean --gmsts "my plugin.esp"

# clean 2 plugins and put the cleaned versions in a subdirectory "Clean":
tes3cmd clean --output-dir Clean "my plugin1.esp" "my plugin2.esp"

# clean all plugins in the current directory, replacing the originals with
# the cleaned versions and save the diagnostic output to a file (clean.txt):
tes3cmd clean --replace *.esm *.esp > clean.txt
};

our $opt_clean_all = 0;
our $opt_clean_cell_objects = 0;
our $opt_clean_cell_params = 0;
our $opt_clean_dups = 0;
our $opt_clean_gmsts = 0;
our $opt_clean_junk_cells = 0;
our $opt_clean_replace = 0;
sub opts_clean {
    $_[0] && do { die $CLEAN_USAGE; };
    GetOptions('debug|d',
	       'all'           => \$opt_clean_all,
	       'cell-objects'  => \$opt_clean_cell_objects,
	       'cell-params'   => \$opt_clean_cell_params,
	       'dups'          => \$opt_clean_dups,
	       'gmsts'         => \$opt_clean_gmsts,
	       'junk-cells'    => \$opt_clean_junk_cells,
	       'no-cache',
	       'output-dir',
	       'replace'       => \$opt_clean_replace)
	or die $CLEAN_USAGE;
    unless ($opt_clean_cell_objects or $opt_clean_cell_params or $opt_clean_dups or $opt_clean_gmsts or $opt_clean_junk_cells) {
	# turn on all safe cleaning options if none are selected.
	$opt_clean_cell_objects = $opt_clean_cell_params = $opt_clean_dups = $opt_clean_gmsts = $opt_clean_junk_cells = 1;
    }
    if ($opt_clean_all) {
	# turn on all cleaning options (in future we may add some that are possibly unsafe)
	$opt_clean_cell_objects = $opt_clean_cell_params = $opt_clean_dups = $opt_clean_gmsts = $opt_clean_junk_cells = 1;
    }
}

my $ESP_USAGE = q{Usage: tes3cmd esp OPTIONS master...

OPTIONS:
 --debug
	turn on debug messages

 --overwrite
	overwrite output if it exists

DESCRIPTION:

Copies input master (.esm) to a plugin (.esp). If the output file already
exists, you must add the --overwrite option to overwrite it.

EXAMPLES:

# output is: "my plugin.esp"
tes3cmd esp "my plugin.esm"
};

sub opts_esp {
    $_[0] && do { die $ESP_USAGE; };
    GetOptions('debug|d', 'overwrite') or die $ESP_USAGE;
}

my $ESM_USAGE = q{Usage: tes3cmd esm OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --overwrite
	overwrite output if it exists

DESCRIPTION:

Copies input plugin (.esp) to a master (.esm). If the output file already
exists, you must add the --overwrite option to overwrite it.

EXAMPLES:

# output is: "my plugin.esm"
tes3cmd esm "my plugin.esp"
};

sub opts_esm {
    $_[0] && do { die $ESM_USAGE; };
    GetOptions('debug|d', 'overwrite') or die $ESM_USAGE;
}

my $MODIFY_USAGE = q{Usage: tes3cmd modify OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --exterior
	if record is CELL, only match if it is an Exterior

 --flag* <flag>
	only modify records with given flag. Flags may be given symbolically
	as: (deleted, persistent, ignored, blocked), or via their numeric
	values (i.e. persistent is 0x400).

 --id* <id-regex>
	only process records whose ids match regular expression pattern
	<id-regex>

 --interior
	if record is CELL, only match if it is an Interior

 --match <regex>
	only process records that match given regular expression <regex>

 --no-match <regex>
	only process records that do not match given regular expression
	<regex>

 --program-file <file>
	load Perl code to run on each matched record from file named: <file>

 --replace /a/b/
	replace regex a with b. you can use any character instead of the slash

 --run "<code>"
	specify a string of Perl <code> to run on each matched record

 --sub-match <regex>
	only modify the subrecords that match <regex>

 --sub-no-match <regex>
	only modify the subrecords that do not match <regex>

 --type* <record-type>
	only modify records with the given <record-type>

 Note: starred (*) options can be repeated.

Modifies records/subrecords from the plugin. You can really damage things with
this command, so be careful!

Helper Functions: dumprec() and setrec()

tes3cmd includes 2 builtin helper functions to help you make your
modifications: dumprec() and setrec(). Use dumprec() to print out a view of
the records. If you just use: "-e 'dumprec()'", you will get an idea of the
record structure. Both functions take the same 2 arguments. The first is a
reference to a Perl hash containing any or all of these keys: "i" (subrecord
Index), "t" (subrecord Type), "f" (subrecord Field). "i" will constrain
matching of subrecords to subrecords by index. "t" specifies a subrecord type
match, and "f" specifies a field name to match. The final argument to setrec()
is the value to assign to matching fields.

Note: documentation for regular expressions:
  http://www.perl.com/doc/manual/html/pod/perlre.html

Example(s):

# print the first 4 subrecords of the cell "Ashmelech" from Morrowind.esm
tes3cmd modify --type cell --id ashmelech --run 'dumprec({i=>[0..3]})' Morrowind.esm

# Problem: Aleanne's clothing mods do not have restocking inventory
# Solution: create a small patch to change the counts for inventory containers
#   to negative numbers so they will be restocking.
# Step 0: confirm the problem, showing the non-negative counts:
tes3cmd print --type cont ale_clothing_v?.esp
# Step 1: Create the patch file ale_patch.esp containing just the container records:
tes3cmd dump --raw-with-header ale_patch.esp --type cont ale_clothing_v?.esp
# Step 2: Change all the count fields for the containers in Aleanne's Clothing to -3 (for restocking wares)
tes3cmd modify --type cont --run "setrec({f=>'Count'}, -3)" ale_patch.esp
# Note: on Linux, the quoting would be a little different:
tes3cmd modify --type cont --run 'setrec({f=>"Count"}, -3)' ale_patch.esp
};

our $opt_modify_program_file = '';
our $opt_modify_replace = '';
our $opt_modify_run = '';
sub opts_modify {
    $_[0] && do { die $MODIFY_USAGE; };
    GetOptions('debug|d',
	       'exterior',
	       'flag=s@',
	       'id=s@',
	       'interior',
	       'match=s',
	       'no-match|M=s',
	       'program-file=s' => \$opt_modify_program_file,
	       'replace=s' => \$opt_modify_replace,
	       'run=s' => \$opt_modify_run,
	       'sub-match=s',
	       'sub-no-match|M=s',
	       'type=s@')
	or die $MODIFY_USAGE;
}

my $MULTIPATCH_USAGE = q{Usage: tes3cmd multipatch

OPTIONS:
 --debug
	turn on debug messages

 --cellnames
	resolve conflicts with renamed external cells

 --fogbug
	fix interior cells with the fog bug

DESCRIPTION:

The multipatch produces a patch file based on your current load order to
solve various problems. You should regenerate your multipatch whenever you
change your load order. After you have generated the multipatch.esp plugin,
you should enable it in your active plugins. The goal of the "multipatch"
command is that it should always be safe to use it with no options to get the
default patching behavior. If no options are specified, the following options
are assumed:

  --cellnames --fogbug

The different patching operations are explained below:

Cell Name Patch (--cellnames)

  Creates a patch plugin to ensure renamed cells are not accidentally reverted
  to their original name.

  This command solves the following plugin conflict that causes bugs:
  * Master A names external CELL (1, 1) as: "".
  * Plugin B renames CELL (1, 1) to: "My City".
  * Plugin C modifies CELL (1, 1), using the original name "", reverting
    plugin B's renaming.
  * References in plugin B (such as in scripts) that refer to "My City" break.

  This command scans your currently active plugin load order for cell name
  reversions, and ensures whenever possible that cell renaming is properly
  maintained. You should regenerate your cellnamepatch whenever you change your
  load order.

Fog Bug Patch (--fogbug)

  Some video cards are affected by how Morrowind handles a fog density setting
  of zero in interior cells with the result that the interior is pitch black,
  except for some light sources, and no amount of light, night-eye, or gamma
  setting will make the interior visible. This is known as the "fog bug".

  This command creates a patch plugin that fixes all fogbugged cells in your
  active plugins by setting the fog density of those cells to a non-zero
  value.

EXAMPLES:

# Create the patch plugin "multipatch.esp"
tes3cmd multipatch
};

our $opt_multipatch_cellnames;
our $opt_multipatch_fogbug;
sub opts_multipatch {
    $_[0] && do { die $MULTIPATCH_USAGE; };
    GetOptions('debug|d',
	       'cellnames'  => \$opt_multipatch_cellnames,
	       'fogbug'     => \$opt_multipatch_fogbug)
	or die $MULTIPATCH_USAGE;
}


my $DELETE_USAGE = q{Usage: tes3cmd delete OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --cell-object-match <regex>
	when printing cells, only print the matching objects in the cell

 --cell-object-no-match <regex>
	when printing cells, only print the non-matching objects in the cell

 --exterior
	if record is CELL, only match if it is an Exterior

 --flag* <flag>
	only modify records with given flag. Flags may be given symbolically
	as: (deleted, persistent, ignored, blocked), or via their numeric
	values (i.e. persistent is 0x400).

 --id* <id-regex>
	only process records whose ids match regular expression pattern
	<id-regex>

 --interior
	if record is CELL, only match if it is an Interior

 --match <regex>
	only process records that match given regular expression <regex>

 --no-match <regex>
	only process records that do not match given regular expression
	<regex>

 --sub-match <regex>
	only modify the subrecords that match <regex>

 --sub-no-match <regex>
	only modify the subrecords that do not match <regex>

 --type* <record-type>
	only modify records with the given <record-type>

 Note: starred (*) options can be repeated.

DESCRIPTION:

Deletes records/subrecords from the plugin. You can really damage things with
this command, so be careful!

Note: documentation for regular expressions:
  http://www.perl.com/doc/manual/html/pod/perlre.html

EXAMPLES:

# Delete all records with IDs matching "foo":
# Note that this doesn't also delete records that may depend on "foo".
tes3cmd delete --id foo "my plugin.esp"
};

sub opts_delete {
    $_[0] && do { die $DELETE_USAGE; };
    GetOptions('debug|d',
	       'cell-object-match=s',
	       'cell-object-no-match=s',
	       'exterior',
	       'flag=s@',
	       'id=s@',
	       'interior',
	       'match=s',
	       'no-match|M=s',
	       'sub-match=s',
	       'sub-no-match|M=s',
	       'type=s@')
	or die $DELETE_USAGE;
}

my $OVERDIAL_USAGE = q{Usage: tes3cmd overdial OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --single
	only test to see if dialog in the first plugin is overlapped. (by
	default all plugins are checked against all other plugins, which is an
	n-squared operation, meaning "possibly very slow").

DESCRIPTION:

Prints the IDs of dialog records that overlap from the set of given plugins.

An overlap is defined as a dialog (DIAL) Topic from one plugin that entirely
contains a dialog Topic from another plugin as a substring. For example, the
mod "White Wolf of Lokken" has a dialog topic "to rescue me" which overlaps
with the dialog topic "rescue me" from "Suran Underworld", which causes the
"Special Guest" quest from SU to get stuck because Ylarra won't offer the
topic "rescue me" when you find her in her cell.

Note that overlap is only a potential problem if the plugins are loaded in the
order they are listed in the output.

Example(s):

# Show dialog overlaps between Lokken and SU:
tes3cmd overdial "BT_Whitewolf_2_0.esm" "Suran_Underworld_2.5.esp"
};

our $opt_overdial_single;
sub opts_overdial {
    $_[0] && do { die $OVERDIAL_USAGE; };
    GetOptions('debug|d',
	       'single' => \$opt_overdial_single)
	or die $OVERDIAL_USAGE;
}

my $COMMON_USAGE = q{Usage: tes3cmd common OPTIONS plugin1 plugin2

OPTIONS:
 --debug
	turn on debug messages

DESCRIPTION:

Prints the IDs of records that the 2 given plugins have in common.

EXAMPLES:

# Show the records in common between my plugin and Morrowind.esm:
tes3cmd common "my plugin.esp" "Morrowind.esm"
};

sub opts_common {
    $_[0] && do { die $COMMON_USAGE; };
    GetOptions('debug|d') or die $COMMON_USAGE;
}


my $DIFF_USAGE = q{Usage: tes3cmd diff OPTIONS plugin1 plugin2

OPTIONS:
 --debug
	turn on debug messages

 --ignore-type* <record-type>
	ignore given type(s)

 --1-not-2|--e1
	report objects in plugin1 that do not exist in plugin2

 --2-not-1|--e2
	report objects in plugin2 that do not exist in plugin1

 --equal|--eq
	report objects in plugin1 that are equal in plugin2

 --not-equal|--ne
	report objects in plugin1 that are different in plugin2

 Note: starred (*) options can be repeated.

DESCRIPTION:

Prints a report on the differences between the two TES3 files.
A summary report with up to four sections is printed to standard output
that gives an overview of differences, as lists of record IDs.
(Report sections that would have no items are not printed).

When objects in plugin1 are different in plugin2, each of these objects
is printed in detail to a file "plugin1.diff" and "plugin2.diff", which
can then be compared textually using a tool such as WinMerge or Emacs'
ediff function.

To reduce a great deal of "uninteresting" differences when diffing savegames,
CELL.FRMR records are automatically ignored when the ModIndex is zero. (Note
that in this case, the ObjIndex appears to only be incremented by one).

EXAMPLES:

# Print report on differences between 2 savegames (output to diff.out):
tes3cmd diff "save1000.ess" "save2000.ess" > diff.out

# You can also use the --ignore-type switch to ignore further subfields in
# order to help reduce the amount of differences as in the following example.
# Report on differences, but ignore the subfields CREA.AIDT and CELL.ND3D:
tes3cmd diff --ignore-type crea.aidt --ignore-type cell.nd3d testa0000.ess testb0000.ess > diff.out

# Just print the records that differ
tes3cmd diff --not-equal "my plugin1.esp" plugin2.esp
};

our @opt_diff_ignore_type = ();
our $opt_diff_1_not_2;
our $opt_diff_2_not_1;
our $opt_diff_equal;
our $opt_diff_not_equal;
sub opts_diff {
    $_[0] && do { die $DIFF_USAGE; };
    GetOptions('debug|d',
	       'ignore-type=s@' => \@opt_diff_ignore_type,
	       '1-not-2|e1'       => \$opt_diff_1_not_2,
	       '2-not-1|e2'       => \$opt_diff_2_not_1,
	       'equal|eq'         => \$opt_diff_equal,
	       'not-equal|ne'     => \$opt_diff_not_equal)
	or die $DIFF_USAGE;
}

my $DUMP_USAGE = q{Usage: tes3cmd dump OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --canon
	dump in canonical format

 --cell-object-match <regex>
	when printing cells, only print the matching objects in the cell

 --cell-object-no-match <regex>
	when printing cells, only print the non-matching objects in the cell

 --exterior
	if record is CELL, only match if it is an Exterior

 --flag* <flag>
	only modify records with given flag. Flags may be given symbolically
	as: (deleted, persistent, ignored, blocked), or via their numeric
	values (i.e. persistent is 0x400).

 --id* <id-regex>
	only process records whose ids match regular expression pattern
	<id-regex>

 --interior
	if record is CELL, only match if it is an Interior

 --list
	only list the ids of the records to be dumped, instead of the entire record

 --match <regex>
	only process records that match given regular expression <regex>

 --no-banner
	do not print banner identifying the current plugin

 --no-match <regex>
	only process records that do not match given regular expression
	<regex>

 --raw <file>
	dump raw records to <file>, instead of as text

 --raw-with-header <file>
	dump raw records with an initial TES3 header record to <file>

 --separator <string>
	separate subrecords with given <string>. Normally subrecords are
	separated by line-breaks. You can use this option to change that so
	they are all printed on one line.

 --type* <record-type>
	only modify records with the given <record-type>

DESCRIPTION:

Dumps the plugin to stdout in text form for easy perusal. For large plugins,
the output can be voluminous.

Note: documentation for regular expressions:
  http://www.perl.com/doc/manual/html/pod/perlre.html

EXAMPLES:

# Dump all records from a plugin (this could generate a lot of output):
tes3cmd dump "my plugin.esp"

# Dump all records with IDs matching "foo":
tes3cmd dump --id foo "plugin.esp"

# Dump all the DIAL and INFO records from a plugin:
tes3cmd dump --type dial --type info "plugin.esp"

# Dump all cells from bradhia_v1_4.esp containing NPC named: "Maeve Jaste"
tes3cmd dump --type cell --match "NAME:.*maeve.jaste" "bradhia_v1_4.esp"
# Dump all records flagged as persistent and blocked (by flag value)
tes3cmd dump --flag persistent --flag 0x2000 "my plugin.esp"
};

our $opt_dump_raw;
our $opt_dump_raw_with_header;
our $opt_dump_canon = 0;
my $RAWOUT;
sub opts_dump {
    $_[0] && do { die $DUMP_USAGE; };
    GetOptions('debug|d',
	       'canon' => \$opt_dump_canon,
	       'cell-object-match=s',
	       'cell-object-no-match=s',
	       'exterior',
	       'flag=s@',
	       'id=s@',
	       'interior',
	       'list',
	       'match=s',
	       'no-banner|B',
	       'no-match|M=s',
	       'raw-with-header=s' => \$opt_dump_raw_with_header,
	       'raw=s' => \$opt_dump_raw,
	       'separator=s',
	       'type=s@')
	or die $DUMP_USAGE;

    $opt_dump_raw = $opt_dump_raw_with_header
	if ($opt_dump_raw_with_header);
    $RAWOUT = open_for_write($opt_dump_raw)
	if ($opt_dump_raw);
    print $RAWOUT make_header()
	if ($opt_dump_raw_with_header);
}

my $HEADER_USAGE = qq{Usage: tes3cmd header OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --author <author>
	set the Author field to <author>

 --description <desc>
	set the Description field to <desc>

 --multiline
	multi-line output for listing field contents

 --synchronize
	same as: --update-masters --update-record-count

 --update-masters
	updates master list to reflect new versions

 --update-record-count
	update record count in header

DESCRIPTION:

When no options are given, the author and description are printed.

Author and Description field values are normally replaced by the given string.
But if the string begins with a "+", the existing value is appended with the
new given value.

If a given value contains the string "\\n", it will be replaced by a CRLF.

Note:
 - the Author value should fit in $HDR_AUTH_LENGTH bytes.
 - the Description value should fit in $HDR_DESC_LENGTH bytes.

If the value supplied won't fit into the plugin header field, you will be
warned.

The --update-masters (or --synchronize) option will clear any warnings
Morrowind gives when it starts up that say: "One or more plugins could not
find the correct versions of the master files they depend on..."

EXAMPLES:

# Show the Author/Description fields for a plugin:
tes3cmd header "my plugin.esp"

# Set the Author field to "john.moonsugar":
tes3cmd header --author john.moonsugar "plugin.esp"

# Append " and friends" to the Author field:
tes3cmd header --author "+ and friends" "plugin.esp"

# Append a Version number to a plugin Description field:
tes3cmd header --description "+\\nVersion: 1.0" "plugin.esp"

# update header field for the number of records in the plugin (if incorrect)
# and sync the list of masters to the masters installed in "Data Files"
tes3cmd header --synchronize "my plugin.esp"
};

our $opt_header_author = '';
our $opt_header_description = '';
our $opt_header_multiline = 0;
our $opt_header_synchronize;
our $opt_header_update_masters;
our $opt_header_update_record_count = 0;
sub opts_header {
    $_[0] && do { die $HEADER_USAGE; };
    GetOptions('debug|d',
	       'author=s' => \$opt_header_author,
	       'description=s' => \$opt_header_description,
	       'multiline' => \$opt_header_multiline,
	       'synchronize' => \$opt_header_synchronize,
	       'update-masters' => \$opt_header_update_masters,
	       'update-record-count' => \$opt_header_update_record_count)
	or die $HEADER_USAGE;

    $opt_header_update_masters = $opt_header_update_record_count = 1
	if ($opt_header_synchronize);
}

my $RENAME_USAGE = q{Usage: tes3cmd rename OPTIONS RECTYPE.SUBTYPE FROM TO plugin...

OPTIONS:
 --debug
	turn on debug messages

 --exterior
	only rename if the record is an exterior CELL

 --interior
	only rename if the record is an interior CELL

 --report-only
	just list the records, do not rename them

 --window-size <size>
	set size of printable window for record contents printed with
	--report-only switch to <size>

DESCRIPTION:

This first form of the command renames all records of type RECTYPE, replacing
the Perl regular expression FROM with the value of TO (which may contain
backreferences). The rename only happens if the CELL.NAME subrecord matches
the given FROM regular expression.

tes3cmd rename --report-only RECTYPE.SUBTYPE plugin...

When the --report-only switch is given, records of the given type are only
listed. (You do not give a FROM or TO when using the --report-only option).

The original input file is renamed to a backup, and changes are output to the
original filename.

Note that when renaming scripts, you can use either SCPT.SCTX or SCPT.SCHD as
the RECTYPE.SUBTYPE parameter, and the script name is changed in both
subrecords.

Note: documentation for regular expressions:
  http://www.perl.com/doc/manual/html/pod/perlre.html

EXAMPLES:

# rename all exterior cells to the null string:
tes3cmd rename --exterior CELL.NAME ".*" "" "my plugin.esp"

# do a caseless comparison with the FROM pattern:
tes3cmd rename cell.name "(?i)pelagaid" "Pelagiad" "plugin.esp"
(This would rename any name that has the string "pelagaid" in it with any form
of capitalization, to "Pelagiad").

# The following command will swap the first and last name of all NPCs using
# substitution backreferences (a very powerful feature of regular expressions):
tes3cmd rename npc_.fnam "^(\S+)\s(\S+)$" "$2 $1" "plugin.esp"
(Note that on Linux you may need to use single-quotes instead of double-quotes).
};

my($RENAME_FROM, $RENAME_TO, $RENAME_TYPE, $RENAME_SUBTYPE);
my @ren_valid_types =
    qw(GMST.NAME CLAS.NAME CLAS.FNAM FACT.NAME FACT.FNAM RACE.NAME RACE.FNAM
       SOUN.NAME SOUN.FNAM REGN.NAME REGN.FNAM BSGN.NAME BSGN.FNAM STAT.NAME
       DOOR.NAME DOOR.FNAM MISC.NAME MISC.FNAM WEAP.NAME WEAP.FNAM CONT.NAME
       CONT.FNAM SPEL.NAME SPEL.FNAM CREA.NAME CREA.FNAM LIGH.NAME LIGH.FNAM
       ENCH.NAME NPC_.NAME NPC_.FNAM ARMO.NAME ARMO.FNAM CLOT.NAME CLOT.FNAM
       REPA.NAME REPA.FNAM ACTI.NAME ACTI.FNAM APPA.NAME APPA.FNAM LOCK.NAME
       LOCK.FNAM PROB.NAME PROB.FNAM INGR.NAME INGR.FNAM BOOK.NAME BOOK.FNAM
       ALCH.NAME ALCH.FNAM LEVI.NAME CELL.NAME DIAL.NAME SCPT.SCHD SCPT.SCTX);
my %VALID_TYPE;
$VALID_TYPE{$_}++ foreach (@ren_valid_types);

our $opt_rename_interior = 0;
our $opt_rename_exterior = 0;
our $opt_rename_window_size = 38;
sub opts_rename {
    $_[0] && do { die $RENAME_USAGE; };
    GetOptions('debug|d',
	       'interior' => \$opt_rename_interior,
	       'exterior' => \$opt_rename_exterior,
	       'report-only',
	       'window-size=i' => \$opt_rename_window_size)
	or die $RENAME_USAGE;

    my $type = uc(shift(@ARGV)) or die "Missing required RECTYPE.SUBTYPE\n$RENAME_USAGE";
    die "Error: Invalid record type.subtype requested: $type\n\nI only know these:\n@ren_valid_types\n" unless ($VALID_TYPE{$type});
    ($RENAME_TYPE, $RENAME_SUBTYPE) = split(/\./, $type);

    unless ($opt_report_only) {
	defined($RENAME_FROM = shift(@ARGV)) or die "Missing required FROM\n$RENAME_USAGE";
	defined($RENAME_TO = shift(@ARGV)) or die "Missing required TO\n$RENAME_USAGE";
    }
}

sub opts_wikiout {
    GetOptions('debug|d') or
	die "Usage: tes3cmd -wikiout\n";
}

our $opt_codectest_continue;
our @opt_codectest_excluded_type = ();
sub opts_codectest {
    GetOptions('debug|d',
	       'continue|c' => \$opt_codectest_continue,
	       'excluded-type|x=s@' => \@opt_codectest_excluded_type)
	or die "Usage: tes3cmd -codectest [--excluded-type|-x excluded_type]\n";
}

###UTILITIES

sub make_header {
    my($opt) = @_;
    my $hedr = pack("a4L/a*", 'HEDR',
		    pack("fLZ${HDR_AUTH_LENGTH}Z${HDR_DESC_LENGTH}L",
			 ($opt->{version} || 1.3),
			 ($opt->{ismaster} || 0),
			 ($opt->{author} || "tes3cmd"),
			 ($opt->{description} || "(generated)"),
			 ($opt->{nrecords} || 0)));
    my $tes3 = pack("a4LLLa*", 'TES3', length($hedr), (my $unk = 0), (my $flags = 0), $hedr);
    die("Invalid TES3 header definition has incorrect size.")
	unless (length($tes3) == MIN_TES3_PLUGIN_SIZE);
    return($tes3);
}

sub celldata {
    my($srh) = @_;
    my $data = $srh->{DATA}[0];
    my($flags, $fog_data) = unpack("Lx[L]f", $data);
    return(($flags & 1), $flags, $fog_data);
}

# is_interior($srh);
sub is_interior { unpack("L", $_[0]->{DATA}[0]) & 1 }

sub chop_nulls { unpack("Z*", $_[0]); }

sub fatal_error {
    my($msg) = @_;
    my $diagnosis;
    if ($^O =~ /^MSWin/) {
	if ($msg =~ /permission denied/i) {
	    $diagnosis =<<END
Permission errors may occur in recent versions of Windows (since Vista) due to
the UAC feature and new protected nature of "Program Files". The ideal
solution is to install Morrowind some place other than "Program Files", such
as "C:\Games\Morrowind". You can also try disabling UAC, although may make your
system less secure.
END
	}
    }
    die qq{FATAL ERROR: $msg$diagnosis\n"};
}

# return a dictionary of all the files found in the given directory.
# keys are lowercased for caseless file finding.
sub list_files {
    my($dir) = @_;
    my %files = ();
    if (opendir(DH, $dir)) {
	while (my $file = readdir(DH)) {
	    next if (($file eq '.') or ($file eq '..'));
	    $files{lc($file)} = $file;
	}
	closedir(DH);
    } else {
	fatal_error(qq{Opening "$dir" ($!)});
    }
    return(\%files);
}

# sort list of files by their modification date
sub sort_by_date {
    my($dir, @files) = @_;
    my $dirlist = list_files($dir);
    my @sorted = sort { (-M "$dir/$dirlist->{lc $b}") <=> (-M "$dir/$dirlist->{lc $a}") } @files;
    warn qq{DBG: sorted files:\n}, join("\n", @sorted), "\n" if (DBG);
    return(@sorted);
}

sub load_order {
    die "DATADIR not defined\n" unless (defined($DATADIR));
    my $datafiles = list_files($DATADIR);
    my $mwfiles = list_files("$DATADIR/..");
    my $ini = "$DATADIR/../$mwfiles->{'morrowind.ini'}";
    my @active;
    my $fh = IO::Handle->new();
    if (open($fh, "<$ini")) {
	warn qq{INI is: "$ini"\n} if (DBG);
	while (<$fh>) {
	    if (my($plugin) = (/GameFile\d+=([^\r\n]*)/)) {
		if ($datafiles->{lc $plugin}) {
		    warn qq{Found Gamefile: "$plugin"\n} if (DBG);
		    push(@active, $plugin);
		} else {
		    warn qq{MISSING Gamefile: "$1"\n} if (DBG);
		}
	    }
	}
    } else {
	warn qq{Error opening "$ini" for input ($!)\n};
    }
    my @sorted = sort_by_date($DATADIR, @active);
    return((grep(/\.esm$/i, @sorted), grep(/\.esp$/i, @sorted)));
}

# assuming the program is run somewhere under the Morrowind game directory, find the
# location of the "Data Files" directory by walking up the hierarchy.
sub find_datadir {
    return($DATADIR) if (defined($DATADIR));
    my $dir = Cwd::getcwd();
    warn "DBG: checking for data dir in: $dir\n" if (DBG);
    while (($dir =~ m!\bmorrowind\b!i) and (-d $dir)) {
	my $datadir = list_files($dir)->{"data files"};
	if ($datadir) {
	    $DATADIR = "$dir/$datadir";
	    print "DATADIR = $DATADIR\n";
	    $TES3CMD_DIR = "$DATADIR/tes3cmd";
	    fatal_error(qq{"$TES3CMD_DIR" exists, but is not a directory, please remove or rename it.})
		if (-e $TES3CMD_DIR and not -d $TES3CMD_DIR);
	    return($DATADIR);
	}
	my @parts = split(m![\\/]!, $dir);
	pop(@parts);
	$dir = join("/", @parts);
	warn "DBG: checking for data dir in: $dir\n" if (DBG);
    }
    warn qq{Can't find "Data Files" directory. Won't be able to find masters\n};
    return(undef);		# not running under morrowind directory
}

sub allowed_cell_type {
    my($srl) = @_;
    return 1 unless ($opt_interior or $opt_exterior);
    my $data;
    foreach my $pair (@$srl) {
	my($type, $val) = @$pair;
	if ($type eq "DATA") {
	    $data = $val;
	    last;
	}
    }
    my($flags) = unpack("L", $data);
    if ($opt_interior) {
	return($flags & 1);	# is interior
    } else {
	return(not($flags & 1)); # is exterior
    }
}

###DATA DEFINITIONS

# these types are for records to be cleaned from plugins when duped from a master:
my @CLEAN_DUP_TYPES =
    qw(ACTI ALCH APPA ARMO BODY BOOK BSGN CELL CLAS CLOT CONT CREA DOOR ENCH
       FACT GLOB GMST INFO INGR LAND LEVC LEVI LIGH LOCK MGEF MISC NPC_
       PGRD PROB RACE REGN REPA SCPT SKIL SNDG SOUN SPEL SSCR STAT WEAP);

# Evil GMSTs for Tribunal (values are hexencoded)
my %EVIL_TB =
    (scompanionshare => '5354525620436f6d70616e696f6e205368617265',
     scompanionwarningbuttonone => '53545256204c657420746865206d657263656e61727920717569742e',
     scompanionwarningbuttontwo => '535452562052657475726e20746f20436f6d70616e696f6e20536861726520646973706c61792e',
     scompanionwarningmessage => '5354525620596f7572206d657263656e61727920697320706f6f726572206e6f77207468616e207768656e20686520636f6e74726163746564207769746820796f752e2020596f7572206d657263656e6172792077696c6c207175697420696620796f7520646f206e6f7420676976652068696d20676f6c64206f7220676f6f647320746f206272696e67206869732050726f6669742056616c756520746f206120706f7369746976652076616c75652e',
     sdeletenote => '535452562044656c657465204e6f74653f',
     seffectsummonfabricant => '53545256207345666665637453756d6d6f6e466162726963616e74',
     slevitatedisabled => '53545256204c657669746174696f6e206d6167696320646f6573206e6f7420776f726b20686572652e',
     smagicfabricantid => '5354525620466162726963616e74',
     smaxsale => '53545256204d61782053616c65',
     sprofitvalue => '535452562050726f6669742056616c7565',
     steleportdisabled => '535452562054656c65706f72746174696f6e206d6167696320646f6573206e6f7420776f726b20686572652e',
     );

# Evil GMSTs for Bloodmoon (values are hexencoded)
my %EVIL_BM =
    (fcombatdistancewerewolfmod => '464c5456209a99993e',
     ffleedistance => '464c54562000803b45',
     fwerewolfacrobatics => '464c54562000001643',
     fwerewolfagility => '464c54562000001643',
     fwerewolfalchemy => '464c5456200000803f',
     fwerewolfalteration => '464c5456200000803f',
     fwerewolfarmorer => '464c5456200000803f',
     fwerewolfathletics => '464c54562000001643',
     fwerewolfaxe => '464c5456200000803f',
     fwerewolfblock => '464c5456200000803f',
     fwerewolfbluntweapon => '464c5456200000803f',
     fwerewolfconjuration => '464c5456200000803f',
     fwerewolfdestruction => '464c5456200000803f',
     fwerewolfenchant => '464c5456200000803f',
     fwerewolfendurance => '464c54562000001643',
     fwerewolffatigue => '464c5456200000c843',
     fwerewolfhandtohand => '464c5456200000c842',
     fwerewolfhealth => '464c54562000000040',
     fwerewolfheavyarmor => '464c5456200000803f',
     fwerewolfillusion => '464c5456200000803f',
     fwerewolfintellegence => '464c5456200000803f',
     fwerewolflightarmor => '464c5456200000803f',
     fwerewolflongblade => '464c5456200000803f',
     fwerewolfluck => '464c5456200000803f',
     fwerewolfmagicka => '464c5456200000c842',
     fwerewolfmarksman => '464c5456200000803f',
     fwerewolfmediumarmor => '464c5456200000803f',
     fwerewolfmerchantile => '464c5456200000803f',
     fwerewolfmysticism => '464c5456200000803f',
     fwerewolfpersonality => '464c5456200000803f',
     fwerewolfrestoration => '464c5456200000803f',
     fwerewolfrunmult => '464c5456200000c03f',
     fwerewolfsecurity => '464c5456200000803f',
     fwerewolfshortblade => '464c5456200000803f',
     fwerewolfsilverweapondamagemult => '464c5456200000c03f',
     fwerewolfsneak => '464c5456200000803f',
     fwerewolfspear => '464c5456200000803f',
     fwerewolfspeechcraft => '464c5456200000803f',
     fwerewolfspeed => '464c54562000001643',
     fwerewolfstrength => '464c54562000001643',
     fwerewolfunarmored => '464c5456200000c842',
     fwerewolfwillpower => '464c5456200000803f',
     iwerewolfbounty => '494e54562010270000',
     iwerewolffightmod => '494e54562064000000',
     iwerewolffleemod => '494e54562064000000',
     iwerewolfleveltoattack => '494e54562014000000',
     seditnote => '535452562045646974204e6f7465',
     seffectsummoncreature01 => '53545256207345666665637453756d6d6f6e43726561747572653031',
     seffectsummoncreature02 => '53545256207345666665637453756d6d6f6e43726561747572653032',
     seffectsummoncreature03 => '53545256207345666665637453756d6d6f6e43726561747572653033',
     seffectsummoncreature04 => '53545256207345666665637453756d6d6f6e43726561747572653034',
     seffectsummoncreature05 => '53545256207345666665637453756d6d6f6e43726561747572653035',
     smagiccreature01id => '5354525620734d61676963437265617475726530314944',
     smagiccreature02id => '5354525620734d61676963437265617475726530324944',
     smagiccreature03id => '5354525620734d61676963437265617475726530334944',
     smagiccreature04id => '5354525620734d61676963437265617475726530344944',
     smagiccreature05id => '5354525620734d61676963437265617475726530354944',
     swerewolfalarmmessage => '5354525620596f752068617665206265656e206465746563746564206368616e67696e672066726f6d20612077657265776f6c662073746174652e',
     swerewolfpopup => '535452562057657265776f6c66',
     swerewolfrefusal => '5354525620596f752063616e6e6f7420646f207468697320617320612077657265776f6c662e',
     swerewolfrestmessage => '5354525620596f752063616e6e6f74207265737420696e2077657265776f6c6620666f726d2e',
    );

my @beth_levc =
    ('bm_ex_berserkers',
     'bm_ex_felcoast',
     'bm_ex_felcoast_40',
     'bm_ex_felcoast_60',
     'bm_ex_felcoast_sleep',
     'bm_ex_hirforest',
     'bm_ex_hirforest_40',
     'bm_ex_hirforest_60',
     'bm_ex_hirforest_sleep',
     'bm_ex_horker_h20',
     'bm_ex_horker_lake',
     'bm_ex_isinplains',
     'bm_ex_isinplains_40',
     'bm_ex_isinplains_60',
     'bm_ex_isinplains_sleep',
     'bm_ex_moemountains',
     'bm_ex_moemountains_40',
     'bm_ex_moemountains_60',
     'bm_ex_moemountains_sleep',
     'bm_ex_reaver_archers',
     'bm_ex_reavers',
     'bm_ex_rieklingpatrols',
     'bm_ex_rieklingpatrols_20',
     'bm_ex_rieklingpatrols_40',
     'bm_ex_rieklingpatrols_60',
     'bm_ex_smugglers',
     'bm_ex_wolfpack',
     'bm_ex_wolfpack_20',
     'bm_ex_wolfpack_40',
     'bm_ex_wolfpack_60',
     'bm_frysehag_all',
     'bm_in_berserker_20',
     'bm_in_berserker_40',
     'bm_in_berserker_60',
     'bm_in_frysehag_20',
     'bm_in_frysehag_40',
     'bm_in_frysehag_8',
     'bm_in_icecaves',
     'bm_in_icecaves_40',
     'bm_in_icecaves_60',
     'bm_in_nordburial',
     'bm_in_nordburial_40',
     'bm_in_nordburial_60',
     'bm_werewolf_connor',
     'bm_werewolf_wilderness01',
     'bm_werewolf_wilderness02',
     'bm_werewolf_wilderness03',
     'bm_werewolf_wilderness04',
     'bm_werewolf_wilderness05',
     'bm_werewolf_wilderness06',
     'bm_werewolf_wilderness07',
     'bm_werewolf_wilderness08',
     'bm_werewolf_wilderness09',
     'db_assassins',
     'ex_ascadianisles_lev+0',
     'ex_ascadianisles_lev+2',
     'ex_ascadianisles_lev-1',
     'ex_ascadianisles_sleep',
     'ex_azurascoast_lev+0',
     'ex_azurascoast_lev+2',
     'ex_azurascoast_lev-1',
     'ex_azurascoast_sleep',
     'ex_bittercoast_lev+0',
     'ex_bittercoast_lev+2',
     'ex_bittercoast_lev-1',
     'ex_bittercoast_sleep',
     'ex_grazelands_lev+0',
     'ex_grazelands_lev+2',
     'ex_grazelands_lev-1',
     'ex_grazelands_sleep',
     'ex_molagmar_lev+0',
     'ex_molagmar_lev+2',
     'ex_molagmar_lev-1',
     'ex_molagmar_sleep',
     'ex_redmtn_all_lev+0',
     'ex_redmtn_all_lev+2',
     'ex_redmtn_all_lev-2',
     'ex_redmtn_all_sleep',
     'ex_sheogorad_lev+0',
     'ex_sheogorad_lev+2',
     'ex_sheogorad_lev-1',
     'ex_sheogorad_sleep',
     'ex_shore_all_lev+0',
     'ex_shore_all_lev+2',
     'ex_shore_all_lev-2',
     'ex_shore_cliffracer_lev+0',
     'ex_shore_cliffracer_lev+2',
     'ex_shore_cliffracer_lev-2',
     'ex_shore_mudcrab',
     'ex_westgash_lev+0',
     'ex_westgash_lev+2',
     'ex_westgash_lev-1',
     'ex_westgash_sleep',
     'ex_wild_all_lev+0',
     'ex_wild_all_lev+2',
     'ex_wild_all_lev-1',
     'ex_wild_all_sleep',
     'ex_wild_netch_lev+0',
     'ex_wild_netch_lev+2',
     'ex_wild_netch_lev-1',
     'ex_wild_rat_lev+0',
     'ex_wild_rat_lev+2',
     'ex_wild_rat_lev-2',
     'h2o_all_lev+0',
     'h2o_all_lev+2',
     'h2o_all_lev-2',
     'h2o_slaughterfish',
     'in_6th_all_lev+0',
     'in_6th_all_lev+2',
     'in_6th_all_lev-2',
     'in_6th_ash_lev+0',
     'in_6th_ash_lev+2',
     'in_6th_ash_lev-2',
     'in_cave_alit_lev+0',
     'in_cave_alit_lev+2',
     'in_cave_alit_lev-1',
     'in_cave_all_lev+0',
     'in_cave_all_lev+2',
     'in_cave_all_lev-1',
     'in_cave_kagouti_lev+0',
     'in_cave_kagouti_lev+2',
     'in_cave_kagouti_lev-1',
     'in_cave_nix_lev+0',
     'in_cave_nix_lev+2',
     'in_cave_nix_lev-1',
     'in_dae_all_lev+0',
     'in_dae_all_lev+2',
     'in_dae_all_lev-2',
     'in_dae_atronach_lev+0',
     'in_dae_atronach_lev+2',
     'in_dae_atronach_lev-2',
     'in_dae_clanfear_lev+0',
     'in_dae_clanfear_lev+2',
     'in_dae_clanfear_lev-2',
     'in_dae_dremora_lev+0',
     'in_dae_dremora_lev+2',
     'in_dae_dremora_lev-2',
     'in_durzogs',
     'in_dwe_all_lev+0',
     'in_dwe_all_lev+2',
     'in_dwe_all_lev-2',
     'in_dwe_all_tribunal',
     'in_dwe_cent_lev+0',
     'in_dwe_cent_lev+2',
     'in_dwe_cent_lev-2',
     'in_egg_all_lev+0',
     'in_egg_all_lev+2',
     'in_egg_all_lev-1',
     'in_egg_kwama_blight_lev+0',
     'in_egg_kwama_blight_lev+2',
     'in_egg_kwama_blight_lev-1',
     'in_egg_kwama_lev+0',
     'in_egg_kwama_lev+2',
     'in_egg_kwama_lev-1',
     'in_egg_kwama_mined',
     'in_egg_scrib_lev+0',
     'in_egg_scrib_lev+2',
     'in_egg_scrib_lev-1',
     'in_goblins',
     'in_tomb_all_lev+0',
     'in_tomb_all_lev+2',
     'in_tomb_all_lev-2',
     'in_tomb_all_lev_trib',
     'in_tomb_bone_lev+0',
     'in_tomb_bone_lev+2',
     'in_tomb_bone_lev-2',
     'in_tomb_skele_lev+0',
     'in_tomb_skele_lev+2',
     'in_tomb_skele_lev-2',
     'in_vamp_cattle',
     'in_vamp_cattle_aun',
     'in_vamp_cattle_ber',
     'in_vamp_cattle_qua',
     'l_vamp_cattle',
    );
my %BETH_LEVC;
foreach my $l (@beth_levc) { $BETH_LEVC{$l}++; }

my @beth_levi =
    ('bm_chest_loot_01',
     'bm_corpse_loot_01',
     'bm_imperial guard random weapon',
     'bm_karstaag_barrels',
     'bm_karstaag_crates',
     'bm_random_enchanted',
     'bm_random_healthpotions',
     'bm_random_lockpick',
     'bm_random_mead',
     'bm_random_nordhuntweap',
     'bm_random_nordictomb',
     'bm_random_nordsilver',
     'bm_random_reaver_helm',
     'bm_random_riekling_loot',
     'bm_random_skaal',
     'bm_randomboots_smugglers',
     'bm_randomcuirass_smugglers',
     'bm_randomgreaves_smugglers',
     'bm_randomhealth_smugglers',
     'bm_randomhelmet_smugglers',
     'bm_randomleft_smugglers',
     'bm_randomloot_smugglers',
     'bm_randomright_smugglers',
     'bm_randomshield_smugglers',
     'bm_randomweapon_berserker',
     'bm_randomwpn_smugglers',
     'bm_skaalhunthelm',
     'bm_skaalhuntlgaunt',
     'bm_skaalhuntlpauldron',
     'bm_skaalhuntrgaunt',
     'bm_skaalhuntrpauldron',
     'bm_skaalhuntshield',
     'goblin_health',
     'goblin_weapons_random',
     'imperial guard random helmet',
     'imperial guard random lpauldron',
     'imperial guard random rpauldron',
     'imperial guard random shield',
     'imperial guard random skirt',
     'imperial guard random weapon',
     'l_b_amulets',
     'l_b_bandit_goods',
     'l_b_loot_tomb',
     'l_b_loot_tomb01',
     'l_b_loot_tomb02',
     'l_b_loot_tomb03',
     'l_b_rings',
     'l_m_amulets',
     'l_m_armor',
     'l_m_armor_boots',
     'l_m_armor_bracers',
     'l_m_armor_cuirass',
     'l_m_armor_gauntlet',
     'l_m_armor_helmet',
     'l_m_armor_shields',
     'l_m_belts',
     'l_m_enchantitem_hlaalu_rank0',
     'l_m_enchantitem_hlaalu_rank4',
     'l_m_enchantitem_hlaalu_rank6',
     'l_m_enchantitem_imperial_rank0',
     'l_m_enchantitem_redoran_rank2',
     'l_m_enchantitem_redoran_rank4',
     'l_m_enchantitem_redoran_rank6',
     'l_m_enchantitem_redoran_rank8',
     'l_m_enchantitem_telvanni_rank01',
     'l_m_enchantitem_telvanni_rank6',
     'l_m_enchantitem_telvanni_rank8',
     'l_m_enchantitem_temple_rank0_1',
     'l_m_enchantitem_temple_rank0_2',
     'l_m_enchantitem_temple_rank4',
     'l_m_enchantitem_temple_rank6',
     'l_m_enchantitem_temple_rank8_1',
     'l_m_enchantitem_temple_rank8_2',
     'l_m_potion',
     'l_m_potion_h',
     'l_m_rings',
     'l_m_wpn_melee',
     'l_m_wpn_melee_axe',
     'l_m_wpn_melee_blunt',
     'l_m_wpn_melee_long blade',
     'l_m_wpn_melee_short blade',
     'l_m_wpn_melee_spear',
     'l_m_wpn_missle',
     'l_m_wpn_missle_arrow',
     'l_m_wpn_missle_bolt',
     'l_n_amulet',
     'l_n_apparatus',
     'l_n_armor',
     'l_n_armor_boots',
     'l_n_armor_bracers',
     'l_n_armor_cuirass',
     'l_n_armor_gauntlet',
     'l_n_armor_greaves',
     'l_n_armor_helmet',
     'l_n_armor_pauldron',
     'l_n_armor_shields',
     'l_n_lockpicks',
     'l_n_probe',
     'l_n_repair item',
     'l_n_rings',
     'l_n_smuggled_goods',
     'l_n_soul gem',
     'l_n_wpn_melee',
     'l_n_wpn_melee_axe',
     'l_n_wpn_melee_blunt',
     'l_n_wpn_melee_blunt_berzerker',
     'l_n_wpn_melee_long blade',
     'l_n_wpn_melee_short blade',
     'l_n_wpn_melee_spear',
     'l_n_wpn_melee_tomb',
     'l_n_wpn_missle',
     'l_n_wpn_missle_arrow',
     'l_n_wpn_missle_bolt',
     'l_n_wpn_missle_bow',
     'l_n_wpn_missle_thrown',
     'l_n_wpn_missle_xbow',
     'random ashlander weapon',
     'random ebony weapon',
     'random excellent melee weapon',
     'random gold',
     'random gold_lev_05',
     'random gold_lev_10',
     'random gold_lev_15',
     'random gold_lev_20',
     'random orcish armor',
     'random_adamantium',
     'random_alchemy_diff',
     'random_alit_hide',
     'random_ampoule_pod',
     'random_armor_bonemold',
     'random_armor_chitin',
     'random_armor_fur',
     'random_armor_glass',
     'random_armor_iron',
     'random_armor_netch_leather',
     'random_armor_steel',
     'random_ash_salts',
     'random_ash_yam',
     'random_bandit_1-5',
     'random_bandit_11+',
     'random_bandit_6-10',
     'random_bear_pelt',
     'random_belladonna_plant',
     'random_belladonna_spriggan',
     'random_bittergreen_petals',
     'random_black_anther',
     'random_black_lichen',
     'random_boar_leather',
     'random_bonemeal',
     'random_book_dunmer',
     'random_book_imperial_dunmer',
     'random_book_imperial_hlaalu',
     'random_book_skill',
     'random_book_wizard_all',
     'random_book_wizard_evil',
     'random_bulbs',
     'random_bunglers_bane',
     'random_cabbage',
     'random_chokeweed',
     'random_coda_flower',
     'random_com_kitchenware',
     'random_comberry',
     'random_common_de_fclothes_01',
     'random_common_de_mclothes_01',
     'random_coprinus',
     'random_corkbulb_root',
     'random_cornberry',
     'random_corprus_weepings',
     'random_crab_meat',
     'random_daedra_heart',
     'random_daedra_skin',
     'random_daedric_weapon',
     'random_de_blueware_01',
     'random_de_cheapfood_01_nc',
     'random_de_cheapfood_01_ne',
     'random_de_pants',
     'random_de_pos_01',
     'random_de_pos_01_nc',
     'random_de_robe',
     'random_de_shirt',
     'random_de_shoes_common',
     'random_de_weapon',
     'random_diamond',
     'random_dreugh_wax',
     'random_drinks_01',
     'random_drinks_nord',
     'random_drinksndrugs_imp',
     'random_dwarven_all',
     'random_dwarven_ingredients',
     'random_dwarven_misc',
     'random_dwemer_armor',
     'random_dwemer_coins',
     'random_dwemer_weapon',
     'random_ebony',
     'random_ectoplasm',
     'random_expensive_de_fclothes_02',
     'random_expensive_de_mclothes_02',
     'random_exquisite_de_fclothes1',
     'random_exquisite_de_mclothes1',
     'random_extravagant_de_fclothes1',
     'random_extravagant_de_mclothes1',
     'random_fire_petal',
     'random_fire_salts',
     'random_food',
     'random_frost_salts',
     'random_gem',
     'random_ghoul_heart',
     'random_glass_weapon',
     'random_gold_kanet',
     'random_golden_saint_shield',
     'random_golden_saint_weapon',
     'random_golden_sedge',
     'random_gravetar',
     'random_green_lichen',
     'random_guar_hide',
     'random_hackle-lo_leaf',
     'random_heartwood',
     'random_heather',
     'random_holly',
     'random_horker_tusk',
     'random_hound_meat',
     'random_hypha_facia',
     'random_imp_armor',
     'random_imp_silverware',
     'random_imp_weapon',
     'random_ingredient',
     'random_ingredient_diff',
     'random_iron_fur_armor',
     'random_iron_weapon',
     'random_kagouti_hide',
     'random_kresh_fiber',
     'random_kwama egg',
     'random_kwama_cuttle',
     'random_loot_bonewalker',
     'random_loot_bonewalker_greater',
     'random_loot_special',
     'random_loot_special_marksman',
     'random_marshmerrow',
     'random_moon_sugar',
     'random_muck',
     'random_netch_leather',
     'random_noble_sedge',
     'random_nordic_weapons',
     'random_nordictomb_rare',
     'random_orcish_weapons',
     'random_pearl',
     'random_pos',
     'random_potion_attribute_restore',
     'random_potion_bad',
     'random_racer_plumes',
     'random_rat_meat',
     'random_rawglass',
     'random_red_guard_cloth_01',
     'random_red_lichen',
     'random_riekling_loot',
     'random_ripened_belladonna',
     'random_roobrush',
     'random_russula',
     'random_rye',
     'random_saltrice',
     'random_scales',
     'random_scamp_skin',
     'random_scathecraw',
     'random_scrap_metal',
     'random_scrib_jelly',
     'random_scroll_all',
     'random_shalk_resin',
     'random_silver_weapon',
     'random_skooma',
     'random_smuggler_1-5',
     'random_smuggler_11+',
     'random_smuggler_6-10',
     'random_snowbear_pelt',
     'random_snowwolf_pelt',
     'random_spines',
     'random_stalks',
     'random_steel_weapon',
     'random_stoneflower_petals',
     'random_sweetpulp',
     'random_timsa',
     'random_trama_root',
     'random_unripened_belladonna',
     'random_vampire_dust',
     'random_void_salts',
     'random_weapon_melee_basic',
     'random_wickwheat',
     'random_willow_anther',
     'random_wolf_pelt',
    );
my %BETH_LEVI;
foreach my $l (@beth_levi) { $BETH_LEVI{$l}++; }

my %REC_FLAGS = ("deleted"     => 0x0020,
		 "persistent"  => 0x0400,
		 "ignored"     => 0x1000,
		 "blocked"     => 0x2000);
$REC_FLAGS{substr($_, 0, 1)} = $REC_FLAGS{$_} foreach (keys %REC_FLAGS);

my %CELL_FLAGS = ("has_water" => 0x02,
		  "illegal_to_sleep_here" => 0x041,
		  "behave_like_exterior" => 0x80);

my %INFO_FUN = ('00' => "Reaction_Low",
		'01' => "Reaction_High",
		'02' => "Rank_Requirement",
		'03' => "Reputation",
		'04' => "Health_Percent",
		'05' => "PC_Reputation",
		'06' => "PC_Level",
		'07' => "PC_Health_Percent",
		'08' => "PC_Magicka",
		'09' => "PC_Fatigue",

		'10' => "PC_Strength",
		'11' => "PC_Block",
		'12' => "PC_Armorer",
		'13' => "PC_Medium_Armor",
		'14' => "PC_Heavy_Armor",
		'15' => "PC_Blunt_Weapon",
		'16' => "PC_Long_Blade",
		'17' => "PC_Axe",
		'18' => "PC_Spear",
		'19' => "PC_Athletics",

		'20' => "PC_Enchant",
		'21' => "PC_Destruction",
		'22' => "PC_Alteration",
		'23' => "PC_Illusion",
		'24' => "PC_Conjuration",
		'25' => "PC_Mysticism",
		'26' => "PC_Restoration",
		'27' => "PC_Alchemy",
		'28' => "PC_Unarmored",
		'29' => "PC_Security",

		'30' => "PC_Sneak",
		'31' => "PC_Acrobatics",
		'32' => "PC_Light_Armor",
		'33' => "PC_Short_Blade",
		'34' => "PC_Marksman",
		'35' => "PC_Mercantile",
		'36' => "PC_Speechcraft",
		'37' => "PC_Hand_To_Hand",
		'38' => "PC_Sex",
		'39' => "PC_Expelled",

		'40' => "PC_Common_Disease",
		'41' => "PC_Blight_Disease",
		'42' => "PC_Clothing_Modifier",
		'43' => "PC_Crime_Level",
		'44' => "Same_Sex",
		'45' => "Same_Race",
		'46' => "Same_Faction",
		'47' => "Faction_Rank_Difference",
		'48' => "Detected",
		'49' => "Alarmed",

		'50' => "Choice",
		'51' => "PC_Intelligence",
		'52' => "PC_Willpower",
		'53' => "PC_Agility",
		'54' => "PC_Speed",
		'55' => "PC_Endurance",
		'56' => "PC_Personality",
		'57' => "PC_Luck",
		'58' => "PC_Corprus",
		'59' => "Weather",

		'60' => "PC_Vampire",
		'61' => "Level",
		'62' => "Attacked",
		'63' => "Talked_To_PC",
		'64' => "PC_Health",
		'65' => "Creature_Target",
		'66' => "Friend_Hit",
		'67' => "Fight",
		'68' => "Hello",
		'69' => "Alarm",

		'70' => "Flee",
		'71' => "Should_Attack",
		'72' => "Werewolf",
		'73' => "Werewolf_Kills",

		'CX' => "Not_Class",
		'DX' => "Dead_Type",
		'FX' => "Not_Faction",
		'IX' => "Item_Type",
		'JX' => "Journal_Type",
		'LX' => "Not_Cell",
		'RX' => "Not_Race",
		'XX' => "Not_ID_Type",
		'fX' => "Global",
		'lX' => "PCGold",
		'sX' => "Variable_Compare",
	       );

my %INFO_SCVR_type =
    ('0' => "Nothing",
     '1' => "Function",
     '2' => "Global",
     '3' => "Local",
     '4' => "Journal",
     '5' => "Item",
     '6' => "Dead",
     '7' => "Not_ID",
     '8' => "Not_Faction",
     '9' => "Not_Class",
     'A' => "Not_Race",
     'B' => "Not_Cell",
     'C' => "Not_Local");

my %INFO_SCVR_cmp =
    ('0' => '=',
     '1' => '!=',
     '2' => '>',
     '3' => '>=',
     '4' => '<',
     '5' => '<=');

my %SEX = (0 => "Male", 1 => "Female", 0xFF => "None");
my %SPECIALIZATION = (0 => "Combat", 1 => "Magic", 2 => "Stealth");

my %SKILL = ( 0 => "Block",
	      1 => "Armorer",
	      2 => "MediumArmor",
	      3 => "HeavyArmor",
	      4 => "BluntWeapon",
	      5 => "LongBlade",
	      6 => "Axe",
	      7 => "Spear",
	      8 => "Athletics",
	      9 => "Enchant",
	     10 => "Destruction",
	     11 => "Alteration",
	     12 => "Illusion",
	     13 => "Conjuration",
	     14 => "Mysticism",
	     15 => "Restoration",
	     16 => "Alchemy",
	     17 => "Unarmored",
	     18 => "Security",
	     19 => "Sneak",
	     20 => "Acrobatics",
	     21 => "LightArmor",
	     22 => "ShortBlade",
	     23 => "Marksman",
	     24 => "Mercantile",
	     25 => "SpeechCraft",
	     26 => "HandToHand",
	    255 => "None");

my %ATTRIBUTE = (0 => "Strength",
		 1 => "Intelligence",
		 2 => "Willpower",
		 3 => "Agility",
		 4 => "Speed",
		 5 => "Endurance",
		 6 => "Personality",
		 7 => "Luck");

my %AUTOCALC_FLAGS = ("weapon" => 0x00001,
		      "armor" => 0x00002,
		      "clothing" => 0x00004,
		      "books" => 0x00008,
		      "ingredient" => 0x00010,
		      "picks" => 0x00020,
		      "probes" => 0x00040,
		      "lights" => 0x00080,
		      "apparatus" => 0x00100,
		      "repair" => 0x00200,
		      "misc" => 0x00400,
		      "spells" => 0x00800,
		      "magic_items" => 0x01000,
		      "potions" => 0x02000,
		      "training" => 0x04000,
		      "spellmaking" => 0x08000,
		      "enchanting" => 0x10000,
		      "repair_item" => 0x20000);

my %DIAL_TYPE = (0 => "Topic",
		 1 => "Voice",
		 2 => "Greeting",
		 3 => "Persuasion",
		 4 => "Journal");

my %SPLM_TYPE = (1 => "Spell", 2 => "Enchantment");

my %ENCHANT_TYPE = (0 => "Cast_Once",
		    1 => "Cast_on_Strike",
		    2 => "Cast_when_Used",
		    3 => "Constant_Effect");

my %RANGE_TYPE = (0 => "Self", 1 => "Touch", 2 => "Target");

my %MGEF_FLAGS = ("spellmaking" => 0x0200,
		  "enchanting" => 0x0400,
		  "negative" => 0x0800);

my %MAGIC_SCHOOL = (0 => "Alteration",
		    1 => "Conjuration",
		    2 => "Destruction",
		    3 => "Illusion",
		    4 => "Mysticism",
		    5 => "Restoration");

my %SPEL_TYPE = (0 => "Spell",
		 1 => "Ability",
		 2 => "Blight",
		 3 => "Disease",
		 4 => "Curse",
		 5 => "Power");

my %SPEL_FLAGS = ("autocalc" => 0x0001,
		  "pc_start" => 0x0002,
		  "always_succeeds" => 0x0004);

my %WEAPON_TYPE = (0 => "ShortBladeOneHand",
		   1 => "LongBladeOneHand",
		   2 => "LongBladeTwoClose",
		   3 => "BluntOneHand",
		   4 => "BluntTwoClose",
		   5 => "BluntTwoWide",
		   6 => "SpearTwoWide",
		   7 => "AxeOneHand",
		   8 => "AxeTwoHand",
		   9 => "MarksmanBow",
		   10 => "MarksmanCrossbow",
		   11 => "MarksmanThrown",
		   12 => "Arrow",
		   13 => "Bolt");

my %WEAPON_FLAGS = (1 => "[ignores_normal_weapon_resistance]");

my %CONTAINER_FLAGS = ("Organic" => 0x0001,
		       "Respawns,_Organic_only" => 0x0002,
		       "Default" => 0x0008);

my %CREATURE_FLAGS = ("biped" => 0x0001,
		      "respawn" => 0x0002,
		      "weapon_and_shield" => 0x0004,
		      "movement:none" => 0x0008,
		      "swims" => 0x0010,
		      "flies" => 0x0020,
		      "walks" => 0x0040,
		      "essential" => 0x0080,
		      "skeleton_blood" => 0x0400,
		      "metal_blood" => 0x0800);

my %ARMOR_TYPE = (0 => "Helmet",
		  1 => "Cuirass",
		  2 => "Left_Pauldron",
		  3 => "Right_Pauldron",
		  4 => "Greaves",
		  5 => "Boots",
		  6 => "Left_Gauntlet",
		  7 => "Right_Gauntlet",
		  8 => "Shield",
		  9 => "Left_Bracer",
		  10 => "Right_Bracer");

my %APPARATUS_TYPE = (0 => "Mortar_and_Pestle",
		      1 => "Alembic",
		      2 => "Calcinator",
		      3 => "Retort");

my %ARMOR_INDEX = (0 => "Head",
		   1 => "Hair",
		   2 => "Neck",
		   3 => "Cuirass",
		   4 => "Groin",
		   5 => "Skirt",
		   6 => "Right_Hand",
		   7 => "Left_Hand",
		   8 => "Right_Wrist",
		   9 => "Left_Wrist",
		   10 => "Shield",
		   11 => "Right_Forearm",
		   12 => "Left_Forearm",
		   13 => "Right_Upper_Arm",
		   14 => "Left_Upper_Arm",
		   15 => "Right_Foot",
		   16 => "Left_Foot",
		   17 => "Right_Ankle",
		   18 => "Left_Ankle",
		   19 => "Right_Knee",
		   20 => "Left_Knee",
		   21 => "Right_Upper_Leg",
		   22 => "Left_Upper_Leg",
		   23 => "Right_Pauldron",
		   24 => "Left_Pauldron",
		   25 => "Weapon",
		   26 => "Tail");

my %CTDT_TYPE = (0 => "Pants",
		 1 => "Shoes",
		 2 => "Shirt",
		 3 => "Belt",
		 4 => "Robe",
		 5 => "Right_Glove",
		 6 => "Left_Glove",
		 7 => "Skirt",
		 8 => "Ring",
		 9 => "Amulet");

my %NPC_FLAGS = ("female" => 0x0001,
		 "essential" => 0x0002,
		 "respawn" => 0x0004,
		 "autocalc" => 0x0010,
		 "blood_skel" => 0x0400,
		 "blood_metal" => 0x0800);

my %LEVI_DATA = (1 => "Calc from all levels <= PC level",
		 2 => "Calc for each item");

my %AIDT_FLAGS = ("weapon" => 0x00001,
		  "armor" => 0x00002,
		  "clothing" => 0x00004,
		  "books" => 0x00008,
		  "ingredient" => 0x00010,
		  "picks" => 0x00020,
		  "probes" => 0x00040,
		  "lights" => 0x00080,
		  "apparatus" => 0x00100,
		  "repair" => 0x00200,
		  "misc" => 0x00400,
		  "spells" => 0x00800,
		  "magic_items" => 0x01000,
		  "potions" => 0x02000,
		  "training" => 0x04000,
		  "spellmaking" => 0x08000,
		  "enchanting" => 0x10000,
		  "repair_item" => 0x20000);

my %LHDT_FLAGS = ("dynamic" => 0x0001,
		  "can_carry" => 0x0002,
		  "negative" => 0x0004,
		  "flicker" => 0x0008,
		  "fire" => 0x0010,
		  "off_default" => 0x0020,
		  "flicker_slow" => 0x0040,
		  "pulse" => 0x0080,
		  "pulse_slow" => 0x0100);

my %RADT_FLAGS = ("playable" => 0x01,
		  "beast_race" => 0x02);

my %SPELL_EFFECT = ('0' => "Water_Breathing",
		    '1' => "Swift_Swim",
		    '2' => "Water_Walking",
		    '3' => "Shield",
		    '4' => "Fire_Shield",
		    '5' => "Lightning_Shield",
		    '6' => "Frost_Shield",
		    '7' => "Burden",
		    '8' => "Feather",
		    '9' => "Jump",
		    '10' => "Levitate",
		    '11' => "Slowfall",
		    '12' => "Lock",
		    '13' => "Open",
		    '14' => "Fire_Damage",
		    '15' => "Shock_Damage",
		    '16' => "Frost_Damage",
		    '17' => "Drain_Attribute",
		    '18' => "Drain_Health",
		    '19' => "Drain_Magicka",
		    '20' => "Drain_Fatigue",
		    '21' => "Drain_Skill",
		    '22' => "Damage_Attribute",
		    '23' => "Damage_Health",
		    '24' => "Damage_Magicka",
		    '25' => "Damage_Fatigue",
		    '26' => "Damage_Skill",
		    '27' => "Poison",
		    '28' => "Weakness_to_Fire",
		    '29' => "Weakness_to_Frost",
		    '30' => "Weakness_to_Shock",
		    '31' => "Weakness_to_Magicka",
		    '32' => "Weakness_to_Common_Disease",
		    '33' => "Weakness_to_Blight_Disease",
		    '34' => "Weakness_to_Corprus_Disease",
		    '35' => "Weakness_to_Poison",
		    '36' => "Weakness_to_Normal_Weapons",
		    '37' => "Disintegrate_Weapon",
		    '38' => "Disintegrate_Armor",
		    '39' => "Invisibility",
		    '40' => "Chameleon",
		    '41' => "Light",
		    '42' => "Sanctuary",
		    '43' => "Night_Eye",
		    '44' => "Charm",
		    '45' => "Paralyze",
		    '46' => "Silence",
		    '47' => "Blind",
		    '48' => "Sound",
		    '49' => "Calm_Humanoid",
		    '50' => "Calm_Creature",
		    '51' => "Frenzy_Humanoid",
		    '52' => "Frenzy_Creature",
		    '53' => "Demoralize_Humanoid",
		    '54' => "Demoralize_Creature",
		    '55' => "Rally_Humanoid",
		    '56' => "Rally_Creature",
		    '57' => "Dispel",
		    '58' => "Soultrap",
		    '59' => "Telekinesis",
		    '60' => "Mark",
		    '61' => "Recall",
		    '62' => "Divine_Intervention",
		    '63' => "Almsivi_Intervention",
		    '64' => "Detect_Animal",
		    '65' => "Detect_Enchantment",
		    '66' => "Detect_Key",
		    '67' => "Spell_Absorption",
		    '68' => "Reflect",
		    '69' => "Cure_Common_Disease",
		    '70' => "Cure_Blight_Disease",
		    '71' => "Cure_Corprus_Disease",
		    '72' => "Cure_Poison",
		    '73' => "Cure_Paralyzation",
		    '74' => "Restore_Attribute",
		    '75' => "Restore_Health",
		    '76' => "Restore_Magicka",
		    '77' => "Restore_Fatigue",
		    '78' => "Restore_Skill",
		    '79' => "Fortify_Attribute",
		    '80' => "Fortify_Health",
		    '81' => "Fortify_Magicka",
		    '82' => "Fortify_Fatigue",
		    '83' => "Fortify_Skill",
		    '84' => "Fortify_Maximum_Magicka",
		    '85' => "Absorb_Attribute",
		    '86' => "Absorb_Health",
		    '87' => "Absorb_Magicka",
		    '88' => "Absorb_Fatigue",
		    '89' => "Absorb_Skill",
		    '90' => "Resist_Fire",
		    '91' => "Resist_Frost",
		    '92' => "Resist_Shock",
		    '93' => "Resist_Magicka",
		    '94' => "Resist_Common_Disease",
		    '95' => "Resist_Blight_Disease",
		    '96' => "Resist_Corprus_Disease",
		    '97' => "Resist_Poison",
		    '98' => "Resist_Normal_Weapons",
		    '99' => "Resist_Paralysis",
		    '100' => "Remove_Curse",
		    '101' => "Turn_Undead",
		    '102' => "Summon_Scamp",
		    '103' => "Summon_Clannfear",
		    '104' => "Summon_Daedroth",
		    '105' => "Summon_Dremora",
		    '106' => "Summon_Ancestral_Ghost",
		    '107' => "Summon_Skeltal_Minion",
		    '108' => "Summon_Bonewalker",
		    '109' => "Summon_Greater_Bonewalker",
		    '110' => "Summon_Bonelord",
		    '111' => "Summon_Winged_Twilight",
		    '112' => "Summon_Hunger",
		    '113' => "Summon_Golden_Saint",
		    '114' => "Summon_Flame_Atronach",
		    '115' => "Summon_Frost_Atronach",
		    '116' => "Summon_Storm_Atronach",
		    '117' => "Fortify_Attack",
		    '118' => "Command_Creature",
		    '119' => "Command_Humanoid",
		    '120' => "Bound_Dagger",
		    '121' => "Bound_Longsword",
		    '122' => "Bound_Mace",
		    '123' => "Bound_Battle_Axe",
		    '124' => "Bound_Spear",
		    '125' => "Bound_Longbow",
		    '126' => "EXTRA_SPELL",
		    '127' => "Bound_Cuirass",
		    '128' => "Bound_Helm",
		    '129' => "Bound_Boots",
		    '130' => "Bound_Shield",
		    '131' => "Bound_Gloves",
		    '132' => "Corprus",
		    '133' => "Vampirism",
		    '134' => "Summon_Centurion_Spider",
		    '135' => "Sun_Damage",
		    '136' => "Stunted_Magicka",
		    '137' => "Summon_Fabricant",
		    '138' => "Call_Wolf",
		    '139' => "Call_Bear",
		    '140' => "Summon_Bonewolf",
		    '141' => "sEffectSummonCreature04",
		    '142' => "sEffectSummonCreature05",
		   );

my %BYDT_PART = ('0' => "Head",
		 '1' => "Hair",
		 '2' => "Neck",
		 '3' => "Chest",
		 '4' => "Groin",
		 '5' => "Hand",
		 '6' => "Wrist",
		 '7' => "Forearm",
		 '8' => "Upperarm",
		 '9' => "Foot",
		 '10' => "Ankle",
		 '11' => "Knee",
		 '12' => "Upperleg",
		 '13' => "Clavicle",
		 '14' => "Tail");

my %BYDT_FLAGS = ('0' => "None", '1' => "Female", '2' => "Playable");

my %BYDT_PTYP = ('0' => "Skin", "1" => "Clothing", "2" => "Armor");

my %FACT_FLAGS = ("hidden_from_player" => 0x0001);

my @CREA_TYPE = qw(Creature Daedra Undead Humanoid);

my @SNDG_DATA = ("Left_Foot", "Right_Foot", "Swim_Left", "Swim_Right", "Moan", "Roar", "Scream", "Land");


sub unpack_short_array {
    my $i = 1;
    my %hr;
    $hr{$i++} = $_ foreach (unpack("s*", $_[0]));
    \%hr;
};
sub pack_short_array {
    my($hr) = @_;
    my @vals;
    unshift(@vals, $hr->{$_}) foreach (sort { $a <=> $b } keys %{$hr});
    pack("s*", @vals);
}
sub unpack_long_array {
    my $i = 1;
    my %hr;
    $hr{$i++} = $_ foreach (unpack("l*", $_[0]));
    \%hr;
};
sub pack_long_array {
    my($hr) = @_;
    my @vals;
    unshift(@vals, $hr->{$_}) foreach (sort { $a <=> $b } keys %{$hr});
    pack("l*", @vals);
}
sub unpack_float_array {
    my $i = 1;
    my %hr;
    $hr{$i++} = $_ foreach (unpack("f*", $_[0]));
    \%hr;
};
sub pack_float_array {
    my($hr) = @_;
    my @vals;
    unshift(@vals, $hr->{$_}) foreach (sort { $a <=> $b } keys %{$hr});
    pack("f*", @vals);
}

my $RD_Actor_Data =
#     Field                              Offset
    [([[("Unknown_1") x 10], "L10"],   #   0
      ["Health", "f"],		       #  40
      ["Max_Health", "f"],	       #  44
      ["Fatigue", "f"],		       #  48
      ["Max_Fatigue", "f"],	       #  52
      ["Unknown_1", "f"],	       #  56
      ["Unknown_1", "f"],	       #  60
      ["Unknown_1", "f"],	       #  64
      ["Unknown_1", "f"],	       #  68
      ["Unknown_1", "f"],	       #  72
      ["Encumbrance", "f"],	       #  76
      ["STR", "f"],		       #  80
      ["STR_Base", "f"],	       #  84
      ["INT", "f"],		       #  88
      ["INT_Base", "f"],	       #  92
      ["WIL", "f"],		       #  96
      ["WIL_Base", "f"],	       # 100
      ["AGI", "f"],		       # 104
      ["AGI_Base", "f"],	       # 108
      ["SPD", "f"],		       # 112
      ["SPD_Base", "f"],	       # 116
      ["END", "f"],		       # 120
      ["END_Base", "f"],	       # 124
      ["PER", "f"],		       # 128
      ["PER_Base", "f"],	       # 132
      ["LUC", "f"],		       # 136
      ["LUC_Base", "f"],	       # 140
      ["Fortify_Attack", "L"],	       # 144
      ["Sanctuary", "L"],	       # 148
      ["Resist_Magicka", "C"],	       # 152
      ["Unknown_1", "a3"],
      ["Resist_Fire", "C"],	# 156 (+ Fire Shield)
      ["Unknown_1", "a3"],
      ["Resist_Frost", "C"],	# 160 (+ Frost Shield)
      ["Unknown_1", "a3"],
      ["Resist_Shock", "C"],	# 164 (+ Lightning Shield)
      ["Unknown_1", "a3"],
      ["Resist_Common_Disease", "L"],		   # 168
      ["Unknown_1", "L"],			   # 172
      ["Unknown_1", "L"],			   # 176
      ["Resist_Poison", "L"],			   # 180
      ["Resist_Paralysis", "L"],		   # 184
      ["Chameleon", "L"],			   # 188
      ["Resist_Normal_Weapons", "L"],		   # 192
      ["Water_Breathing", "L"],			   # 196
      ["Water_Walking", "L"],			   # 200
      ["Swift_Swim", "L"],			   # 204
      ["Unknown_1", "L"],			   # 208
      ["Levitate", "L"],			   # 212
      ["Shield", "L"],				   # 216
      ["Unknown_1", "L"],			   # 220
      ["Unknown_1", "L"],			   # 224
      ["Blind", "L"],				   # 228
      ["Unknown_1", "L"],			   # 232
      ["Invisibility", "L"],			   # 236
      ["Unknown_1", "L"],			   # 240
      ["Unknown_1", "L"],			   # 244
      ["Unknown_1", "L"],			   # 248
      ["Unknown_1", "L"],			   # 252
      ["Unknown_1", "L"],			   # 256
      ["Unknown_1", "L"])];

my $RD_Enchantment =
    [["Spell_Effect", "S"], ["Skill", "C"], ["Attribute", "C"], ["Range", "L"],
     ["Area", "L"], ["Duration", "L"], ["MagMin", "L"], ["MagMax", "L"]];

my $RD_Unknown = [["Unknown_1", "H*"]];

my %RECDEF =
    {
     ACTI => [
	      NAME => [["ID", "a*"]],
	      FNAM => [["Name", "a*"]],
	      MODL => [["Model", "a*"]],
	      SCRI => [["Script", "a*"]],
	     ],
     ALCH => [
	      NAME => [["ID", "a*"]],
	      ALDT => [["Weight", "f"], ["Value", "L"], ["Autocalc", "L"]],
	      ENAM => $RD_Enchantment,
	      FNAM => [["Name", "a*"]],
	      MODL => [["Model", "a*"]],
	      SCRI => [["Script", "a*"]],
	      TEXT => [["Icon", "a*"]],
	     ],
     APPA => [
	      NAME => [["ID", "a*"]],
	      AADT => [["Type", "L"], ["Quality", "f"], ["Weight", "f"], ["Value", "L"]],
	      FNAM => [["Name", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      SCRI => [["Script", "a*"]],
	     ],
     ARMO => [
	      NAME => [["ID", "a*"]],
	      AODT => [["Type", "L"], ["Weight", "f"], ["Value", "L"], ["Health", "L"], ["Enchant_Points", "L"], ["Armor_Rating", "L"]],
	      BNAM => [["Male_Body_ID", "a*"]],
	      CNAM => [["Female_Body_ID", "a*"]],
	      ENAM => [["Enchantment", "a*"]],
	      FNAM => [["Name", "a*"]],
	      INDX => [["Part_Index", "C"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      SCRI => [["Script", "a*"]],
	     ],
     BODY => [
	      NAME => [["ID", "a*"]],
	      BYDT => [["Body_Part", "C"], ["Vampire", "C"], ["Flags", "C"], ["Part_Type", "C"]],
	      FNAM => [["Name", "a*"]],
	      MODL => [["Model", "a*"]],
	     ],
     BOOK => [
	      NAME => [["ID", "a*"]],
	      BKDT => [["Weight", "f"], ["Value", "L"], ["Scroll", "L"], ["Skill", "L"], ["Enchant_Points", "L"]],
	      ENAM => [["Enchantment", "a*"]],
	      FNAM => [["Name", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      SCRI => [["Script", "a*"]],
	      TEXT => [["Text", "a*"]],
	     ],
     BSGN => [
	      NAME => [["ID", "a*"]],
	      DESC => [["Description", "a*"]],
	      FNAM => [["Name", "a*"]],
	      NPCS => [["Spell", "a*"]],
	      TNAM => [["Image", "a*"]]
	     ],
     CELL => [
	      [
	       AMBI => [["Ambient_Color", "L"], ["Sunlight_Color", "L"], ["Fog_Color", "L"], ["Fog_Density", "f"]],
	      ],
	      [
	       FRMR => [["ObjIdx", "S"], ["Unknown", "C"], ["ModIdx", "C"]],
	      ],
	      ACDT => $RD_Actor_Data,
	      ACSC => $RD_Unknown,
	      ACSL => $RD_Unknown,
	      ACTN => $RD_Unknown,
	      ANAM => $RD_Unknown,
	      ANIS => $RD_Unknown,
	      APUD => $RD_Unknown,
	      BNAM => $RD_Unknown,
	      CHRD => $RD_Unknown,
	      CNAM => $RD_Unknown,
	      CNDT => $RD_Unknown,
	      CRED => $RD_Unknown,
	      CSHN => $RD_Unknown,
	      CSTN => [["Target", "Z*"]], # guessing this is: "Cast/Current Spell Target Name"
	      DATA => [sub {
			   my($buff) = @_;
			   my $dlen = length($buff);
			   if ($dlen == 24) {
			       my($x, $y, $z, $xrot, $yrot, $zrot) = unpack("f6", $buff);
			       return({ X => $x, Y => $y, Z => $z,
					X_angle => $xrot, Y_angle => $yrot, Z_angle => $zrot });
			   } elsif ($dlen == 12) {
			       my($flags, $unk, $fog) = unpack("LLf", $buff);
			       if ($flags & 0x01) { # Interior
				   return({ Flags => $flags, Unknown => $unk, Fog_Density => $fog });
			       } else {	# Exterior
				   my($x, $y) = unpack("x[L]ll", $buff);
				   return({ Flags => $flags, X => $x, Y => $y });
			       }
			   } else {
			       die "DECODER ERROR on CELL.DATA, Invalid length: $dlen\n";
			   }
		       },
		       sub {
			   my($hr) = @_;
			   if (exists $hr->{flags}) {
			       if ($hr->{flags} & 0x01) { # Interior
				   return(pack("LLf", $hr->{flags}, $hr->{unknown}, $hr->{fog_density}));
			       } else {	# Exterior
				   return(pack("Lll", $hr->{flags}, $hr->{x}, $hr->{y}));
			       }
			   } else {
			       return(pack("f6", $hr->{x}, $hr->{y}, $hr->{z},
					   $hr->{x_angle}, $hr->{y_angle}, $hr->{z_angle}));
			   }
		       }],
	      DELE => [["Unknown", "H4"]],
	      DNAM => [["Door_ID", "a*"]],
	      DODT => [["X", "f"], ["Y", "f"], ["Z", "f"], ["Angle_X", "f"], ["Angle_Y", "f"], ["Angle_Z", "f"]],
	      FGTN => $RD_Unknown,
	      FLTV => [["Unknown_1", "f"]],
	      INDX => $RD_Unknown,
	      INTV => $RD_Unknown,
	      KNAM => $RD_Unknown,
	      LSHN => $RD_Unknown,
	      LSTN => $RD_Unknown,
	      LVCR => $RD_Unknown,
	      MNAM => $RD_Unknown,
	      MVRF => [["Moved_Ref", "L"]], # .ess
	      NAM0 => [["Object_Count", "L"]],
	      NAM5 => [["Red", "C"], ["Green", "C"], ["Blue", "C"], ["Unused", "C"]], # Map Color
	      NAM8 => $RD_Unknown,
	      NAM9 => [["Owner", "L"]],
	      NAME => [["ID", "a*"]],
	      ND3D => $RD_Unknown,
	      PRDT => $RD_Unknown,
	      PWPC => $RD_Unknown,
	      PWPS => $RD_Unknown,
	      RGNN => $RD_Unknown,
	      SCRI => [["Script", "a*"]],
	      SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]],
	      SLFD => [\&unpack_float_array, \&pack_float_array],
	      SLLD => [\&unpack_long_array,  \&pack_long_array],
	      SLSD => [\&unpack_short_array, \&pack_short_array],
	      STPR => $RD_Unknown,
	      TGTN => $RD_Unknown,
	      TNAM => $RD_Unknown,
	      UNAM => $RD_Unknown,
	      WHGT => $RD_Unknown,
	      WNAM => $RD_Unknown,
	      XCHG => [["Enchant_Charge", "L"]],
	      XNAM => $RD_Unknown,
	      XSCL => [["Scale", "f"]],
	      XSOL => [["Soul", "Z*"]],
	      YNAM => $RD_Unknown,
	      ZNAM => $RD_Unknown,
	     ],
     CLAS => [
	      NAME => [["ID", "a*"]],
	      CLDT => [["Primary_Attribute", "L"], ["Secondary_Attribute", "L"], ["Specialization", "L"],
		       [[("Minor_Skill_1", "Major_Skill_1") x 5], "(L2)5"], ["Flags", "L"], ["AutoCalc", "L"]],
	      DESC => [["Description", "a*"]],
	      FNAM => [["Name", "a*"]],
	     ],
     CLOT => [
	      NAME => [["ID", "a*"]],
	      BNAM => [["Male_Body_ID", "a*"]],
	      CNAM => [["Female_Body_ID", "a*"]],
	      CTDT => [["Type", "L"], ["Weight", "f"], ["Value", "S"], ["Enchant_Points", "S"]],
	      ENAM => [["Enchantment_ID", "a*"]],
	      FNAM => [["Name", "a*"]],
	      INDX => [["Index", "C"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      SCRI => [["Script", "a*"]],
	     ],
     CNTC => [
	      NAME => [["ID", "a*"]],
	      INDX => [["Index", "L"]],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      SCRI => [["Script", "a*"]],
	      SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]],
	      SLFD => [\&unpack_float_array, \&pack_float_array],
	      SLLD => [\&unpack_long_array,  \&pack_long_array],
	      SLSD => [\&unpack_short_array, \&pack_short_array],
	      XCHG => [["Enchant_Charge", "L"]],
	      XHLT => [["Health", "L"]],
	      XIDX => [["Scripted_Item_Index", "L"]],
	      XSOL => [["Soul", "Z*"]],
	     ],
     CONT => [
	      FNAM => [["Name", "a*"]],
	      CNDT => [["Weight", "f"]],
	      FLAG => [["Container_Flags", "L"]],
	      INDX => [["Unknown_1", "L"]],	# .ess
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      SCRI => [["Script", "a*"]],
	     ],
     CREA => [
	      NAME => [["ID", "a*"]],
	      AIDT => [["Hello", "C"], ["Unknown_1", "C"], ["Fight", "C"], ["Flee", "C"], ["Alarm", "C"], ["Unknown_1", "a3"], ["Flags", "L"]],
	      AI_E => $RD_Unknown,
	      AI_F => $RD_Unknown,
	      AI_T => $RD_Unknown,
	      AI_W => [["Distance", "S"], ["Duration", "C"], ["Time_of_day", "C"], [[("Idle_1") x 10], "C10"]],
	      CNAM => $RD_Unknown,
	      DNAM => $RD_Unknown,
	      DODT => [["X", "f"], ["Y", "f"], ["Z", "f"], ["Angle_X", "f"], ["Angle_Y", "f"], ["Angle_Z", "f"]],
	      FLAG => [["Flags", "L"]],
	      FNAM => [["Name", "a*"]],
	      INDX => $RD_Unknown,
	      MODL => [["Model", "a*"]],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      NPCS => $RD_Unknown,
	      NPDT => [["Type", "L"], ["Lev", "L"], ["Str", "L"], ["Int", "L"], ["Wil", "L"], ["Agi", "L"], ["Spd", "L"], ["End", "L"], ["Per", "L"], ["Lck", "L"], ["Health", "L"], ["Spell_Points", "L"], ["Fatigue", "L"], ["Soul", "L"], ["Combat", "L"], ["Magic", "L"], ["Stealth", "L"], ["Attack_1_Min", "L"], ["Attack_1_Max", "L"], ["Attack_2_Min", "L"], ["Attack_2_Max", "L"], ["Attack_3_Min", "L"], ["Attack_3_Max", "L"], ["Gold", "L"]],
	      SCRI => [["Script", "a*"]],
	      XSCL => [["Scale", "f"]],
	     ],
     CREC => [
	      NAME => [["ID", "a*"]],
	      AI_F => $RD_Unknown,
	      AI_T => $RD_Unknown,
	      AI_W => $RD_Unknown,
	      INDX => $RD_Unknown,
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      SCRI => [["Script", "a*"]],
	      SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]],
	      SLFD => [\&unpack_float_array, \&pack_float_array],
	      SLSD => [\&unpack_short_array, \&pack_short_array],
	      WIDX => [["Equipped_Index", "l"], ["Ammo_Flag", "l"]],
	      XCHG => [["Enchant_Charge", "L"]],
	      XHLT => [["Health", "L"]],
	      XIDX => $RD_Unknown,
	      XSCL => [["Scale", "f"]],
	     ],
     DIAL => [
	      NAME => [["ID", "a*"]],
	      DATA => [["Type", "C"]],
	      XIDX => $RD_Unknown,
	     ],
     DOOR => [
	      NAME => [["ID", "a*"]],
	      ANAM => [["Door_Close_Sound", "a*"]],
	      FNAM => [["Name", "a*"]],
	      MODL => [["Model", "a*"]],
	      SCRI => [["Script", "a*"]],
	      SNAM => [["Door_Open_Sound", "a*"]],
	     ],
     ENCH => [
	      NAME => [["ID", "a*"]],
	      ENAM => $RD_Enchantment,
	      ENDT => [["Type", "L"], ["Cost", "L"], ["Charge", "L"], ["Autocalc", "L"]],
	     ],
     FACT => [
	      NAME => [["ID", "a*"]],
	      ANAM => [["Contra_Faction", "a*"]],
	      FADT => [["Primary_Attribute", "L"], ["Secondary_Attribute", "L"],
		       [[("At1_1", "At2_1", "Sk1_1", "Sk2_1", "Fact_1") x 10], "(L5)10"],
		       [[("Sk_1") x 6], "L6"], ["Unknown_1", "L"], ["Flags", "L"]],
	      FNAM => [["Name", "a*"]],
	      INTV => [["Contra_Faction_Factor", "a*"]],
	      RNAM => [["Rank", "a*"]],
	     ],
     FMAP => [
	      MAPD => $RD_Unknown,
	      MAPH => $RD_Unknown,
	     ],
     GAME => [
	      GMDT => [["Current_Cell", "Z*"]], # there is junk following the cell name ... not clear if there's a max cell name size?
	     ],
     GLOB => [
	      NAME => [["ID", "a*"]],
	      FLTV => [["Float", "f"]],
	      FNAM => [["Type", "a"]],
	     ],
     GMST => [
	      NAME => [["ID", "a*"]],
	      FLTV => [["Float", "f"]],
	      INTV => [["Integer", "l"]],
	      STRV => [["String", "a*"]],
	     ],
     INFO => [
	      INAM => [["ID", "a*"]],
	      ACDT => [["Actor_Data", "Z*"]], # .ess
	      ANAM => [["Cell", "Z*"]],
	      BNAM => [["Result", "a*"]],
	      CNAM => [["Class", "Z*"]],
	      DATA => [["Unknown_1", "L"], ["Disposition", "L"], ["Rank", "C"],
		       ["Sex", "C"], ["PCRank", "C"], ["Unknown_1", "C"]],
	      DNAM => [["PC_Faction", "Z*"]],
	      FLTV => [["Result_Value", "f"]],
	      FNAM => [["Faction", "Z*"]],
	      INTV => [["Compare_Value", "L"]],
	      NAME => [["Response", "a*"]],
	      NNAM => [["Next_ID", "Z*"]],
	      ONAM => [["Actor", "Z*"]],
	      PNAM => [["Prev_ID", "Z*"]],
	      QSTF => [["Quest_Finished", "C"]],
	      QSTN => [["Quest_Name", "C"]],
	      QSTR => [["Quest_Restart", "C"]],
	      RNAM => [["Race", "a*"]],
	      SCVR => [["Index", "a"], ["Type", "a"], ["Function", "a2"], ["Comparison", "a"], ["Name", "a*"]],
	      SNAM => [["Sound_File", "a"]],
	     ],
     INGR => [
	      NAME => [["ID", "a*"]],
	      FNAM => [["Name", "a*"]],
	      IRDT => [["Weight", "f"], ["Value", "L"], [[("Effect_1") x 4], "l4"], [[("Skill_1") x 4], "l4"], [[("Attribute_1") x 4], "l4"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      SCRI => [["Script", "a*"]],
	     ],
     JOUR => [
	      NAME => [["ID", "a*"]],
	     ],
     KLST => [
	      [
	       KNAM => [["ID", "a*"]],
	       CNAM => [["Dead_Count", "L"]],
	       INTV => [["End_of_List", "L"]],
	      ]
	     ],
     LAND => [
	      DATA => $RD_Unknown,
	      INTV => [["X", "l"], ["Y", "l"]],
	      VCLR => $RD_Unknown,
	      VHGT => $RD_Unknown,
	      VNML => $RD_Unknown,
	      VTEX => $RD_Unknown,
	      WNAM => $RD_Unknown,
	     ],
     LEVC => [
	      NAME => [["ID", "a*"]],
	      DATA => [["List_Data", "L"]],
	      INDX => [["Item_Count", "L"]],
	      [
	       CNAM => [["Actor_ID", "a*"]],
	       INTV => [["Level", "S"]],
	      ],
	      NNAM => [["Chance_None", "C"]]
	     ],
     LEVI => [
	      NAME => [["ID", "a*"]],
	      DATA => [["List_Data", "L"]],
	      INDX => [["Item_Count", "L"]],
	      [
	       INAM => [["Item_ID", "Z*"]],
	       INTV => [["Level", "S"]],
	      ],
	      NNAM => [["Chance_None", "C"]]
	     ],
     LIGH => [
	      FNAM => [["Name", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      LHDT => [["Weight", "f"], ["Value", "L"], ["Time", "L"], ["Radius", "L"],
		       ["Red", "C"], ["Green", "C"], ["Blue", "C"],
		       ["Unknown_1", "C"], ["Flags", "L"]],
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	      SCRI => [["Script", "a*"]],
	      SNAM => [["Sound_ID", "a*"]],
	     ],
     LOCK => [
	      FNAM => [["Name", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      LKDT => [["Weight", "f"], ["Value", "L"], ["Quality", "f"], ["Uses", "L"]],
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	      SCRI => [["Script", "a*"]],
	     ],
     LTEX => [
	      NAME => [["ID", "a*"]],
	      DATA => [["Texture_Path", "Z*"]],
	      INTV => [["Unknown_1", "L"]],
	     ],
     MGEF => [
	      INDX => [["ID", "L"]],
	      ASND => [["Area_Sound", "a*"]],
	      AVFX => [["Area_VFX", "a*"]],
	      BSND => [["Bolt_Sound", "a*"]],
	      BVFX => [["Bolt_VFX", "a*"]],
	      CSND => [["Cast_Sound", "a*"]],
	      CVFX => [["Cast_VFX", "a*"]],
	      DESC => [["Description", "a*"]],
	      HSND => [["Hit_Sound", "a*"]],
	      HVFX => [["Hit_VFX", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      MEDT => [["School", "L"], ["Base_Cost", "f"],["Flags", "L"],
		       ["Red", "L"], ["Green", "L"], ["Blue", "L"],
		       ["Speed", "f"], ["Size", "f"], ["SizeCap", "f"]],
	      PTEX => [["Particle_Texture", "a*"]],
	     ],
     MISC => [
	      FNAM => [["Name", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      MCDT => [["Weight", "f"], ["Value", "L"], ["Unknown_1", "L"]],
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	      SCRI => [["Script", "a*"]],
	     ],
     NPCC => [
	      AI_E => $RD_Unknown,
	      AI_F => $RD_Unknown,
	      AI_T => $RD_Unknown,
	      AI_W => $RD_Unknown,
	      NAME => [["ID", "a*"]],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      NPDT => $RD_Unknown,
	      SCRI => [["Script", "a*"]],
	      SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]],
	      SLFD => [\&unpack_float_array, \&pack_float_array],
	      SLLD => [\&unpack_long_array,  \&pack_long_array],
	      SLSD => [\&unpack_short_array, \&pack_short_array],
	      WIDX => [["Equipped_Index", "l"], ["Ammo_Flag", "l"]],
	      XCHG => [["Enchant_Charge", "L"]],
	      XHLT => [["Health", "L"]],
	      XIDX => $RD_Unknown,
	      XSOL => [["Soul", "Z*"]],
	     ],
     NPC_ => [
	      AIDT => [["Hello", "C"], ["Unknown_1", "C"], ["Fight", "C"], ["Flee", "C"], ["Alarm", "C"], ["Unknown_1", "a3"], ["Flags", "L"]],
	      AI_E => [["X", "l"], ["Y", "l"], ["Z", "l"], ["Duration", "S"], ["ID", "a32"], ["Unknown_1", "S"]],
	      AI_F => $RD_Unknown,
	      AI_T => $RD_Unknown,
	      AI_W => [["Distance", "S"], ["Duration", "S"], ["Time_of_day", "C"], [[("Idle_1") x 8], "C8"], ["Unknown_1", "C"]],
	      ANAM => $RD_Unknown,
	      BNAM => $RD_Unknown,
	      CNAM => $RD_Unknown,
	      CNDT => [["Data", "Z*"]],
	      DNAM => $RD_Unknown,
	      DODT => [["X", "f"], ["Y", "f"], ["Z", "f"], ["Angle_X", "f"], ["Angle_Y", "f"], ["Angle_Z", "f"]],
	      FLAG => [["Flags", "L"]],
	      FNAM => [["Name", "a*"]],
	      KNAM => $RD_Unknown,
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      NPCS => $RD_Unknown,
	      NPDT => [sub {
			   my($buff) = @_;
			   my %hr;
			   my $len = length($buff);
			   if ($len == 12) {
			       my($lev, $disp, $fact, $rank, $unk1, $unk2, $unk3, $gold) = unpack("SC6L", $_[0]);
			       return({ Level => $lev, Disposition => $disp, Faction => $fact, Rank => $rank,
					Unk1 => $unk1, Unk2 => $unk2, Unk3 => $unk3, Gold => $gold });
			   } elsif ($len == 52) {
			       my $i = 0;
			       my %hr;
			       foreach my $skill_level (unpack("x[SC8]C27", $buff)) {
				   $hr{$SKILL{$i++}} = $skill_level;
			       }
			       ($hr{Level}, $hr{Str}, $hr{Int}, $hr{Wil}, $hr{Agi}, $hr{Spd}, $hr{End},
				$hr{Per}, $hr{Lck}, $hr{Rep}, $hr{Health}, $hr{Magicka}, $hr{Fatigue},
				$hr{Disposition}, $hr{Faction}, $hr{Rank}, $hr{Gold}) = unpack("SC8x[C27]CSSSCCCxL", $buff);
			       return(\%hr);
			   } else {
			       warn "BAD NPC_.NPDT length ($len) is not 12 or 52!\n";
			   }
		       },
		       sub {
			   my($hr) = @_;
			   if (exists $hr->{magicka}) {
			       return(pack("SC8C27CSSSCCCxL",
					   $hr->{level}, $hr->{str}, $hr->{int}, $hr->{wil}, $hr->{agi},
					   $hr->{spd}, $hr->{end}, $hr->{per}, $hr->{lck},
					   $hr->{"block"}, $hr->{"armorer"}, $hr->{"mediumarmor"}, $hr->{"heavyarmor"},
					   $hr->{"bluntweapon"}, $hr->{"longblade"}, $hr->{"axe"}, $hr->{"spear"},
					   $hr->{"athletics"}, $hr->{"enchant"}, $hr->{"destruction"}, $hr->{"alteration"},
					   $hr->{"illusion"}, $hr->{"conjuration"}, $hr->{"mysticism"}, $hr->{"restoration"},
					   $hr->{"alchemy"}, $hr->{"unarmored"}, $hr->{"security"}, $hr->{"sneak"},
					   $hr->{"acrobatics"}, $hr->{"lightarmor"}, $hr->{"shortblade"}, $hr->{"marksman"},
					   $hr->{"mercantile"}, $hr->{"speechcraft"}, $hr->{"handtohand"},
					   $hr->{rep}, $hr->{health}, $hr->{magicka}, $hr->{fatigue},
					   $hr->{disposition}, $hr->{faction}, $hr->{rank}, $hr->{gold}));
			   } else {
			       return(pack("SC6L", $hr->{level}, $hr->{disposition}, $hr->{faction}, $hr->{rank},
					   $hr->{unk1}, $hr->{unk2}, $hr->{unk3},  $hr->{gold}));
			   }
		       }],
	      RNAM => $RD_Unknown,
	      SCRI => [["Script", "a*"]],
	     ],
     PCDT => [
	      AADT => $RD_Unknown,
	      ANIS => $RD_Unknown,
	      BNAM => $RD_Unknown,
	      CNAM => $RD_Unknown,
	      DNAM => $RD_Unknown,
	      ENAM => $RD_Unknown,
	      FNAM => [["Name", "a*"]],
	      KNAM => $RD_Unknown,
	      LNAM => $RD_Unknown,
	      MNAM => $RD_Unknown,
	      NAM0 => $RD_Unknown,
	      NAM1 => $RD_Unknown,
	      NAM2 => $RD_Unknown,
	      NAM3 => $RD_Unknown,
	      NAM9 => $RD_Unknown,
	      PNAM => $RD_Unknown,
	      SNAM => $RD_Unknown,
	     ],
     PGRD => [
	      NAME => [["ID", "a*"]],
	      DATA => $RD_Unknown,
	      PGRC => $RD_Unknown,
	      PGRP => $RD_Unknown,
	     ],
     PROB => [
	      NAME => [["ID", "a*"]],
	      FNAM => [["Name", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      PBDT => [["Weight", "f"], ["Value", "L"], ["Quality", "f"], ["Uses", "L"]],
	     ],
     QUES => [
	      NAME => [["ID", "a*"]],
	      DATA => [["Info_ID", "Z*"]], # {ess => 1}
	     ],
     RACE => [
	      NAME => [["ID", "a*"]],
	      DESC => [["Description", "a*"]],
	      FNAM => [["Name", "a*"]],
	      NPCS => [["Spell", ["Z32", "a32"]]],
	      RADT => [[[("Skill_1", "Bonus_1") x 7], "(L2)7"], [[("Attr_Male_1", "Attr_Female_1") x 8], "(L2)8"],
		       ["Male_Height", "f"], ["Female_Height", "f"], ["Male_Weight", "f"], ["Female_Weight", "f"], ["Flags", "L"]],
	     ],
     REFR => [
	      NAME => [["ID", "a*"]],
	      AADT => $RD_Unknown,
	      ACDT => $RD_Actor_Data,
	      ACSC => $RD_Unknown,
	      ACSL => $RD_Unknown,
	      ACTN => [["Unknown_1", "L"]], # Actor Number???
	      CHRD => $RD_Unknown,
	      CSHN => $RD_Unknown,
	      CSTN => $RD_Unknown,
	      DATA => $RD_Unknown,
	      FGTN => [["Uknown_1", "a*"]], # Following Target Name???
	      FRMR => [["Form_Ref", "L"]],
	      ND3D => [["Unknown_1", "C"]],
	      STPR => $RD_Unknown,
	      TGTN => [["Target", "a*"]],
	      WNAM => [["Readied_Spell", "Z*"]],
	      XSCL => [["Scale", "f"]],
	     ],
     REGN => [
	      NAME => [["ID", "a*"]],
	      BNAM => [["Sleep_Creature_ID", "a*"]],
	      CNAM => [["Red", "C"], ["Green", "C"], ["Blue", "C"], ["Unused", "C"]],
	      FNAM => [["Name", "a*"]],
	      SNAM => [["Sound_Name", ["Z32", "a32"]], ["Chance", "C"]],
	      WEAT => [["Clear", "C"], ["Cloudy", "C"], ["Foggy", "C"], ["Overcast", "C"],
		       ["Rain", "C"], ["Thunder", "C"], ["Ash", "C"], ["Blight", "C"],
		       ["Snow", "C"], ["Blizzard", "C"]],	 # Bloodmoon
	      WNAM => [["Name", "L"]],
	     ],
     REPA => [
	      NAME => [["ID", "a*"]],
	      FNAM => [["Name", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      RIDT => [["Weight", "f"], ["Value", "L"], ["Uses", "L"], ["Quality", "f"]],
	      SCRI => [["Script", "a*"]],
	     ],
     SCPT => [
	      RNAM => [["Unknown_1", "L"]],
	      SCDT => [["Bytecode", "H*"]],
	      SCHD => [["ID", ["Z32", "a32"]], ["Num_Shorts", "L"], ["Num_Longs", "L"], ["Num_Floats", "L"],
		       ["Data_Size", "L"], ["Local_Var_Size", "L"]],
	      SCTX => [["Script_Text", "a*"]],
	      SCVR => [["Variables", "a*"]],
	      SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]],
	      SLFD => [\&unpack_float_array, \&pack_float_array],
	      SLLD => [\&unpack_long_array,  \&pack_long_array],
	      SLSD => [\&unpack_short_array, \&pack_short_array],
	     ],
     SKIL => [
	      INDX => [["ID", "L"]],
	      DESC => [["Description", "a*"]],
	      SKDT => [["Attribute", "L"], ["Specialization", "L"], [[("Use_Values_1") x 4], "f4"]],
	     ],
     SNDG => [
	      NAME => [["ID", "a*"]],
	      CNAM => [["Creature_ID", "a*"]],
	      DATA => [["Data", "L"]],
	      SNAM => [["Sound_ID", "a*"]],
	     ],
     SOUN => [
	      NAME => [["ID", "a*"]],
	      DATA => [["Volume", "C"], ["MinRange", "C"], ["MaxRange", "C"]],
	      FNAM => [["Name", "a*"]],
	     ],
     SPEL => [
	      NAME => [["ID", "a*"]],
	      ENAM => $RD_Enchantment,
	      FNAM => [["Name", "a*"]],
	      SPDT => [["Type", "L"], ["Cost", "L"], ["Flags", "L"]],
	     ],
     SPLM => [
	      CNAM => [["Unknown_1", "L"], ["Unknown_1", "Z*"]],
	      NAM0 => [["Unknown_1", "L"]],
	      NAME => [["Name", "L"]],
	      NPDT => [["Name", ["Z40", "a40"]], ["Magnitude", "l"], ["Seconds_Active", "f"], [[("Long_1") x 2], "l2"]],
	      SPDT => [["Type", "L"], ["Name", ["Z40", "a40"]], [[("Long_1") x 2], "L2"],
		       ["Caster", ["Z32", "a32"]], ["Item", "Z*"]],
	      TNAM => [["Target", "Z*"]],
	      VNAM => [["Unknown_1", "L"]],
	      XNAM => [["Unknown_1", "L"]],
	     ],
     SSCR => [
	      NAME => [["ID", "a*"]],
	      DATA => [["Name", "a*"]],
	     ],
     STAT => [
	      NAME => [["ID", "a*"]],
	      MODL => [["Model", "a*"]],
	     ],
     STLN => [
	      NAME => [["ID", "a*"]],
	      FNAM => [["Name", "a*"]],
	      ONAM => [["Name", "Z*"]],
	     ],
     TES3 => [
	      DATA => [sub { my($l1, $l2) = unpack("L2", $_[0]); { Length => $l1 + ($l2 << 32) }; },
		       sub { my $len = $_[0]->{Length}; my $l1 = $len & 0xffffffff; my $l2 = $len >> 32; pack("L2", $l1, $l2); }],
	      GMDT => [["Unknown_1", "H23"], ["Current_Cell", ["Z67", "a67"]], ["Unknown_1", "L"], ["Unknown_1", "H30"]],
	      HEDR => [["Version", "f"], ["Is_Master", "L"], ["Author", ["Z32", "a32"]],
		       ["Description", ["Z256", "a256"]], ["NRecords", "L"]],
	      MAST => [["Master", "Z*"]],
	      SCRD => [[[("Long_1") x 5], "L5"]],
	      SCRS => [["Screenshot", "H*"]],
	     ],
     VFXM => [
	      VNAM => [[[("Long_1") x 6], "(a4)6"], ["Short", "S"], ["Unknown_1", "a22"],
		       ["Name_1", ["Z36", "a36"]], ["Name_1", ["Z68", "a68"]]],
	     ],
     WEAP => [
	      NAME => [["ID", "a*"]],
	      ENAM => [["Enchantment", "a*"]],
	      FNAM => [["Name", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      SCRI => [["Script", "a*"]],
	      WPDT => [["Weight", "f"], ["Value", "L"], ["Type", "S"], ["Health", "S"], ["Speed", "f"],
		       ["Reach", "f"], ["Enchant_Points", "S"], ["Chop_Min", "C"], ["Chop_Max", "C"],
		       ["Slash_Min", "C"], ["Slash_Max", "C"], ["Thrust_Min", "C"], ["Thrust_Max", "C"],
		       ["Flags", "L"]],
	     ],
     };

# All record sub-types found in .esm/.esp/.ess
my @SUBRECTYPES =
    qw(AADT ACDT ACSC ACSL ACTN AIDT AI_E AI_F AI_T AI_W ALDT AMBI ANAM ANIS
       AODT APUD ASND AVFX BKDT BNAM BSND BVFX BYDT CHRD CLDT CNAM CNDT CRED
       CSHN CSND CSTN CTDT CVFX DATA DELE DESC DNAM DODT ENAM ENDT FADT FGTN
       FLAG FLTV FNAM FRMR GMDT HEDR HSND HVFX INAM INDX INTV IRDT ITEX KNAM
       LHDT LKDT LNAM LSHN LSTN LVCR MAPD MAPH MAST MCDT MEDT MNAM MODL MVRF
       NAM0 NAM1 NAM2 NAM3 NAM5 NAM8 NAM9 NAME ND3D NNAM NPCO NPCS NPDT ONAM
       PBDT PGRC PGRP PNAM PTEX QSTF QSTN QSTR RADT RGNN RIDT RNAM SCDT SCHD
       SCRD SCRI SCRS SCTX SCVR SKDT SLCS SLFD SLLD SLSD SNAM SPDT STPR STRV
       TEXT TGTN TNAM UNAM VCLR VHGT VNAM VNML VTEX WEAT WHGT WIDX WNAM WPDT
       XCHG XHLT XIDX XNAM XSCL XSOL YNAM ZNAM);

my %JUNKCELL_SUBTYPE = (NAME => 1, DATA => 1, RGNN => 1);

sub indent_result {
    my($str) = @_;
    $str =~ tr/\r//d;
    $str =~ s/\n/\n\t\t/g;
    return("\t\t$str");
}

sub dbg_word {
    my($longstr) = @_;
    my $len = length($longstr);
    if ($len != 4) {
	warn "dbg_word: expected length of 4, got $len\n";
	return;
    }
    sprintf(qq{[UNKNOWN_WORD: 0x%s (f:%0.2f) (L:%d) (S:%d S:%d) (C:%d C:%d C:%d C:%d)]},
	unpack("H*", $longstr), unpack("f", $longstr), unpack("L", $longstr), unpack("S2", $longstr), unpack("C4", $longstr));
}

sub decode_flags {
    my($flags, $flagdefs) = @_;
    my @list = ();
    while (my($name, $val) = each %$flagdefs) {
	next if (length($name) == 1);
	if ($flags & $val) {
	    $name =~ s/([[:alnum:]]+)/ucfirst($1)/ge;
	    push(@list, $name);
	}
    }
    my $flagstr = sprintf "0x%04x", $flags;
    return("$flagstr (" . join(", ", @list) . ")");
}

sub print_lookup {
    my($key, $hashref) = @_;
    return($hashref->{$key} || $key . "???");
}

###CODECS

my $DECODER_UNKNOWN = sub { return({ unknown => unpack("H*", $_[0])}, {}); };
my $ENCODER_UNKNOWN = sub { return(pack("H*", $_[0]->{unknown})); };
my %DECODE = ();
my %ENCODE = ();
my %RD = ();

sub flatten {
    my @newlist;
    push(@newlist, (ref eq 'ARRAY') ? flatten(@$_) : $_) foreach (@_);
    return(@newlist);
}

sub compile_def {
    my($purpose, @def) = @_;
    my $format = "";
    my @keys;
    my %key_n;
    my %idx;
    my $index = 0;
    foreach my $ref (@def) {
	my($key, $fmt) = @$ref;
	if (ref($fmt) eq 'ARRAY') {
	    $format .= ($purpose eq 'decode') ? $fmt->[0] : $fmt->[1];
	} else {
	    $format .= $fmt;
	}
	foreach my $key (map { lc } flatten($key)) {
	    while (exists $idx{$key}) {
		$key =~ s/_\d+$//;
		$key .= '_' . $key_n{$key}++;
	    }
	    push(@keys, $key);
	    $idx{$key} = $index++;
	}
    }
    return($format, scalar(@keys), \@keys, \%idx);
}
sub default_decoder {
    my($type, @def) = @_;
    my($cdef, $nkeys, $keys) = compile_def('decode', @def);
    $RD{$type} = $cdef; # for transitional code
    my $decoder = sub {
	my($buff) = @_;
	my %hr;
	my @vals = unpack($cdef, $buff);
	my $nvals = scalar(@vals);
	die "Error in codec: nvals($nvals) != nkeys($nkeys)\n"
	    if ($nvals > $nkeys);
	foreach my $key (@$keys) {
	    my $val = shift(@vals);
	    $hr{$key} = $val;
	    last unless (@vals);
	}
	return(\%hr);
    };
    return($decoder);
};
sub default_encoder {
    my(@def) = @_;
    my($cdef, $nkeys, $keys, $idx) = compile_def('encode', @def);
    my $encoder = sub {
	my($hr) = @_;
	my @rec = ();
	while (my($key, $val) = each %$hr) {
	    $rec[$idx->{lc($key)}] = $val;
	}
	return(pack($cdef, @rec));
    };
    return($encoder);
};
sub default_codec {
    my($type, @def) = @_;
    $DECODE{$type} = default_decoder($type, @def);
    $ENCODE{$type} = default_encoder(@def);
}
default_codec('TES3.HEDR', (["Version", "f"],
			    ["Is_Master", "L"],
			    ["Author", ["Z32", "a32"]],
			    ["Description", ["Z256", "a256"]],
			    ["NRecords", "L"]));
default_codec('TES3.MAST', (["Master", "Z*"]));

# custom codec for TES3.DATA
$RD{'TES3.DATA'} = "L2";
$DECODE{'TES3.DATA'} = sub {
    my($buff) = @_;
    my($l1, $l2) = unpack("L2", $buff);
    return({ length => $l1 + ($l2 << 32) });
};
$ENCODE{'TES3.DATA'} = sub {
    my($hr) = @_;
    my $len = $hr->{length};
    my $l1 = $len & 0xffffffff;
    my $l2 = $len >> 32;
    return(pack("L2", $l1, $l2));
};

default_codec('ALCH.ALDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Autocalc", "L"]));
default_codec('APPA.AADT', (["Type", "L"],
			    ["Quality", "f"],
			    ["Weight", "f"],
			    ["Value", "L"]));
default_codec('ARMO.AODT', (["Type", "L"],
			    ["Weight", "f"],
			    ["Value", "L"],
			    ["Health", "L"],
			    ["Enchant_Points", "L"],
			    ["Armor_Rating", "L"]));
default_codec('ARMO.INDX', (["Index", "C"]));
default_codec('BODY.BYDT', (["Body_Part", "C"],
			    ["Vampire", "C"],
			    ["Flags", "C"],
			    ["Part_Type", "C"]));
default_codec('BOOK.BKDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Scroll", "L"],
			    ["Skill", "L"],
			    ["Enchant_Points", "L"]));
default_codec('CELL.AMBI', (["Ambient_Color", "L"],
			    ["Sunlight_Color", "L"],
			    ["Fog_Color", "L"],
			    ["Fog_Density", "f"]));
default_codec('CELL.CSTN', (["Target", "Z*"])); # guessing this is: "Cast/Current Spell Target Name"

# custom codec for CELL_DATA
$DECODE{'CELL.DATA'} = sub {
    my($buff) = @_;
    my $dlen = length($buff);
    if ($dlen == 24) {
	my($x, $y, $z, $xrot, $yrot, $zrot) = unpack("f6", $buff);
	return({ x => $x, y => $y, z => $z,
		 x_angle => $xrot, y_angle => $yrot, z_angle => $zrot });
    } elsif ($dlen == 12) {
	my($flags, $unk, $fog) = unpack("LLf", $buff);
	if ($flags & 0x01) { 	# Interior
	    return({ flags => $flags, unknown => $unk, fog_density => $fog });
	} else {		# Exterior
	    my($x, $y) = unpack("x[L]ll", $buff);
	    return({ flags => $flags, x => $x, y => $y });
	}
    } else {
	die "DECODER ERROR on CELL.DATA, Invalid length: $dlen\n";
    }
};
$ENCODE{'CELL.DATA'} = sub {
    my($hr) = @_;
    if (exists $hr->{flags}) {
	if ($hr->{Flags} & 0x01) { # Interior
	    return(pack("LLf", $hr->{flags}, $hr->{unknown}, $hr->{fog_density}));
	} else {		     # Exterior
	    return(pack("Lll", $hr->{flags}, $hr->{x}, $hr->{y}));
	}
    } else {
	return(pack("f6", $hr->{x}, $hr->{y}, $hr->{z},
		    $hr->{x_angle}, $hr->{y_angle}, $hr->{z_angle}));
    }
};

default_codec('CELL.FRMR', (["ObjIdx", "S"],
			    ["Unknown_1", "C"],
			    ["ModIdx", "C"]));
default_codec('CELL.NAM5', (["R", "C"], # Map Color
			    ["G", "C"],
			    ["B", "C"],
			    ["Unused", "C"]));
default_codec('CELL.NAM9', (["Owner", "L"]));
default_codec('CLAS.CLDT', (["Primary_Attribute", "L"],
			    ["Secondary_Attribute", "L"],
			    ["Specialization", "L"],
			    [[("Minor_Skill_1", "Major_Skill_1") x 5], "(L2)5"],
			    ["Flags", "L"],
			    ["AutoCalc", "L"]));
default_codec('CLOT.CTDT', (["Type", "L"],
			    ["Weight", "f"],
			    ["Value", "S"],
			    ["Enchant_Points", "S"]));
default_codec('CLOT.INDX', (["Index", "C"]));
default_codec('CONT.CNDT', (["Weight", "f"]));
default_codec('CONT.FLAG', (["Container_Flags", "L"]));
default_codec('CREA.AI_W', (["Distance", "S"],
			    ["Duration", "C"],
			    ["Time_of_day", "C"],
			    [[("Idle_1") x 10], "C10"]));
#default_codec('CREA.AIDT', ([[("AI_1") x 12], "C12"]));
default_codec('CREA.AIDT', (["Hello", "C"],
			    ["Unknown_1", "C"],
			    ["Fight", "C"],
			    ["Flee", "C"],
			    ["Alarm", "C"],
			    ["Unknown_1", "a3"],
			    ["Flags", "L"]));
default_codec('CREA.FLAG', (["Flags", "L"]));
default_codec('CREA.NPDT', (["Type", "L"],
			    ["Lev", "L"],
			    ["Str", "L"],
			    ["Int", "L"],
			    ["Wil", "L"],
			    ["Agi", "L"],
			    ["Spd", "L"],
			    ["End", "L"],
			    ["Per", "L"],
			    ["Lck", "L"],
			    ["Health", "L"],
			    ["Spell_Points", "L"],
			    ["Fatigue", "L"],
			    ["Soul", "L"],
			    ["Combat", "L"],
			    ["Magic", "L"],
			    ["Stealth", "L"],
			    ["Attack_1_Min", "L"],
			    ["Attack_1_Max", "L"],
			    ["Attack_2_Min", "L"],
			    ["Attack_2_Max", "L"],
			    ["Attack_3_Min", "L"],
			    ["Attack_3_Max", "L"],
			    ["Gold", "L"]));
default_codec('DIAL.DATA', (["Type", "C"],
			   # ["Unused", "a3"]
			   ));
default_codec('ENCH.ENDT', (["Type", "L"],
			    ["Cost", "L"],
			    ["Charge", "L"],
			    ["Autocalc", "L"]));
default_codec('ENCH.ENAM', (["Spell_Effect", "S"],
			    ["Skill", "C"],
			    ["Attribute", "C"],
			    ["Range", "L"],
			    ["Area", "L"],
			    ["Duration", "L"],
			    ["MagMin", "L"],
			    ["MagMax", "L"]));
default_codec('FACT.FADT', (["Primary_Attribute", "L"],
			    ["Secondary_Attribute", "L"],
			    [[("At1_1", "At2_1", "Sk1_1", "Sk2_1", "Fact_1") x 10], "(L5)10"],
			    [[("Sk_1") x 6], "L6"],
			    ["Unknown_1", "L"],
			    ["Flags", "L"]));
default_codec('GLOB.FNAM', (["VarType", "a"]));
default_codec('GMST.NAME', (["Name", "a*"]));
default_codec('INFO.ACDT', (["Actor_Data", "Z*"])); # (only in .ess)
default_codec('INFO.INAM', (["Name", "Z*"]));
default_codec('INFO.DATA', (["Unknown_1", "L"],
			    ["Disposition", "L"],
			    ["Rank", "C"],
			    ["Sex", "C"],
			    ["PCRank", "C"],
			    ["Unknown_1", "C"]));
default_codec('INFO.ANAM', (["Cell", "Z*"]));
default_codec('INFO.BNAM', (["Result", "a*"]));
default_codec('INFO.CNAM', (["Class", "Z*"]));
default_codec('INFO.DNAM', (["PC_Faction", "Z*"]));
default_codec('INFO.FNAM', (["Faction", "Z*"]));
default_codec('INFO.NAME', (["Response", "a*"]));
default_codec('INFO.NNAM', (["Next_ID", "Z*"]));
default_codec('INFO.ONAM', (["Actor", "Z*"]));
default_codec('INFO.PNAM', (["Prev_ID", "Z*"]));
default_codec('INFO.RNAM', (["Race", "Z*"]));
default_codec('INFO.QSTN', (["Quest_Name", "C"]));
default_codec('INFO.QSTF', (["Quest_Finished", "C"]));
default_codec('INFO.QSTR', (["Quest_Restart", "C"]));
default_codec('INFO.SCVR', (["Index", "a"],
			    ["Type", "a"],
			    ["Function", "a2"],
			    ["Comparison", "a"],
			    ["Name", "a*"]));
default_codec('INGR.IRDT', (["Weight", "f"],
			    ["Value", "L"],
			    [[("Effect_1") x 4], "l4"],
			    [[("Skill_1") x 4], "l4"],
			    [[("Attribute_1") x 4], "l4"]));
default_codec('LAND.INTV', (["X", "l"],
			    ["Y", "l"]));
default_codec('LEVC.DATA', (["List_Data", "L"]));
default_codec('LEVC.INTV', (["Level", "S"]));
default_codec('LEVC.NNAM', (["Chance_None", "C"]));
default_codec('LEVI.DATA', (["List_Data", "L"]));
default_codec('LEVI.INTV', (["Level", "S"]));
default_codec('LEVI.INAM', (["Name", "Z*"]));
default_codec('LEVI.NNAM', (["Chance_None", "C"]));
default_codec('LIGH.LHDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Time", "L"],
			    ["Radius", "L"],
			    ["Red", "C"],
			    ["Green", "C"],
			    ["Blue", "C"],
			    ["Unknown_1", "C"],
			    ["Flags", "L"]));
default_codec('LOCK.LKDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Quality", "f"],
			    ["Uses", "L"]));
default_codec('LTEX.DATA', (["Data", "Z*"]));
default_codec('MGEF.MEDT', (["School", "L"],
			    ["Base_Cost", "f"],
			    ["Flags", "L"],
			    ["Red", "L"],
			    ["Green", "L"],
			    ["Blue", "L"],
			    ["Speed", "f"],
			    ["Size", "f"],
			    ["SizeCap", "f"]));
default_codec('MISC.MCDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Unknown_1", "L"]));
default_codec('NPC_.CNDT', (["Data", "Z*"]));
default_codec('NPC_.FLAG', (["Flags", "L"]));
default_codec('NPC_.AIDT', (["Hello", "C"],
			    ["Unknown_1", "C"],
			    ["Fight", "C"],
			    ["Flee", "C"],
			    ["Alarm", "C"],
			    ["Unknown_1", "a3"],
			    ["Flags", "L"]));
default_codec('NPC_.AI_W', (["Distance", "S"],
			    ["Duration", "S"],
			    ["Time_of_day", "C"],
			    [[("Idle_1") x 8], "C8"],
			    ["Unknown_1", "C"]));

$DECODE{'NPC_.NPDT'} = sub {
    my($buff) = @_;
    my %hr;
    my $len = length($buff);
    if ($len == 12) {
	my($lev, $disp, $fact, $rank, $unk1, $unk2, $unk3, $gold) = unpack("SC6L", $_[0]);
	return({ level => $lev, disposition => $disp, faction => $fact, rank => $rank, unk1 => $unk1, unk2 => $unk2, unk3 => $unk3, gold => $gold });
    } elsif ($len == 52) {
	my $i = 0;
	my %hr;
	foreach my $skill_level (unpack("x[SC8]C27", $buff)) {
	    $hr{$SKILL{$i++}} = $skill_level;
	}
	($hr{level}, $hr{str}, $hr{int}, $hr{wil}, $hr{agi}, $hr{spd}, $hr{end},
	 $hr{per}, $hr{lck}, $hr{rep}, $hr{health}, $hr{magicka}, $hr{fatigue},
	 $hr{disposition}, $hr{faction}, $hr{rank}, $hr{gold}) = unpack("SC8x[C27]CSSSCCCxL", $buff);
	return(\%hr);
    } else {
	warn "BAD NPC_.NPDT length ($len) is not 12 or 52!\n";
    }
};
$ENCODE{'NPC_.NPDT'} = sub {
    my($hr) = @_;
    if (exists $hr->{magicka}) {
	return(pack("SC8C27CSSSCCCxL",
		    $hr->{level}, $hr->{str}, $hr->{int}, $hr->{wil}, $hr->{agi},
		    $hr->{spd}, $hr->{end}, $hr->{per}, $hr->{lck},
		    $hr->{"block"}, $hr->{"armorer"}, $hr->{"mediumarmor"}, $hr->{"heavyarmor"},
		    $hr->{"bluntweapon"}, $hr->{"longblade"}, $hr->{"axe"}, $hr->{"spear"},
		    $hr->{"athletics"}, $hr->{"enchant"}, $hr->{"destruction"}, $hr->{"alteration"},
		    $hr->{"illusion"}, $hr->{"conjuration"}, $hr->{"mysticism"}, $hr->{"restoration"},
		    $hr->{"alchemy"}, $hr->{"unarmored"}, $hr->{"security"}, $hr->{"sneak"},
		    $hr->{"acrobatics"}, $hr->{"lightarmor"}, $hr->{"shortblade"}, $hr->{"marksman"},
		    $hr->{"mercantile"}, $hr->{"speechcraft"}, $hr->{"handtohand"},
		    $hr->{rep}, $hr->{health}, $hr->{magicka}, $hr->{fatigue},
		    $hr->{disposition}, $hr->{faction}, $hr->{rank}, $hr->{gold}));
    } else {
	return(pack("SC6L", $hr->{level}, $hr->{disposition}, $hr->{faction}, $hr->{rank}, $hr->{unk1}, $hr->{unk2}, $hr->{unk3},  $hr->{gold}));
    }
};

#     "PCDT.SNAM" => $TOSTR_UNKNOWN, # .ess
#     "PCDT.ENAM" => $TOSTR_UNKNOWN, # .ess
#     "PCDT.FNAM" => $TOSTR_UNKNOWN, # .ess

default_codec('PROB.PBDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Quality", "f"],
			    ["Uses", "L"]));
default_codec('QUES.DATA', (["Info_ID", "Z*"])); # only in .ess (relates back to Actor in INFO)
default_codec('RACE.RADT', ([[("Skill_1", "Bonus_1") x 7], "(L2)7"],
			    [[("Attr_Male_1", "Attr_Female_1") x 8], "(L2)8"],
			    ["Male_Height", "f"],
			    ["Female_Height", "f"],
			    ["Male_Weight", "f"],
			    ["Female_Weight", "f"],
			    ["Flags", "L"]));
# REFR.ACDT (player Actor Data)
##(Not present???: Burden, Detect Animal, Detect Ench., Light, Night Eye, Slowfall, Telekinesis)
#----------------------------------------------------------- Offset
default_codec('REFR.ACDT', ([[("Unknown_1") x 10], "L10"],   #   0
			    ["Health", "f"],		     #  40
			    ["Max_Health", "f"],	     #  44
			    ["Fatigue", "f"],		     #  48
			    ["Max_Fatigue", "f"],	     #  52
			    ["Unknown_1", "f"],		     #  56
			    ["Unknown_1", "f"],		     #  60
			    ["Unknown_1", "f"],		     #  64
			    ["Unknown_1", "f"],		     #  68
			    ["Unknown_1", "f"],		     #  72
			    ["Encumbrance", "f"],	     #  76
			    ["STR", "f"],		     #  80
			    ["STR_Base", "f"],		     #  84
			    ["INT", "f"],		     #  88
			    ["INT_Base", "f"],		     #  92
			    ["WIL", "f"],		     #  96
			    ["WIL_Base", "f"],		     # 100
			    ["AGI", "f"],		     # 104
			    ["AGI_Base", "f"],		     # 108
			    ["SPD", "f"],		     # 112
			    ["SPD_Base", "f"],		     # 116
			    ["END", "f"],		     # 120
			    ["END_Base", "f"],		     # 124
			    ["PER", "f"],		     # 128
			    ["PER_Base", "f"],		     # 132
			    ["LUC", "f"],		     # 136
			    ["LUC_Base", "f"],		     # 140
			    ["Fortify_Attack", "L"],	     # 144
			    ["Sanctuary", "L"],		     # 148
			    ["Resist_Magicka", "C"],	     # 152
			    ["Unknown_1", "a3"],
			    ["Resist_Fire", "C"],            # 156 (+ Fire Shield)
			    ["Unknown_1", "a3"],
			    ["Resist_Frost", "C"],           # 160 (+ Frost Shield)
			    ["Unknown_1", "a3"],
			    ["Resist_Shock", "C"],	     # 164 (+ Lightning Shield)
			    ["Unknown_1", "a3"],
			    ["Resist_Common_Disease", "L"],  # 168
			    ["Unknown_1", "L"],		     # 172
			    ["Unknown_1", "L"],		     # 176
			    ["Resist_Poison", "L"],	     # 180
			    ["Resist_Paralysis", "L"],	     # 184
			    ["Chameleon", "L"],		     # 188
			    ["Resist_Normal_Weapons", "L"],  # 192
			    ["Water_Breathing", "L"],	     # 196
			    ["Water_Walking", "L"],	     # 200
			    ["Swift_Swim", "L"],	     # 204
			    ["Unknown_1", "L"],		     # 208
			    ["Levitate", "L"],		     # 212
			    ["Shield", "L"],		     # 216
			    ["Unknown_1", "L"],		     # 220
			    ["Unknown_1", "L"],		     # 224
			    ["Blind", "L"],		     # 228
			    ["Unknown_1", "L"],		     # 232
			    ["Invisibility", "L"],	     # 236
			    ["unknown", "L"],		     # 240
			    ["Unknown_1", "L"],		     # 244
			    ["Unknown_1", "L"],		     # 248
			    ["Unknown_1", "L"],		     # 252
			    ["Unknown_1", "L"],		     # 256
			    ["Unknown_1", "L"]));	     # 260
default_codec("REFR.WNAM", (["Readied_Spell", "Z*"]));
default_codec('REGN.WEAT', (["Clear", "C"],
			    ["Cloudy", "C"],
			    ["Foggy", "C"],
			    ["Overcast", "C"],
			    ["Rain", "C"],
			    ["Thunder", "C"],
			    ["Ash", "C"],
			    ["Blight", "C"],
			    ["Snow", "C"], # Bloodmoon
			    ["blizzard", "C"])); # Bloodmoon
default_codec('REGN.CNAM', (["Red", "C"],
			    ["Green", "C"],
			    ["Blue", "C"],
			    ["Unused", "C"]));
default_codec('REGN.SNAM', (["Sound_Name", ["Z32", "a32"]],
			    ["Chance", "C"]));
default_codec('REGN.WNAM', (["Name", "L"]));
default_codec('REPA.RIDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Uses", "L"],
			    ["Quality", "f"]));
default_codec('SCPT.RNAM', (["Unknown_1", "L"]));
default_codec('SCPT.SCDT', (["Bytecode", "H*"]));
default_codec('SCPT.SCHD', (["Name", ["Z32", "a32"]],
			    ["Num_Shorts", "L"],
			    ["Num_Longs", "L"],
			    ["Num_Floats", "L"],
			    ["Data_Size", "L"],
			    ["Local_Var_Size", "L"]));
default_codec('SCPT.SCVR', (["Variables", "a*"]));
default_codec('SCPT.SCTX', (["Script", "a*"]));
default_codec('SKIL.SKDT', (["Attribute", "L"],
			    ["Specialization", "L"],
			    [[("Use_Values_1") x 4], "f4"]));
default_codec('SNDG.DATA', (["Data", "L"]));
default_codec('SPEL.SPDT', (["Type", "L"],
			    ["Cost", "L"],
			    ["Flags", "L"]));
default_codec('SPLM.NAME', (["Name", "L"]));
default_codec('SPLM.SPDT', (["Type", "L"],
			    ["Name", ["Z40", "a40"]],
			    [[("Long_1") x 2], "L2"],
			    ["Caster", ["Z32", "a32"]],
			    ["Item", "Z*"]));
default_codec('SPLM.NPDT', (["Name", ["Z40", "a40"]],
			    ["Magnitude", "l"],
			    ["Seconds_Active", "f"],
			    [[("Long_1") x 2], "l2"]));
default_codec('SPLM.XNAM', (["Name", "L"]));
default_codec('SPLM.TNAM', (["Target", "Z*"]));
default_codec('SOUN.DATA', (["Volume", "C"],
			    ["MinRange", "C"],
			    ["MaxRange", "C"]));
default_codec('SSCR.DATA', (["Name", "a*"]));
default_codec('STLN.ONAM', (["Name", "Z*"]));
default_codec('WEAP.WPDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Type", "S"],
			    ["Health", "S"],
			    ["Speed", "f"],
			    ["Reach", "f"],
			    ["Enchant_Points", "S"],
			    ["Chop_Min", "C"],
			    ["Chop_Max", "C"],
			    ["Slash_Min", "C"],
			    ["Slash_Max", "C"],
			    ["Thrust_Min", "C"],
			    ["Thrust_Max", "C"],
			    ["Flags", "L"]));
default_codec('VFXM.VNAM', ([[("Long_1") x 6], "(a4)6"],
			    ["Short", "S"],
			    ["Unknown_1", "a22"],
			    ["Name_2", ["Z36", "a36"]],
			    ["Name_3", ["Z68", "a68"]]));
default_codec('DELE', (["Unknown_1", "L"]));
default_codec('DODT', (["X", "f"],
		       ["Y", "f"],
		       ["Z", "f"],
		       ["Angle_X", "f"],
		       ["Angle_Y", "f"],
		       ["Angle_Z", "f"]));
default_codec('FLAG', (["Flags", "L"]));
default_codec('NPCO', (["Count", "l"],
		       ["Name", ["Z32", "a32"]]));
default_codec('NPCS', (["String", ["Z32", "a32"]]));
default_codec('XCHG', (["Enchant_Charge", "L"]));
default_codec('XHLT', (["Health", "L"]));
default_codec('XSCL', (["Scale", "f"]));
default_codec('XSOL', (["Soul", "Z*"]));
default_codec('WIDX', (["Equipped_Index", "l"],
		       ["Ammo_Flag", "l"]));
default_codec('SLCS', (["Shorts", "L"],
		       ["Longs", "L"],
		       ["Floats", "L"]));

$DECODE{'SLSD'} = \&unpack_short_array;
$ENCODE{'SLSD'} = \&pack_short_array;
$DECODE{'SLLD'} = \&unpack_long_array;
$ENCODE{'SLLD'} = \&pack_long_array;
$DECODE{'SLFD'} = \&unpack_float_array;
$ENCODE{'SLFD'} = \&pack_float_array;

$DECODE{"SPEL.ENAM"} = $DECODE{"ENCH.ENAM"};
$ENCODE{"SPEL.ENAM"} = $ENCODE{"ENCH.ENAM"};

# subrecords that decode as signed 32-bit longs:
foreach (qw(INTV)) {
    $DECODE{$_} = sub{ { long => unpack("l", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("l", $_[0]->{long} );
    };
}

# subrecords that decode as unsigned 32-bit longs:
foreach (qw(INDX NAM0 XIDX)) {
    $DECODE{$_} = sub{ { long => unpack("L", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("L", $_[0]->{long} ); };
}

# subrecords that decode as 32-bit floats:
foreach (qw(FLTV WHGT)) {
    $DECODE{$_} = sub{ { float => unpack("f", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("f", $_[0]->{float} ); };
}

# subrecords that decode as variable length strings:
foreach (qw(ANAM ASND AVFX BNAM BSND BVFX CNAM CSND CVFX DESC DNAM ENAM FGTN FNAM
HSND HVFX ITEX KNAM LSHN LSTN MNAM MODL NAME PTEX RGNN RNAM SCIP SCPT SCRI SNAM STRV
TEXT TGTN TNAM WNAM)) {
    $DECODE{$_} = sub{ { string => unpack("Z*", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("a*", $_[0]->{string} ); };
}

###PRETTY PRINTER

my $TOSTR_UNK =
    sub { my $buff = $_[0];
	  sprintf qq{len:%d  hex:%s  str:"%s"}, length($buff),
	      unpack("H*", $buff), substr((($_ = $buff) =~ tr/\000-\037\177-\377//d, $_), 0, 60) };
my $TOSTR_DEBUG = sub { sprintf qq{DEBUG %s}, $TOSTR_UNK->($_[0]); };

my $DIALTYPE = "None";
my $NREC;
my %TOSTR =
    ("TES3.HEDR" => sub { my($ver, $is_master, $auth, $desc, $nrec) = unpack($RD{'TES3.HEDR'}, $_[0]);
			  $NREC = $nrec; # save it for later.
			  ($ver = sprintf("%0.2f", $ver)) =~ s/0+$//;
			  sprintf qq{\tVersion:$ver  Is_Master:%s\tAuthor:"$auth"\n\tDescription:"$desc"\n\tNRecords:$NREC},
			      ($is_master) ? "True" : "False"; },
     "TES3.MAST" => sub { unpack($RD{'TES3.MAST'}, $_[0]) },
     "TES3.DATA" => sub { my($l1, $l2) = unpack($RD{'TES3.DATA'}, $_[0]);
			  my $size = $l1 + ($l2 << 32);
			  "Length:     $size"; },
     "ALCH.ALDT" => sub { sprintf "Weight: %0.2f  Value: %d  Autocalc: %d", unpack($RD{'ALCH.ALDT'}, $_[0]) },
     "APPA.AADT" => sub { my($type, $qual, $wght, $val) = unpack($RD{'APPA.AADT'}, $_[0]);
			  sprintf "Type: %s  Quality: %0.2f  Weight: %0.2f  Value: %d",
			      $APPARATUS_TYPE{$type}, $qual, $wght, $val },
     "ARMO.AODT" => sub { my($type, $wght, $value, $health, $epts, $armor) = unpack($RD{'ARMO.AODT'}, $_[0]);
			  sprintf "Type: %s  Weight: %0.2f  Value: %d  Health %d  Enchant_Points: %d  ArmorRating: %d",
			      $ARMOR_TYPE{$type}, $wght, $value, $health, $epts, $armor},
     "ARMO.INDX" => sub { $ARMOR_INDEX{unpack($RD{'ARMO.INDX'}, $_[0])} },
     "BODY.BYDT" => sub { my($part, $vamp, $flags, $ptype) = unpack($RD{'BODY.BYDT'}, $_[0]);
			  sprintf "Bodypart: %s  Vampire: %d  Flag: %s  PartType: %s",
			      $BYDT_PART{$part}, $vamp, print_lookup($flags, \%BYDT_FLAGS), $BYDT_PTYP{$ptype}
		      },
     "BOOK.BKDT" => sub { my($wght, $val, $scrl, $skil, $epts) = unpack($RD{'BOOK.BKDT'}, $_[0]);
			  sprintf "Weight: %0.2f  Value: %d  Scroll: %s  Skill: %d  Enchant_Points: %d",
			      $wght, $val, (1 == $scrl) ? "Yes" : "No", $skil, $epts },
     "CELL.AMBI" => sub { sprintf("Ambient Color: 0x%08x  Sunlight Color: 0x%08x  Fog Color: 0x%08x  Fog Density: %0.2f",
				unpack($RD{'CELL.AMBI'}, $_[0])); },
     "CELL.CSTN" => sub { sprintf "Target: %s", unpack($RD{'CELL.CSTN'}, $_[0]); },
     "CELL.DATA" => sub {
	 if (length($_[0]) == 24) {
	     sprintf("Position x: %0.2f y: %0.2f z: %0.2f   Angle x: %0.2f y: %0.2f z: %0.2f", unpack("f6", $_[0]));
	 } else {
	     my($flags, $unkbuf, $fog_den_data) = unpack("La4f", $_[0]);
	     my @flags = ();
	     my $coord = '';
	     my $data_fog_str = '';
	     my $unk_str = '';
	     if ($flags & 0x01) {
		 push(@flags, "Interior");
		 $data_fog_str = sprintf "FogDensity: %0.2f ", $fog_den_data;
		 $unk_str = sprintf "Unk:0x%s ", unpack("H*", $unkbuf);
	     } else {
		 push(@flags, "Exterior");
		 my($x, $y) = unpack("x[L]ll", $_[0]);
		 $coord = "Coordinates: ($x, $y) ";
	     }
	     my $flags_str = "Flags: " . decode_flags($flags, \%CELL_FLAGS);
	     $coord . $data_fog_str . $unk_str . $flags_str;
	 }
     },
     "CELL.FRMR" => sub { sprintf "ObjIdx: %d Unk: %d ModIdx: %d", unpack($RD{'CELL.FRMR'}, $_[0]); },
     "CELL.NAM5" => sub { sprintf "Map_Color_RGB: (%x, %x, %x)", unpack($RD{'CELL.NAM5'}, $_[0]) },
     "CELL.NAM9" => sub { my $val = unpack($RD{'CELL.NAM9'}, $_[0]); (1 == $val) ? "Owner" : "Unk:$val"; },
     "CLAS.CLDT" => sub { my($attr1, $attr2, $spec, $min1, $maj1, $min2, $maj2, $min3, $maj3, $min4, $maj4, $min5, $maj5, $flags, $autoflags) =
			      unpack($RD{'CLAS.CLDT'}, $_[0]);
			  "  " . join("\n\t\t",
				      "Primary Attribute:   $ATTRIBUTE{$attr1}",
				      "Secondary Attribute: $ATTRIBUTE{$attr2}",
				      "Specialization: $SPECIALIZATION{$spec}",
				      "Major-Skill-1: $SKILL{$maj1}",
				      "Major-Skill-2: $SKILL{$maj2}",
				      "Major-Skill-3: $SKILL{$maj3}",
				      "Major-Skill-4: $SKILL{$maj4}",
				      "Major-Skill-5: $SKILL{$maj5}",
				      "Minor-Skill-1: $SKILL{$min1}",
				      "Minor-Skill-2: $SKILL{$min2}",
				      "Minor-Skill-3: $SKILL{$min3}",
				      "Minor-Skill-4: $SKILL{$min4}",
				      "Minor-Skill-5: $SKILL{$min5}",
				      "Flags: " . (($flags) ? "Playable" : "Non-playable"),
				      "AutoCalc Flags: " . decode_flags($autoflags, \%AUTOCALC_FLAGS));
		      },
     "CLOT.CTDT" => sub { my($type, $wght, $value, $epts) = unpack($RD{'CLOT.CTDT'}, $_[0]);
			  sprintf "Type: %s  Weight: %0.2f  Value: %d  Enchant_Points: %d",
			      $CTDT_TYPE{$type}, $wght, $value, $epts },
     "CLOT.INDX" => sub { unpack($RD{'CLOT.INDX'}, $_[0]) },
     "CONT.CNDT" => sub { sprintf "Weight: %0.2f", unpack($RD{'CONT.CNDT'}, $_[0]) },
     "CONT.FLAG" => sub { decode_flags(unpack($RD{'CONT.FLAG'}, $_[0]), \%CONTAINER_FLAGS) },
     "CREA.AI_W" => sub { my($hr) = $DECODE{'CREA.AI_W'}->($_[0]);
			  my $idle = join(", ", map { $hr->{"idle_$_"} } 1..10);
			  sprintf "Distance: %d  Duration: %d  Time_of_day: %d, Idles: $idle",
			      $hr->{distance}, $hr->{duration}, $hr->{time_of_day} },
#     "CREA.AIDT" => sub { join(", ", unpack($RD{'CREA.AIDT'}, $_[0])) },
     "CREA.AIDT" => sub { my($hello, $unk1, $fight, $flee, $alarm, $unk2, $unk3, $unk4, $flags) = unpack($RD{'NPC_.AIDT'}, $_[0]);
			  sprintf "Hello: %d  Fight: %d  Flee: %d  Alarm: %d  Flags: %s",
			      $hello, $fight, $flee, $alarm, decode_flags($flags, \%AIDT_FLAGS); },
     "CREA.FLAG" => sub { decode_flags(unpack($RD{'CREA.FLAG'}, $_[0]), \%CREATURE_FLAGS) },
     "CREA.NPDT" => sub { my($typ_i, $lev, $str, $int, $wil, $agi, $spd, $end, $per, $lck,
			     $hlth, $spelpts, $fat, $soul, $comb, $mag, $stlth,
			     $atkmin1, $atkmax1, $atkmin2, $atkmax2, $atkmin3, $atkmax3, $gold) = unpack($RD{'CREA.NPDT'}, $_[0]);
			  sprintf "Type: %s  Lev: %d  Str: %d  Int: %d  Wil: %d  Agi: %d  Spd: %d  End: %d  Per: %d  Lck: %d\n\t\tHealth: %d  Magicka: %d  Fatigue: %d  Soul: %d  Combat: %d  Magic: %d  Stealth: %d\n\t\tAttack-1 (%d, %d)  Attack-2: (%d, %d)  Attack-3 (%d, %d)  Gold: %d",
			      $CREA_TYPE[$typ_i], $lev, $str, $int, $wil, $agi, $spd, $end, $per, $lck,
				  $hlth, $spelpts, $fat, $soul, $comb, $mag, $stlth,
				      $atkmin1, $atkmax1, $atkmin2, $atkmax2, $atkmin3, $atkmax3, $gold;
		      },
     "DIAL.DATA" => sub { $DIALTYPE = $DIAL_TYPE{unpack($RD{'DIAL.DATA'}, $_[0])}; },
     "ENCH.ENDT" => sub { my($type, $cost, $chrg, $auto) = unpack($RD{'ENCH.ENDT'}, $_[0]);
		      sprintf "Type: %s  Cost: %d  Charge: %d  Autocalc: %d", $ENCHANT_TYPE{$type}, $cost, $chrg, $auto },
     "ENCH.ENAM" => sub { my($effect, $skill, $attr, $range, $area, $dur, $mmin, $mmax) = unpack($RD{'ENCH.ENAM'}, $_[0]);
			  my $spell = $SPELL_EFFECT{$effect};
			  if ($spell =~ /_attribute$/i) {
			      $spell .= "/$ATTRIBUTE{$attr}";
			  } elsif ($spell =~ /_skill$/i) {
			      $spell .= "/$SKILL{$skill}";
			  }
			  sprintf "%-28s  Range: %s  Area: %3d  Duration: %3d  MagMin: %4d  MagMax: %4d",
			      $spell, $RANGE_TYPE{$range}, $area, $dur, $mmin, $mmax },
     "FACT.FADT" => sub { my($attr1, $attr2, $rankdata, $skills, $unk, $flags) = unpack("LLa200a24LL", $_[0]);
			  my(@results) = sprintf "Attribute_1: %s  Attribute_2: %s  Unk:0x%x  Flags: %s",
			      $ATTRIBUTE{$attr1}, $ATTRIBUTE{$attr2}, $unk, decode_flags($flags, \%FACT_FLAGS);
			  push(@results, "\t\tFavored_Skills: " . join(", ", map { $SKILL{$_} } unpack("L6", $skills)));
			  foreach my $rd (unpack("(a20)10", $rankdata)) {
			      my($at1, $at2, $sk1, $sk2, $fact) = unpack("L5", $rd);
			      push(@results, sprintf "\t\tAttr_1: %3d  Attr_2: %3d  Skill_1: %3d  Skill_2: %3d  Fact: %3d",
				  $at1, $at2, $sk1, $sk2, $fact);
			  }
			  join("\n", @results);
		      },
     "INFO.ACDT" => sub { unpack($RD{'INFO.ACDT'}, $_[0]) }, # Actor Data? (only in .ess)
     "INFO.INAM" => sub { unpack($RD{'INFO.INAM'}, $_[0]) },
     "INFO.DATA" => sub { my($disp, $rank, $sex, $pcrank) = unpack($RD{'INFO.DATA'}, $_[0]);
			  $rank = "None" if $rank == 255;
			  $pcrank = "None" if $pcrank == 255;
			  if ($DIALTYPE eq "Journal") {
			      "JournalIndex: $disp";
			  } else {
			      "Disp:$disp  Rank:$rank  Sex:$SEX{$sex}  PCRank:$pcrank";
			  }},
     "INFO.ANAM" => sub { sprintf qq{Cell:       "%s"}, unpack($RD{'INFO.ANAM'}, $_[0]) },
     "INFO.BNAM" => sub { sprintf qq{Result:\n%s}, indent_result(unpack($RD{'INFO.BNAM'}, $_[0])) },
     "INFO.CNAM" => sub { sprintf qq{Class:      "%s"}, unpack($RD{'INFO.CNAM'}, $_[0]) },
     "INFO.DNAM" => sub { sprintf qq{PC Faction: "%s"}, unpack($RD{'INFO.DNAM'}, $_[0]) },
     "INFO.FNAM" => sub { sprintf qq{Faction:    "%s"}, unpack($RD{'INFO.FNAM'}, $_[0]) },
     "INFO.NAME" => sub { my $str = unpack($RD{'INFO.NAME'}, $_[0]); $str =~ tr/\r//d; sprintf qq{Response:   "%s"}, $str },
     "INFO.NNAM" => sub { sprintf qq{Next ID:    "%s"}, unpack($RD{'INFO.NNAM'}, $_[0]) },
     "INFO.ONAM" => sub { sprintf qq{Actor:      "%s"}, unpack($RD{'INFO.ONAM'}, $_[0]) },
     "INFO.PNAM" => sub { sprintf qq{Prev ID:    "%s"}, unpack($RD{'INFO.PNAM'}, $_[0]) },
     "INFO.RNAM" => sub { sprintf qq{Race:       "%s"}, unpack($RD{'INFO.RNAM'}, $_[0]) },
     "INFO.QSTN" => sub { my $val = unpack($RD{'INFO.QSTN'}, $_[0]);
			  (1 == $val) ? "Quest_Name" : "Unknown($val)" },
     "INFO.QSTF" => sub { my $val = unpack($RD{'INFO.QSTF'}, $_[0]);
			  (1 == $val) ? "Quest_Finished" : "Unknown($val)" },
     "INFO.QSTR" => sub { my $val = unpack($RD{'INFO.QSTR'}, $_[0]);
			  (1 == $val) ? "Quest_Restart" : "Unknown($val)" },
     "INFO.SCVR" => sub { my($idx, $typ, $fun, $cmp, $nam) = unpack($RD{'INFO.SCVR'}, $_[0]);
			  my $name = ($typ == 1) ? "" : "  Name:$nam";
			  sprintf "Index:$idx  Type:%s  Fun:%s  Cmp:%s$name",
			      print_lookup($typ, \%INFO_SCVR_type), print_lookup($fun, \%INFO_FUN), print_lookup($cmp, \%INFO_SCVR_cmp); },
     "INGR.IRDT" => sub { my($hr) = $DECODE{'INGR.IRDT'}->($_[0]);
			  my $result = sprintf "Weight: %0.2f  Value: %d  Effects: ",
			      $hr->{weight}, $hr->{value};
			  my @results;
			  foreach my $i (1..4) {
			      if ($hr->{"effect_$i"} != -1) {
				  my $eix = $hr->{"effect_$i"};
				  my $effect = $SPELL_EFFECT{$eix} || "${eix}???";
				  if ($effect =~ /_attribute$/i) {
				      push(@results, qq{$effect/$ATTRIBUTE{$hr->{"attribute_$i"}}}); # $attrs[$i]
				  } elsif ($effect =~ /_skill$/i) {
				      push(@results, qq{$effect/$SKILL{$hr->{"skill_$i"}}}); # $skills[$i]
				  } else {
				      push(@results, "$effect");
				  }
			      }
			  }
			  $result . join(", ", @results);
		      },
     "LAND.INTV" => sub { sprintf qq{Coordinates: (%d, %d)}, unpack($RD{'LAND.INTV'}, $_[0]) },
     "LEVC.DATA" => sub { "List Data: %d (1 = Calc from all levels <= PC level)", unpack($RD{'LEVC.DATA'}, $_[0]) },
     "LEVC.INTV" => sub { sprintf "Level: %d", unpack($RD{'LEVC.INTV'}, $_[0]) },
     "LEVC.NNAM" => sub { sprintf "ChanceNone: %d", unpack($RD{'LEVC.NNAM'}, $_[0]) },
     "LEVI.DATA" => sub { "List Data: %s ", $LEVI_DATA{unpack($RD{'LEVI.DATA'}, $_[0])} },
     "LEVI.INTV" => sub { sprintf "Level: %d", unpack($RD{'LEVI.INTV'}, $_[0]) },
     "LEVI.INAM" => sub { unpack($RD{'LEVI.INAM'}, $_[0]) },
     "LEVI.NNAM" => sub { sprintf "ChanceNone: %d", unpack($RD{'LEVI.NNAM'}, $_[0]) },
     "LIGH.LHDT" => sub { my($wght, $value, $time, $radius, $red, $green, $blue, $null, $flags) = unpack($RD{'LIGH.LHDT'}, $_[0]);
			  sprintf "Weight: %0.2f  Value: %d  Time: %d  Radius: %d  RGB: (%x, %x, %x)  Flags: %s",
			      $wght, $value, $time, $radius, $red, $green, $blue, decode_flags($flags, \%LHDT_FLAGS) },
     "LOCK.LKDT" => sub { sprintf "Weight: %0.2f  Value: %d  Quality: %0.2f  Uses: %d", unpack($RD{'LOCK.LKDT'}, $_[0]) },
     "LTEX.DATA" => sub { unpack($RD{'LTEX.DATA'}, $_[0]) },
     "MGEF.MEDT" => sub { my($school, $base, $flags, $red, $blue, $green, $speed, $size, $sizecap) = unpack($RD{'MGEF.MEDT'}, $_[0]);
			  sprintf "School: %s  BaseCost: %0.2f  Flags: %s  RGB: (%x, %x, %x)  SizeX: %0.2f  SizeCap: %0.2f",
			      $MAGIC_SCHOOL{$school}, $base, decode_flags($flags, \%MGEF_FLAGS), $red, $blue, $green, $size, $sizecap },
     "MISC.MCDT" => sub { sprintf "Weight: %0.2f  Value: %d  Unk:%0x", unpack($RD{'MISC.MCDT'}, $_[0]) },
#     "NPC_.ANAM" => $TOSTR_UNK,
#     "NPC_.KNAM" => $TOSTR_UNK,
     "NPC_.CNDT" => sub { unpack($RD{'NPC_.CNDT'}, $_[0]) },
     "NPC_.FLAG" => sub { decode_flags(unpack($RD{'NPC_.FLAG'}, $_[0]), \%NPC_FLAGS) },
     "NPC_.AIDT" => sub { my($hello, $unk1, $fight, $flee, $alarm, $unk2, $unk3, $unk4, $flags) = unpack($RD{'NPC_.AIDT'}, $_[0]);
			  sprintf "Hello: %d  Fight: %d  Flee: %d  Alarm: %d  Flags: %s",
			      $hello, $fight, $flee, $alarm, decode_flags($flags, \%AIDT_FLAGS); },
     "NPC_.AI_W" => sub { my($hr) = $DECODE{'NPC_.AI_W'}->($_[0]);
			  my $idle = join(", ", map { $hr->{"idle_$_"} } 1..8);
			  sprintf "Distance: %d  Duration: %d  Time_of_day: %d, Idles: $idle",
			      $hr->{distance}, $hr->{duration}, $hr->{time_of_day} },
     "NPC_.NPDT" => sub { my($hr) = $DECODE{'NPC_.NPDT'}->($_[0]);
			  if (exists $hr->{str}) { # long form
			      my $skills = "";
			      my $n = 0;
			      foreach my $skill (sort values %SKILL) {
				  next if ($skill eq 'None');
				  $skills .= "\n\t\t" if (($n++ % 7) == 0);
				  $skills .= " $skill: $hr->{$skill}";# if (defined $hr->{$skill});
			      }
			      sprintf "  Level: %d  Str: %d  Int: %d  Wil: %d  Agi: %d  Spd: %d  End: %d  Per: %d  Lck: %d\n\t\tRep: %d  Health: %d Magicka: %d  Fatigue: %d  Disp: %d  Faction: %d  Rank: %d  Gold: %d\n\t\tSkills:$skills",
				  $hr->{level}, $hr->{str}, $hr->{int}, $hr->{wil}, $hr->{agi}, $hr->{spd},
				      $hr->{end}, $hr->{per}, $hr->{lck}, $hr->{rep}, $hr->{health}, $hr->{magicka},
					  $hr->{fatigue}, $hr->{disposition}, $hr->{faction}, $hr->{rank}, $hr->{gold};
			  } else {		   # short form (autocalced)
			      sprintf "Level: %d  Disposition: %d  Faction: %d  Rank: %d  Gold: %d",
				  $hr->{level}, $hr->{disposition}, $hr->{faction}, $hr->{rank}, $hr->{gold};
			  }
		      },
     "PCDT.SNAM" => $TOSTR_UNK, # .ess
     "PCDT.ENAM" => $TOSTR_UNK, # .ess
     "PCDT.FNAM" => $TOSTR_UNK, # .ess
     "PROB.PBDT" => sub { sprintf "Weight: %0.2f  Value: %d  Quality: %0.2f  Uses: %d", unpack($RD{'PROB.PBDT'}, $_[0]) },
     "QUES.DATA" => sub { sprintf "INFO_ID: %s", unpack($RD{'QUES.DATA'}, $_[0]) }, # only in .ess (relates back to Actor in INFO)
     "RACE.RADT" => sub { my($hr) = $DECODE{'RACE.RADT'}->($_[0]);
			  my $result = sprintf "Flags: %s  Male_Height: %0.2f  Male_Weight: %0.2f  Female_Height: %0.2f  Female_Weight: %0.2f",
			      decode_flags($hr->{flags}, \%RADT_FLAGS), $hr->{male_height}, $hr->{male_weight},
				  $hr->{female_height}, $hr->{female_weight};
			  $result .= "\n\t\tSkill Bonuses:";
			  foreach my $i (1..7) {
			      my($skill_id, $bonus) = ($hr->{"skill_$i"}, $hr->{"bonus_$i"});
			      $result .= sprintf("\n\t\t%-12s %3d", $SKILL{$skill_id}, $bonus);
			  }
			  my @attr_names = qw(Strength Intelligence Willpower Agility Speed Endurance Personality Luck);
			  $result .= "\n\t\tBase Attributes: Male/Female";
			  foreach my $i (1..8) {
			      my($male, $female) = ($hr->{"attr_male_$i"}, $hr->{"attr_female_$i"});
			      $result .= sprintf("\n\t\t%-12s    %3d  %3d", shift(@attr_names), $male, $female);
			  }
			  $result;
		      },
     "REFR.ACDT" => sub { sprintf "%s", unpack("H*", $_[0]) },
     "REFR.WNAM" => sub { my $spell = unpack($RD{'REFR.WNAM'}, $_[0]);
		      sprintf "Readied_Spell: %s", $spell },
     "REGN.WEAT" => sub { sprintf "Clear: %d  Cloudy: %d  Foggy: %d  Overcast: %d  Rain: %d  Thunder: %d  Ash: %d  Blight: %d  Snow: %d  Blizzard: %d",
			      unpack($RD{'REGN.WEAT'}, $_[0]) },
     "REGN.CNAM" => sub { "Map_Color_RGB: (%x, %x, %x)", unpack($RD{'REGN.CNAM'}, $_[0]) },
     "REGN.SNAM" => sub { "Chance: %3d  SoundName: %s", unpack($RD{'REGN.SNAM'}, $_[0]) },
     "REGN.WNAM" => sub { unpack($RD{'REGN.WNAM'}, $_[0]); },
     "REPA.RIDT" => sub { sprintf "Weight: %0.2f  Value: %d  Uses: %d  Quality: %0.2f", unpack($RD{'REPA.RIDT'}, $_[0]); },
     "SCPT.RNAM" => sub { sprintf "Unk:%x", unpack($RD{'SCPT.RNAM'}, $_[0]) },
     "SCPT.SCDT" => sub { if (DBG) { unpack($RD{'SCPT.SCDT'}, $_[0]) } else { "(Compiled script data)" }; },
     "SCPT.SCHD" => sub { sprintf "Name: %s  NumShorts: %d  NumLongs: %d  NumFloats: %d  ScriptDataSize: %d  LongVarSize: %d",
			      unpack($RD{'SCPT.SCHD'}, $_[0]); },
     "SCPT.SCVR" => sub { "Script Variables: " . join(',', split(/\000/, unpack($RD{'SCPT.SCVR'}, $_[0]))) },
     "SCPT.SCTX" => sub { my $sctx = unpack($RD{'SCPT.SCTX'}, $_[0]);
			  $sctx =~ s/\r$//gm if ($^O eq 'linux');
			  "Script:\n$sctx"  },
     "SKIL.INDX" => sub { my $skill = unpack("L", $_[0]) ;
			  sprintf("%d (%s)", $skill, $SKILL{$skill});  },
     "SKIL.SKDT" => sub { my($attr, $spec, @usevals) = unpack($RD{'SKIL.SKDT'}, $_[0]);
			  sprintf "Attribute: %s  Specialization: %s  UseValues: %0.2f %0.2f %0.2f %0.2f",
			      $ATTRIBUTE{$attr}, $SPECIALIZATION{$spec}, @usevals},
     "SNDG.DATA" => sub { qq{"$SNDG_DATA[unpack($RD{'SNDG.DATA'}, $_[0])]"}; },
     "SPEL.SPDT" => sub { my($type, $cost, $flags) = unpack($RD{'SPEL.SPDT'}, $_[0]);
		      sprintf "Type: %s  Cost: %d  Flags: %s", $SPEL_TYPE{$type}, $cost, decode_flags($flags, \%SPEL_FLAGS) },
     "SPLM.NAME" => sub { unpack($RD{'SPLM.NAME'}, $_[0]); },
     "SPLM.SPDT" => sub {
	 # SPDT is 160 bytes long
	 my($type, $name, $long1, $long2, $caster, $item) = unpack($RD{'SPLM.SPDT'}, $_[0]);
	 sprintf qq{Type: %s  Name: "%s"  long1:%s  long2: %d  caster: "%s"  Item: "%s"},
	     $SPLM_TYPE{$type}, $name, dbg_word(pack("L", $long1)), $long2, $caster, $item;
     },
     "SPLM.NPDT" => sub {
	 # NPDT is 56 bytes long
	 my($name, $mag, $active, $long3, $long4) = unpack($RD{'SPLM.NPDT'}, $_[0]);
	 sprintf qq{Name: "%s"  Magnitude: %d  Seconds_Active: %0.1f  Long3: %d  Long4: %d},
	     $name, $mag, $active, $long3, $long4;
     },
     "SPLM.XNAM" => sub { sprintf "%d", unpack($RD{'SPLM.XNAM'}, $_[0]); },
     "SPLM.TNAM" => sub { sprintf "Target: %s", unpack($RD{'SPLM.TNAM'}, $_[0]); },
     "SOUN.DATA" => sub { sprintf "Volume: %d  MinRange: %d  MaxRange: %d", unpack($RD{'SOUN.DATA'}, $_[0]) },
     "SSCR.DATA" => sub { unpack($RD{'SSCR.DATA'}, $_[0]) },
     "STLN.ONAM" => sub { unpack($RD{'STLN.ONAM'}, $_[0]) },
     "WEAP.WPDT" => sub { my($wght, $value, $type, $health, $speed, $reach, $epts, $chopmin, $chopmax, $slashmin, $slashmax, $pokemin, $pokemax, $flags) = unpack($RD{'WEAP.WPDT'}, $_[0]);
		      sprintf " Wght: %0.2f  Val: %d  Typ: %s  Hlth: %d  Spd: %0.2f  Rch: %0.2f\n\t\tEnchant_Points: %d  Chop: %d-%d  Slash: %d-%d Thrust: %d-%d  Flags: %s",
			  $wght, $value, $WEAPON_TYPE{$type}, $health, $speed, $reach, $epts, $chopmin, $chopmax, $slashmin, $slashmax, $pokemin, $pokemax, $WEAPON_FLAGS{$flags}},
     "VFXM.VNAM" => sub {
	 my($long1, $long2, $long3, $long4, $long5, $long6, $short1, $hex1, $name2, $name3) =
	     unpack($RD{'VFXM.VNAM'}, $_[0]);
	 sprintf "\n  long1:%s\n  long2:%s\n  long3:%s\n  long4:%s\n  long5:%s\n  long6:%s\n  short1:%d\n  unk1:[%s]\n  name2: %s\n  name3: %s\n",
	     dbg_word($long1), dbg_word($long2), dbg_word($long3), dbg_word($long4), dbg_word($long5), dbg_word($long6), $short1, $TOSTR_UNK->($hex1), $name2, $name3;
     },

     # The following are common subrecord formats
     DELE => sub { sprintf "DELETED: Unk:0x%s", unpack($RD{'DELE'}, $_[0]) },
     DODT => sub { sprintf "Position x: %0.2f y: %0.2f z: %0.2f   Angle x: %0.2f y: %0.2f z: %0.2f", unpack($RD{'DODT'}, $_[0]) },
     FLAG => sub { sprintf "hexflags:0x%04x", unpack($RD{'FLAG'}, $_[0]) },
     NPCO => sub { sprintf 'Count=%d  Name="%s"', unpack("lZ*", $_[0]) }, # codec must use a32 for NAME
     XCHG => sub { sprintf "Enchant_Charge: %0.2f", unpack($RD{'XCHG'}, $_[0]) },
     XHLT => sub { sprintf "Health: %d", unpack($RD{'XHLT'}, $_[0]) },
     XSCL => sub { sprintf "Scale: %0.2f", unpack($RD{'XSCL'}, $_[0]) },
     XSOL => sub { sprintf "Soul: %s", unpack($RD{'XSOL'}, $_[0]) },
     WIDX => sub { my($idx, $ammo) = unpack($RD{'WIDX'}, $_[0]);
		   $ammo = ($ammo == 0) ? "" : " (Ammo)";
		   sprintf "Equipped_Idx:%3d$ammo",  $idx }, # JMS index into NPCO inventory items of those that are equipped
     SLCS => sub { sprintf "Shorts: %d  Longs: %d  Floats: %d", unpack($RD{'SLCS'}, $_[0]) }, # .ess
     SLSD => sub { sprintf "Short_Vals: " . join(", ", unpack($RD{'SLSD'}, $_[0])) }, # .ess
     SLLD => sub { sprintf "Long_Vals: " . join(", ", unpack($RD{'SLLD'}, $_[0])) }, # .ess
     SLFD => sub { sprintf "Float_Vals: " . join(", ", map { sprintf "%0.2f", $_ } join(", ", unpack($RD{'SLFD'}, $_[0]))) }, # .ess
    );

$TOSTR{"SPEL.ENAM"} = $TOSTR{"ENCH.ENAM"};

# subrecords that decode as signed 32-bit longs:
foreach (qw(INTV)) {
    $TOSTR{$_} = sub { unpack("l", $_[0]) }; }

# subrecords that decode as unsigned 32-bit longs:
foreach (qw(INDX NAM0 XIDX))
    { $TOSTR{$_} = sub { unpack("L", $_[0]) }; }

# subrecords that decode as 32-bit floats:
foreach (qw(FLTV WHGT))
    { $TOSTR{$_} = sub { sprintf "%0.2f", unpack("f", $_[0]) }; }

# subrecords that decode as variable length Z-strings:
foreach (qw(ANAM ASND AVFX BNAM BSND BVFX CNAM CSND CVFX DESC DNAM ENAM FGTN FNAM
HSND HVFX ITEX KNAM LSHN LSTN MNAM MODL NAME NPCS PTEX RGNN RNAM SCIP SCPT SCRI SNAM STRV
TEXT TGTN TNAM WNAM))
    { $TOSTR{$_} = sub { unpack("Z*", $_[0]) }; }

###DISPATCHER

my %CMDS =
    (
     # Type is 's' for commands that operate on one plugin at a time,
     # 'm' for multiple plugins at a time.
     #                    Options_fn         Command_fn        Type Description
     "clean"       => [ \&opts_clean,       \&cmd_clean,       's', "Clean plugins of Evil GMSTs, junk cells, and more"],
     "common"      => [ \&opts_common,      \&cmd_common,      'm', "Find record IDs common between two plugins"],
     "delete"      => [ \&opts_delete,      \&cmd_delete,      's', "Delete records from plugin"],
     "diff"        => [ \&opts_diff,        \&cmd_diff,        'm', "Report differences between two plugins"],
     "dump"        => [ \&opts_dump,        \&cmd_dump,        's', "Dump records as text"],
     "esm"         => [ \&opts_esm,         \&cmd_esm,         's', "Convert plugin (esp) to master (esm)"],
     "esp"         => [ \&opts_esp,         \&cmd_esp,         's', "Convert master (esm) to plugin (esp)"],
     "header"      => [ \&opts_header,      \&cmd_header,      's', "Read/Write plugin header fields (author, description)"],
     "help"        => [ \&opts_help ],
     "modify"      => [ \&opts_modify,      \&cmd_modify,      's', "Powerful batch record modification via user code extensions"],
     "multipatch"  => [ \&opts_multipatch,  \&cmd_multipatch,  'm', "Patches problems in your active plugins"],
     "overdial"    => [ \&opts_overdial,    \&cmd_overdial,    'm', "Identify overlapping dialog (a source of missing topic bugs)"],
     "recover"     => [ \&opts_recover,     \&cmd_recover,     's', "Recover usable records from plugin with 'bad form' errors"],
     "rename"      => [ \&opts_rename,      \&cmd_rename,      's', "Rename objects"],
     "-codectest"  => [ \&opts_codectest,   \&cmd_codectest,   's', "Test TES3 codec"],
     "-wikiout"    => [ \&opts_wikiout,     \&cmd_wikiout,     'm', "Output wiki formatted help"],
    );

my $command_list;
foreach (sort keys %CMDS) {
    $command_list .= "  $_\n    $CMDS{$_}->[3].\n"
	unless (($_ eq 'help') or ($_ =~ /^-/));
}
my $USAGE_ALL = qq{Usage: tes3cmd COMMAND OPTIONS plugins...

VERSION: $::VERSION

tes3cmd is a low-level command line tool that can examine, edit, and delete
records from a TES3 plugin for Morrowind. It can also generate various patches
and clean plugins too.

COMMANDS
$command_list

FOR HELP ON INDIVIDUAL COMMANDS:

  tes3cmd help <command>

GENERAL HELP:

OPTIONS given to commands may be abbreviated, as long as the abbreviations are
unique.

tes3cmd uses Perl regular expressions for matching, the full documentation can
be found here:
   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^\$()[]{}" have
special meaning in a regular expression and that they are unlike characters
used for matching on a Windows command line.
};

sub opts_help {
    if (my $cmd_name = shift(@ARGV)) {
	if (my $cmd_ref = $CMDS{$cmd_name}) {
	    $cmd_ref->[0]->(1);	# exits
	} else {
	    die $USAGE_ALL;
	}
    }
    die $USAGE_ALL;
}

###IO

sub update_header {
    my($plugin, $quiet) = @_;
    my $datafiles;
    my $master;
    my($atime, $mtime) = (stat($plugin))[8,9];
    if ($opt_header_update_masters) {
	find_datadir();
	$datafiles = list_files($DATADIR);
    }
    my $fh = open_for_update($plugin);
    my($rectype, $rec, $flags, $unk) = read_rec($fh, 'TES3', $plugin);
    my $tes3len = length($rec);
    decode_rec($plugin, 'TES3', $rec); # sets $R
    my $updated_masters = '';
    foreach my $subr (@$R) {
	my($subtype, $hr) = @$subr;
	if ($subtype eq 'HEDR') {
	    if ($opt_header_author) {
		if ($opt_header_author =~ /^\+(.*)/) {
		    $hr->{author} .= $1;
		} else {
		    $hr->{author} = $opt_header_author;
		}
	    }
	    if ($opt_header_description) {
		if ($opt_header_description =~ /^\+(.*)/) {
		    $hr->{description} .= $1;
		} else {
		    $hr->{description} = $opt_header_description;
		}
	    }
	    if ($opt_header_update_record_count) {
		$hr->{nrecords} = get_record_count($plugin);
	    }
	}
	if ($opt_header_update_masters) {
	    if ($subtype eq 'MAST') {
		$master = $hr->{master};
	    } elsif ($subtype eq 'DATA') {
		my $length = $hr->{length};
		if ((my $newlen = -s ("$DATADIR/" . $datafiles->{lc($master)})) != $length) {
		    $updated_masters .= qq{  Synchronized master "$master" length: $length --> $newlen\n};
		    $hr->{length} = $newlen;
		}
	    }
	}
    }
    unless ($quiet) {
	my $banner = "$plugin:\n";
	if (not($opt_header_author or $opt_header_description or $opt_header_update_record_count or
		$opt_header_update_masters or $opt_header_update_record_count) or
	    $opt_header_author or $opt_header_description or $opt_header_update_record_count) {
	    foreach my $subr (@$R) {
		my($subtype, $hr) = @$subr;
		if ($subtype eq 'HEDR') {
		    if ($opt_header_multiline) {
			print qq{$plugin:\n  AUTH=$hr->{author}\n  DESC=$hr->{description}\n};
		    } else {
			my $msg = qq{$plugin:  AUTH=$hr->{author}  DESC=$hr->{description}};
			$msg =~ s/(\r)?\n/\\r\\n/gm;
			print "$msg\n";
		    }
		    $banner = '';
		    last;
		}
	    }
	}
	print $banner . $updated_masters if ($updated_masters);
    }
    $rec = encode_rec('TES3');	# uses $R
    if (length($rec) == $tes3len) {
	seek($fh, 0, SEEK_SET);
	write_rec($fh, 'TES3', $rec, $flags, $unk);
    } else {
	die "update_header(): output header size incorrect\n";
    }
    close($fh);
    utime($atime, $mtime, $plugin);
}				# update_header

my $hdr_size = 16;
sub read_rec {
    my($fh, $expected_type, $plugin) = @_;
    my $rec_hdr = "";
    my $n_read = sysread($fh, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef);
    }
    if ($n_read != $hdr_size) {
	my $inp_offset = sysseek($fh, 0, SEEK_CUR) - $n_read - $hdr_size;
	die qq{read_rec(): Read Error ($plugin header at byte: $inp_offset): asked for $hdr_size bytes, got $n_read\n};
    }
    my($rectype, $rec_len, $unk, $flags) = unpack("a4LLL", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rectype) {
	my $inp_offset = sysseek($fh, 0, SEEK_CUR) - $n_read - $hdr_size;
	die qq{read_rec(): Error ($plugin at byte: $inp_offset): Expected: $expected_type, got: $rectype\n};
    }
    my $rec = "";
    $n_read = sysread($fh, $rec, $rec_len);
    if ($n_read != $rec_len) {
	my $inp_offset = sysseek($fh, 0, SEEK_CUR) - $n_read - $hdr_size;
	die qq{read_rec(): Read Error ($plugin record at byte: $inp_offset, rec_type="$rectype"): asked for $rec_len bytes, got $n_read\n};
    }
    return($rectype, $rec, $flags, $unk, $rec_hdr);
}

sub write_rec {
    my($fh, $rectype, $rec, $flags, $unk) = @_;
    print $fh pack("a4LLLa*", $rectype, length($rec), $unk, $flags, $rec);
}

sub subrec {
    my($type, $val) = @_;
    return(pack("a4La*", $type, length($val), $val));
}

sub ext_cell_name {
    my($srh, $name) = @_;
    $name = $name || chop_nulls($srh->{RGNN}[0]) || "Wilderness";
    if (length($srh->{DATA}[0]) < 12) { # size of "x[L]ll"
	warn "Error, CELL: ($name) does not have a valid DATA subrecord\n";
	return($name);
    } else {
	return(sprintf("$name (%d, %d)", unpack("x[L]ll", $srh->{DATA}[0])));
    }
}

sub rec_id {
    my($srh, $rectype) = @_;
    if ($rectype eq "INFO") {
	return(chop_nulls($srh->{INAM}[0]));
    } elsif ($rectype eq "CELL") {
	my $name = chop_nulls($srh->{NAME}[0]);
	my $data = $srh->{DATA}[0];
	my($flags) = unpack("L", $data);
	if ($flags & 1) {	# interior
	    return($name);
	} else {		# exterior
	    return(ext_cell_name($srh, $name));
	}
    } elsif ($rectype eq "SCPT") {
	return(lc(unpack("Z32", $srh->{SCHD}[0])));
    } elsif (defined $srh->{NAME}) {
	return(lc(chop_nulls($srh->{NAME}[0])));
    } elsif (defined $srh->{INDX}) {
	return(unpack("L", $srh->{INDX}[0]));
    } elsif ($rectype eq "LAND") {
	my($x, $y) = unpack("ll", $srh->{INTV}[0]);
	return("($x, $y)");
    } elsif ($rectype eq "TES3") {
	return('');
    }
    return(undef);
}

# given a reference to object returned by a decoder, return printable name
# operates on current record: $R
sub get_id {
    my($rectype) = @_;
    if ($rectype eq "INFO") {
	foreach my $subr (@$R) {
	    if ($subr->[0] eq 'INAM') {
		return($subr->[1]->{Name});
	    }
	}
    } elsif ($rectype eq "CELL") {
	my($name, $rgnn, $coord);
	foreach my $subr (@$R) {
	    if ($subr->[0] eq 'NAME') {
		$name = $subr->[1]->{String} unless (defined $name);
	    } elsif ($subr->[0] eq 'RGNN') {
		$rgnn = $subr->[1]->{String} unless (defined $rgnn);
	    } elsif ($subr->[0] eq 'DATA') {
		if (defined $subr->[1]->{X}) {
		    $coord = "$subr->[1]->{X}, $subr->[1]->{Y}"; # External Cell
		}
	    }
	    last if ($subr->[0] eq 'FRMR');
	}
	if (defined $coord) {	# this is an external cell
	    my $where = $name || $rgnn || 'Wilderness';
	    return("$where ($coord)");
	} else {		# this is an internal cell
	    return($name);
	}
    } elsif ($rectype eq "SCPT") {
	foreach my $subr (@$R) {
	    return(lc(chop_nulls($subr->[1]->{Name})))
		if ($subr->[0] eq 'SCHD');
	}
    } elsif ($rectype eq "LAND") {
	foreach my $subr (@$R) {
	    if ($subr->[0] eq 'INTV') {
		my $x = $subr->[1]->{X};
		my $y = $subr->[1]->{Y};
		return("($x, $y)");
	    }
	}
    } elsif (($rectype eq "MGEF") or ($rectype eq "SKIL")) {
	foreach my $subr (@$R) {
	    if ($subr->[0] eq 'INDX') {
		return($subr->[1]->{Long});
	    }
	}
    } elsif ($rectype eq "TES3") {
	return('');
    } else {
	foreach my $subr (@$R) {
	    if ($subr->[0] eq 'NAME') {
		return($subr->[1]->{String});
	    }
	}
    }
    warn "get_id(): don't know how to make ID for: $rectype\n";
    return(undef);
}

sub parse_subrec_list {
    my($rec) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @subrecs = ();
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	push(@subrecs, [$subrec_type, $subrec]) if (defined $subrec);
	$p += $subrec_len;
    }
    return(\@subrecs);
}

# this version takes a little longer to execute
sub parse_subrec_hash_long {
    my($rec) = @_;
    warn "DBG: calling parse_subrec_hash_long for rec=$rec\n" if (DBG);
    my %r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	push(@{$r{$subrec_type}}, $subrec) if (defined $subrec);
	$p += $subrec_len;
    }
    return(\%r);
}

sub parse_subrec_hash {
    my($rec) = @_;
    my %r = ();
    eval {
	my @parts = unpack("(a4L/a*)*", $rec);
	while (my($key, $buff) = splice(@parts, 0, 2)) {
	    push(@{$r{$key}}, $buff);
	}
    };
    if ($@) {
	warn qq{DBG: parse_subrec_hash failed on "$rec", retrying with safer parser\n} if (DBG);
	return(parse_subrec_hash_long($rec));
    }
    return(\%r);
}

sub parse_cell_objects {
    my($rec) = @_;
    my($hdr, $obj, @objs, %objidx);
    my $srl = parse_subrec_list($rec);
    foreach my $subr (@$srl) {
	my($subtype, $subrec) = @$subr;
	if ($subtype eq 'NAM0') {
	    if ($obj) {
		my @newobj = @$obj;
		push(@objs, \@newobj);
		$objidx{$newobj[1]} = $newobj[0];
		undef $obj;
	    }
	    push(@objs, 'NAM0');
	} elsif ($subtype eq 'FRMR') {
	    if ($obj) {
		my @newobj = @$obj;
		push(@objs, \@newobj);
		$objidx{$newobj[1]} = $newobj[0];
	    }
	    # start new object
	    $obj->[0] = [unpack($RD{'CELL.FRMR'}, $subrec)];
	    $obj->[1] = '';
	} else {
	    if ($obj) {		# collecting object
		$obj->[1] .= pack("a4L/a*", $subtype, $subrec);
	    } else {		# still collecting header
		$hdr .= pack("a4L/a*", $subtype, $subrec);
	    }
	}
    }
    if ($obj) {
	my @newobj = @$obj;
	push(@objs, \@newobj);
	$objidx{$newobj[1]} = $newobj[0];
    }
    return($hdr, \@objs, \%objidx);
}

sub assemble_cell_objects {
    my($hdr, $objs) = @_;
    my $rec = $hdr;
    my $idx = 1;
    foreach my $obj (@$objs) {
	if ($obj eq 'NAM0') {
	    my $nam0 = scalar(@$objs) - $idx;
	    $rec .= pack("a4LL", 'NAM0', 4, $nam0) if ($nam0 > 0);
	} else {
	    my $frmr = pack($RD{'CELL.FRMR'}, @{$obj->[0]});
	    $rec .=  pack("a4L/a*", 'FRMR', $frmr) . $obj->[1];
	}
	$idx++;
    }
    return($rec);
}

sub new_rec {
    my($sub_recs) = @_;
    my @rec;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	my $len = length($val);
	push(@rec, pack("a4La*", $type, $len, $val));
    }
    return(join("", @rec));
}

sub pprec {
    my($rec, $subtype) = @_;
    warn "DBG: pprec($rec)\n" if (DBG);
    my $recstr = join(":", grep(!/[^[:print:]]/, map { s/[\000]+$//gm; tr/\r\n/ /; $_; } split(/\000?([A-Z][A-Z_][A-Z_][A-Z_\d])...\000/, $rec)));
    $recstr =~ s/^:$subtype:.*?:// if ($subtype);
    $recstr =~ s/:([A-Z][A-Z_][A-Z_][A-Z_\d])/|$1/g;
    return(substr($recstr, 0, $opt_rename_window_size));
}

sub open_for_read {
    my($plugin) = @_;
    my $fh = IO::Handle->new();
    unless (open($fh, "<$plugin")) {
	die qq{Error opening "$plugin" for input ($!)\n};
    }
    unless (binmode($fh, ':raw')) {
	die "Error setting binmode on $plugin ($!)\n";
    }
    return($fh);
}

sub open_for_write {
    my($plugin) = @_;
    my $fh = IO::Handle->new();
    unless (open($fh, ">$plugin")) {
	die qq{Error opening "$plugin" for output ($!)\n};
    }
    unless (binmode($fh, ':raw')) {
	die qq{Error setting binmode on "$plugin" ($!)\n};
    }
    return($fh);
}

sub open_for_update {
    my($plugin) = @_;
    my $fh = IO::Handle->new();
    unless (open($fh, "+<$plugin")) {
	die qq{Error opening "$plugin" for read/write ($!)\n};
    }
    unless (binmode($fh, ':raw')) {
	die qq{Error setting binmode on "$plugin" ($!)\n};
    }
    return($fh);
}

sub make_temp {
    my($plugin) = @_;
    die qq{Error, "$plugin" name does not end in .esm/.esp/.ess\n}
	if ($plugin !~ /\.(es[mps])$/i);
    my $plugtmp = "$plugin.tmp";
    my $inp = open_for_read($plugin);
    my $out = open_for_write($plugtmp);
    return($inp, $out);
}

sub unique_backup_name {
    my($plugbak) = @_;
    my($ext) = ($plugbak =~ /\.(es[mps])$/i);
    while (-f $plugbak) {
	$plugbak =~ s/(?:~(\d+))?\.$ext$/'~' . ($1 + 1) . ".$ext"/e;
    }
    return($plugbak);
}

sub fix_output {
    my($inp, $out, $plugin, $modified, $newname) = @_;
    close($inp);
    close($out);
    my $plugtmp = "$plugin.tmp";
    unless ($modified) {
	print "$plugin was not modified\n";
	unlink($plugtmp);
	return;
    }
    if ($opt_output_dir) {
	$newname = $plugin unless ($newname);
	# prepend given output directory
	$newname = "$opt_output_dir/" . (fileparse($newname))[0];
    }
    if (my($ext) = ($plugin =~ /\.(es[mps])$/i)) {
	my($atime, $mtime) = (stat($plugin))[8,9];
	if (File::Spec->rel2abs($newname) eq File::Spec->rel2abs($plugin)) {
	    warn "fix_output(): newname ($newname) same as plugin ($plugin)\n";
	    undef $newname;
	}
	if (defined($newname)) {
	    unless ($newname =~ /\.(es[mps])$/i) {
		fatal_error(qq{"$newname" name does not end in .esm/.esp/.ess});
	    }
	    unless (rename($plugtmp, $newname)) {
		fatal_error(qq{Renaming "$plugtmp" to "$newname" ($!)});;
	    }
	    $opt_header_update_record_count = 1;
	    update_header($newname, QUIET);
	    utime($atime, $mtime, $newname);
	    print qq{Output saved in: "$newname"\nOriginal unaltered: "$plugin"\n};
	} else {
	    my $plugbak = unique_backup_name($plugin);
	    unless (rename($plugin, $plugbak)) {
		fatal_error(qq{Renaming "$plugin" to "$plugbak" ($!)});
	    }
	    unless (rename($plugtmp, $plugin)) {
		fatal_error(qq{Renaming "$plugtmp" to "$plugin" ($!)});
	    }
	    $opt_header_update_record_count = 1;
	    update_header($plugin, QUIET);
	    utime($atime, $mtime, $plugin);
	    print qq{Output saved in: "$plugin"\nOriginal backed up to: "$plugbak"\n};
	}
    } else {
	die qq{Error, "$plugin" name does not end in .esm/.esp/.ess\n};
    }
}

sub cleanup_temp {
    my($inp, $plugin) = @_;
    close($inp);
    my $plugtmp = "$plugin.tmp";
    unlink($plugtmp);
}

sub read_objects {
    my($plugin, $fun) = @_;
    my $inp = open_for_read($plugin);
    my %plugin_id = ();
    eval {
	while (my($rectype, $rec, $flags, $unk) = read_rec($inp, undef, $plugin)) {
	    last if (not defined $rectype);
	    if ($flags & 0x1000) {
		warn "plugin($plugin) REC=$rectype flags=$flags (ignored)\n" if (DBG);
		next;
	    }
	    my $id = rec_id(parse_subrec_hash($rec), $rectype);
	    if ($fun) {
		$fun->($rectype, $id);
	    } else {
		$plugin_id{$rectype}->{$id} = $rec if (defined $id);
	    }
	}
    };
    warn $@ if ($@);
    close($inp);
    return(\%plugin_id) unless ($fun);
}

sub read_dialogs {
    my($plugin, $dialref) = @_;
    my $inp = open_for_read($plugin);
    eval {
	while (my($rectype, $rec, $flags, $unk) = read_rec($inp, undef, $plugin)) {
	    last if (not defined $rectype);
	    if ($flags & 0x1000) {
		warn "plugin($plugin) REC=$rectype flags=$flags (ignored)\n" if (DBG);
		next;
	    }
	    next if ($rectype ne "DIAL");
	    my $srh = parse_subrec_hash($rec);
	    my $id = chop_nulls($srh->{NAME}[0]);
	    my $type = unpack("C", $srh->{DATA}[0]);
	    $dialref->{$plugin}->{$id}++ if ($type == 0 and $id);
	}
    };
    warn $@ if ($@);
    close($inp);
}


sub get_wanted {
    my $wanted_ids = (@opt_id) ? '(' . join('|', @opt_id) . ')' : '';
    my $wanted_flags;
    foreach my $flag (@opt_flag) {
	if ((my $n = eval $flag) > 0) {
	    $wanted_flags |= $n; # it's a numeric flag
	} else {
	    $wanted_flags |= $REC_FLAGS{lc($flag)};
	}
    }
    my $wanted_types;
    if (@opt_type) {
	foreach my $option (@opt_type) {
	    my($type, $subtype) = split(/\./, uc($option));
	    if (length($type) != 4) {
		warn qq{get_wanted_types: Invalid record type: "$type" (must be 4 characters long)\n};
		next;
	    }
	    $wanted_types->{$type}++;
	    if ($subtype) {
		if (length($subtype) == 4) {
		    $wanted_types->{"$type.$subtype"}++;
		} else {
		    warn qq{get_wanted_types: Invalid record subtype: "$subtype" (must be 4 characters long)\n};
		    next;
		}
	    }
	}
    }
    return($wanted_ids, $wanted_types, $wanted_flags);
}

my $CURRENT_DIAL;
sub rec_to_string {
    my($rec, $rectype, $id, $plugin, $flags, $unk) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @print_rec;
    my($prefix, $unkstr);
    unless ($opt_separator) {
	$prefix = "\n";
	$opt_separator = "\n ";
    }
    if (DBG) {
	$prefix = "$plugin ";
	$unkstr = sprintf "  Unk:%04x", $unk;
	$opt_separator = "\n ";
    }
    my $dial_str = ($rectype eq 'INFO') ? " $CURRENT_DIAL" : '';
    my $flagstr = decode_flags($flags, \%REC_FLAGS);
    warn "REC=$rectype $id flags=$flagstr\n" if (DBG);
    my $hdr = defined($flags) ? qq{${prefix}Record: $rectype "$id"$dial_str Flags: $flagstr${unkstr}} : '';
    my @frmr_data;
    my $first_frmr_seen = 0;
    my $frmr_match = 0;
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	$p += $subrec_len;
	if (defined $subrec) {
	    my $full_type = "${rectype}.${subrec_type}";
	    my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type} || $TOSTR_UNK;
	    my $subrec_str = $tostr->($subrec);
	    if ($opt_cell_object_match and ($rectype eq 'CELL')) {
		if ($first_frmr_seen) {
		    if ($subrec_type eq 'FRMR') {
			if (join(" ", @frmr_data) =~ /$opt_cell_object_match/i) {
			    $frmr_match++;
			    push(@print_rec, @frmr_data);
			}
			@frmr_data = (); # start a new group
		    }
		    push(@frmr_data, "$subrec_type: $subrec_str");
		} else {
		    if ($subrec_type eq 'FRMR') {
			# start the first FRMR group
			$first_frmr_seen = 1;
			push(@frmr_data, "$subrec_type: $subrec_str");
		    } else {
			# we push subrecs onto print_rec up until the first FRMR
			push(@print_rec, "$subrec_type: $subrec_str");
		    }
		}
	    } else {
		push(@print_rec, "$subrec_type: $subrec_str");
	    }
	} else {
	    warn "$plugin: Error, malformed subrec for ($rectype $id) type=$subrec_type pos=$p len=$subrec_len\n";
	}
    }
    # if -C, check the last FRMR group
    if ($opt_cell_object_match) {
	if (join(" ", @frmr_data) =~ /$opt_cell_object_match/i) {
	    $frmr_match++;
	    push(@print_rec, @frmr_data);
	}
	return("") unless ($frmr_match);
    }
    return(join($opt_separator, $hdr, @print_rec));
}

# decode record buffer into a list of [subtype, hr], where hr is a hash of the fields of the subrecord
sub decode_rec {
    my($plugin, $rectype, $rec) = @_;
    #warn "decode_rec($plugin, $rectype, $rec)\n";
    my $p = 0;
    my $rec_len = length($rec);
    # decode the subrecords for this record
    my @subrecs = ();
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	$p += $subrec_len;
	if (defined $subrec) {
	    my($hr) = decoder($rectype, $subrec_type)->($subrec);
	    push(@subrecs, [$subrec_type, $hr]);
	} else {
	    warn "$plugin: Error, malformed subrec for ($rectype) type=$subrec_type pos=$p len=$subrec_len\n";
	}
    }
    return($R = \@subrecs);
}

# encode and return a buffer for the subrecords that comprise the body of a full record.
sub encode_rec {
    my($rectype) = @_;
    my $newrec = '';
    foreach my $subr (@$R) {
	my($subrec_type, $hr) = @$subr;
	my $full_type = "${rectype}.${subrec_type}";
	my $subrec = encoder($rectype, $subrec_type)->($hr);
	$newrec .= pack("a4L/a*", $subrec_type, $subrec);
    }
    return($newrec);
}

# return 1 if record matches selection criteria of command line switches
sub rec_match {
    my($plugin, $rectype, $rec, $flags, $wanted_ids, $wanted_types, $wanted_flags) = @_;
    next if ($wanted_flags and not ($flags & $wanted_flags));
    if ($wanted_types) {
	unless ($wanted_types->{INFO} and ($rectype eq 'DIAL')) {
	    return(0) unless ($wanted_types->{$rectype});
	}
    }
    my $srh = parse_subrec_hash($rec);
    if ($rectype eq 'DIAL') {
	$CURRENT_DIAL = '(' . $DIAL_TYPE{unpack("C", $srh->{DATA}[0])} . ':' . chop_nulls($srh->{NAME}[0]) . ')';
    }
    return(0, $srh) if ($wanted_types and not $wanted_types->{$rectype});
    my $id = rec_id($srh, $rectype);
    return(0, $srh, $id) if ($wanted_ids and $id !~ /$wanted_ids/i);
    if ($rectype eq 'CELL') {
	if (is_interior($srh)) {
	    return(0, $srh, $id) if ($opt_exterior);
	} else {
	    return(0, $srh, $id) if ($opt_interior);
	}
    }
    if ($opt_match or $opt_no_match) {
	#warn qq{DBG: opt_match == "$opt_match"   opt_no_match == "$opt_no_match"\n};
	my $print_rec = rec_to_string($rec, $rectype, $id, $plugin, $flags);
	#warn "DBG: print_rec == {{{{$print_rec}}}}\n";
	if (((not $opt_match) or ($print_rec =~ /$opt_match/is)) and
	    ((not $opt_no_match) or ($print_rec !~ /$opt_no_match/is))) {
	    #warn "DBG: match for $opt_match\n";
	    return(1, $srh, $id, $print_rec);
	} else {
	    return(0, $srh, $id, $print_rec);
	}
    } else {
	return(1, $srh, $id);
    }
}

sub process_plugin_for_read {
    my($plugin, $fun) = @_;
    my $inp = open_for_read($plugin);
    my $expected = "TES3";
    my($wanted_ids, $wanted_types, $wanted_flags) = get_wanted();
    # process each record in the plugin
    eval {
	while (my($rectype, $rec, $flags, $unk, $rec_hdr) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if (not defined $rectype);
	    warn "REC=$rectype flags=$flags\n" if (DBG);
	    my($rec_match, $srh, $id, $print_rec) =
		rec_match($plugin, $rectype, $rec, $flags, $wanted_ids, $wanted_types, $wanted_flags);
	    $fun->($rec_match, $rectype, $id, $rec, $srh, $flags, $unk, $rec_hdr, $print_rec);
	}
    };
    warn $@ if ($@);
    close($inp);
}

sub process_plugin_for_update {
    my($plugin, $fun, $prefix) = @_;
    my($inp, $out) = make_temp($plugin);
    my $expected = "TES3";
    my($wanted_ids, $wanted_types, $wanted_flags) = get_wanted();
    my $modified = 0;
    # process each record in the plugin
    eval {
	while (my($rectype, $rec, $flags, $unk, $rec_hdr) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if (not defined $rectype);
	    warn "REC=$rectype flags=$flags\n" if (DBG);
	    my($rec_match, $srh, $id, $print_rec) =
		rec_match($plugin, $rectype, $rec, $flags, $wanted_ids, $wanted_types, $wanted_flags);
	    my($newrec, $newflags) = $fun->($rec_match, $rectype, $id, $rec, $srh, $flags, $unk, $rec_hdr, $print_rec);
	    if ($newrec) {	# rec was kept
		write_rec($out, $rectype, $newrec, $newflags, $unk);
		$modified++ if ($rec ne $newrec);
	    } else {
		$modified++;	# rec was deleted
	    }
	}
    };
    if ($@) {
	$modified = 0;
	warn $@;
    }
    if ($prefix) {
	my($file, $dir) = fileparse($plugin);
	my $newname = ($dir eq './') ? "${prefix}${file}" : "${dir}${prefix}${file}";
	fix_output($inp, $out, $plugin, $modified, $newname);
    } else {
	fix_output($inp, $out, $plugin, $modified);
    }
}

sub get_record_count {
    my($plugin) = @_;
    my $count = -1;		# we don't count the TES3 record
    process_plugin_for_read($plugin, sub { $count++; });
    return($count);
}

sub search_and_replace {
    my($x, $mref) = @_;
    my $type = ref($x);
    if ($type eq 'ARRAY') {
	foreach (@$x) {
	    if (ref($_) eq '') {
		${$mref} = 1 if eval qq{\$_ =~ s$opt_modify_replace;};
	    } else {
		search_and_replace($_, $mref);
	    }
	}
    } elsif ($type eq 'HASH') {
	while (my($k, $v) = each %$x) {
	    if (ref($x->{$k}) eq '') {
		${$mref} = 1 if eval qq{\$x->{\$k} =~ s$opt_modify_replace;};
	    } else {
		search_and_replace($x->{$k}, $mref);
	    }
	}
    } elsif ($type eq '') {
	my $x_before = $x;
	${$mref} = 1 if eval qq{\$_ =~ s$opt_modify_replace;};
    }
}

# currently unused
sub getrec {
    my($opt) = @_; 		# opt is hashref with keys: "i", "t", "f"
    my @indices = defined($opt->{i}) ? ($opt->{i}) : (0 .. $#$R);
    foreach my $i (@indices) {
	my $type = $R->[$i]->[0];
	next if (defined($opt->{t}) and ($type !~ /^$opt->{t}/i));
	if (defined($opt->{f})) {
	    my $key = lc($opt->{f});
	    if (defined($R->[$i]->[1]->{$key})) {
		return($R->[$i]->[1]->{$key});
	    } else {
		next;
	    }
	} else {
	    # give first (default) field
	    my @ordered_fields = ();
	    my @unordered_fields = ();
	    while (my($key, $val) = each %{$R->[$i]->[1]}) {
		if (defined $R->[$i]->[2]->{$key}) {
		    $ordered_fields[$R->[$i]->[2]->{$key}] = $val;
		} else {
		    push(@unordered_fields, $val);
		}
	    }
	    my @fields;
	    push(@fields, @ordered_fields, @unordered_fields);
	    return(shift, @fields);
	}
    }
    die "getrec: no match\n";
}

# operates on current record: $R
sub dumprec {
    my($opt) = @_; 		# opt is hashref with keys: "i", "t", "f"
    my @indices = defined($opt->{i}) ? @{$opt->{i}} : (0 .. $#$R);
    foreach my $i (@indices) {
	my $type = $R->[$i]->[0];
	next if (defined($opt->{t}) and ($type !~ /^$opt->{t}/i));
	if (defined($opt->{f})) {
	    my $key = lc($opt->{f});
	    if (defined($R->[$i]->[1]->{$key})) {
		print qq{$i: $type  $key = $R->[$i]->[1]->{$key}\n};
	    } else {
		next;
	    }
	} else {
	    # dump all fields
	    my @ordered_fields = ();
	    my @unordered_fields = ();
	    while (my($key, $val) = each %{$R->[$i]->[1]}) {
		$val = qq{"$val"} if ($val =~ /[^\d.]/);
		my $print_key = lcfirst($key);
		if (defined $R->[$i]->[2]->{$key}) {
		    $ordered_fields[$R->[$i]->[2]->{$key}] = "$key = $val";
		} else {
		    push(@unordered_fields, "$key = $val");
		}
	    }
	    print " $i: $type ", join(", ", @ordered_fields, @unordered_fields), "\n";
	}
    }
    return(0);
}

# operates on current record: $R
sub setrec {
    my($opt, $newval) = @_;	# opt is hashref with keys: "i", "t", "f"
    unless (defined $newval) {
	warn qq{Usage: setrec(\$option_hash, \$newvalue)
option_hash can have the keys: "i", "t", or "f"\n};
	return;
    }
    my $rc = 0;
    my @indices = defined($opt->{i}) ? @{$opt->{i}} : (0 .. $#$R);
    foreach my $i (@indices) {
	my $type = $R->[$i]->[0];
	next if (defined($opt->{t}) and ($opt->{t} ne $type));
	if (defined($opt->{f})) {
	    my $key = lc($opt->{f});
	    if (defined($R->[$i]->[1]->{$key})) {
		if ($R->[$i]->[1]->{$key} ne $newval) {
		    $R->[$i]->[1]->{$key} = $newval;
		    $rc++;
		}
		#print qq{$i: $type  $key = $R->[$i]->[1]->{$key}\n};
	    } else {
		next;
	    }
	} else {
	    # set all fields
	    my @ordered_fields = ();
	    my @unordered_fields = ();
	    while (my($key, $val) = each %{$R->[$i]->[1]}) {
		if ($newval ne $val) {
		    $val = $R->[$i]->[1]->{$key} = $newval;
		    $rc++;
		}
		if (defined $R->[$i]->[2]->{$key}) {
		    $ordered_fields[$R->[$i]->[2]->{$key}] = "$key = $val";
		} else {
		    push(@unordered_fields, "$key = $val");
		}
	    }
	    #print "$i: $type ", join(", ", @ordered_fields, @unordered_fields), "\n";
	}
    }
    return($rc);
}

sub remove_subrec {
    my($r, $subtype, $n) = @_;
    my @new_r = ();
    my $c = 0;
    foreach my $subr (@$r) {
	if ($subr->[0] eq $subtype) {
	    next unless ((defined $n) and ($c++ >= $n));
	}
	push(@new_r, $subr);
    }
    return(\@new_r);
}

sub run_code {
    my($rectype, $flags, $unk) = @_;
    my $mod = 0;
    search_and_replace($R, \$mod) if ($opt_modify_replace);
    if ($opt_modify_run) {
	$mod ||= eval($opt_modify_run);
	if ($@) {
	    warn qq{Error running "$opt_modify_run" on: $rectype ($@)\n};
	    $mod = 0;
	}
    }
    return(($mod) ? $R : undef)
}

sub encoder {
    my($rectype, $subrec_type) = @_;
    return($ENCODE{"${rectype}.${subrec_type}"} || $ENCODE{$subrec_type} || $ENCODER_UNKNOWN);
}

sub decoder {
    my($rectype, $subrec_type) = @_;
    return($DECODE{"${rectype}.${subrec_type}"} || $DECODE{$subrec_type} || $DECODER_UNKNOWN);
}

sub master_cache_name {
    my($esm) = @_;
    my $cname = "$TES3CMD_DIR/$esm";
    $cname =~ s/\.esm$/.dat/;
    #warn "DBG: master_cache_name($esm) -> $cname\n";
    return($cname);
}

sub load_master_cache {
    my($esm) = @_;
    return(0) if ($opt_no_cache);
    my $esm_file = list_files($DATADIR)->{$esm};
    my $mcache = master_cache_name($esm);
    warn "DBG: master cache name = $mcache\n" if (DBG);
    eval {
	if (my $listref = retrieve($mcache)) {
	    my($prev_size, $master_data) = @{$listref};
	    my $curr_size = (-s "$DATADIR/$esm_file");
	    if ($curr_size == $prev_size) {
		$MASTER_ID->{$esm} = $master_data;
		my $name = $mcache;
		$name =~ s/$DATADIR/<DATADIR>/;
		print "Loaded cached Master: $name\n";
	    } else {
		die "Cache Invalidated for: $esm_file (curr_size == $curr_size, prev_size == $prev_size)\n";
	    }
	} else {
	    die "Error retrieving master cache for: $esm_file\n";
	}
    };
    if ($@) {
	warn $@ unless ($@ =~ /can't open .*\.dat: No such file or directory/);
	return(0);
    } else {
	return(1);
    }
}

sub save_master_cache {
    my($esm) = @_;
    return(0) if ($opt_no_cache);
    my $esm_file = list_files($DATADIR)->{$esm};
    my $mcache = master_cache_name($esm);
    unless (-d $TES3CMD_DIR) {
	mkdir($TES3CMD_DIR, 0755) or
	    fatal_error(qq{Unable to make directory: "$TES3CMD_DIR" ($!)});
    }
    my $size = (-s "$DATADIR/$esm_file");
    warn "DBG: save_master_cache($esm) saving size: $size\n" if (DBG);
    store([ $size, $MASTER_ID->{$esm}], $mcache);
}

# load all the records from a master .esm into a dictionary.
sub load_master {
    my($esm, $types) = @_;
    $esm = lc($esm);
    warn "DBG: load_master($esm, $types)\n" if (DBG);
    find_datadir();
    if (defined $MASTER_ID->{$esm}) {
	warn "DBG: re-using master data: $esm\n" if (DBG);
	return;
    }
    return if (load_master_cache($esm)); # load pre-parsed data
    print "Loading Master: $esm\n";
    my $esm_file = list_files($DATADIR)->{$esm};
    my $inp = open_for_read("$DATADIR/$esm_file");
    eval {
	while (my($rectype, $rec, $flags) = read_rec($inp, undef)) {
	    last if (not defined $rectype);
	    next if (defined $types and not $types->{$rectype});
	    if ($flags & 0x1000) {
		print "Master($esm) REC=$rectype flags=$flags (ignored)\n" if (DBG);
		next;
	    }
	    print "DBG: rec_type = $rectype\n" if (DBG);
	    my $srh = parse_subrec_hash($rec);
	    my $id = rec_id($srh, $rectype);
	    $MASTER_ID->{$esm}->{$id}->{$rectype} = [$srh, $rec, $flags];
	}
    };
    warn $@ if ($@);
    close($inp);
    save_master_cache($esm);
}

sub dumpit {
    my($label, $it) = @_;
    $it =~ s/([[:cntrl:]])/"^".chr(ord($1)+64)/ge;
    warn("$label: [$it]\n" . ((DBG) ? unpack("H*", $it) . "\n" : ''));
}

###COMMANDS

sub cmd_codectest {
    my($plugin) = @_;
    return if ($plugin =~ /^test_/);
    my %exclude;
    if (@opt_codectest_excluded_type) {
	# optional types to exclude
	foreach (@opt_codectest_excluded_type) { $exclude{uc($_)}++; }
    }
    print "\n", ("=" x 65), "\n";
    print "TESTING codec on: $plugin ...\n";
    my $fun = sub {
	my($rec_match, $rectype, $id, $rec, $srh, $flags, $unk, $rec_hdr, $print_rec) = @_;
	my $r = decode_rec($plugin, $rectype, $rec);
	my $newflags = $flags;
	my $newrec = '';
	my $p = 0;
	my $rec_len = length($rec);
	while ($p < $rec_len) {
	    my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	    my $full_type = "${rectype}.${subrec_type}";
	    $p += 8;
	    my $subrec = substr($rec, $p, $subrec_len);
	    $p += $subrec_len;
	    if (defined $subrec) {
		my($hr) = decoder($rectype, $subrec_type)->($subrec);
		my $newsubrec = encoder($rectype, $subrec_type)->($hr);
		unless ($exclude{$full_type}) {
		    if ($newsubrec ne $subrec) {
			warn "CODEC FAILURE on subrecord ${full_type}:\n";
			if (length($newsubrec) != length($subrec)) {
			    warn "Encoded length mismatch: newrec: @{[length($newsubrec)]}  subrec: @{[length($subrec)]}\n";
			}
			dumpit('original', $subrec);
			dumpit('re-coded', $newsubrec);
			warn Dumper($hr);
			$print_rec ||= rec_to_string($rec, $rectype, $id, $plugin, $flags, $unk);
			warn "Full Record:\n$print_rec\n";
			die "Test Halted\n" unless ($opt_codectest_continue);
		    }
		}
		$newrec .= pack("a4L/a*", $subrec_type, $newsubrec);
	    } else {
		warn "$plugin: Error, malformed subrec for ($rectype) type=$subrec_type pos=$p len=$subrec_len\n";
	    }
	}
	unless ($exclude{$rectype}) {
	    if ($rec ne $newrec) {
		warn "CODEC FAILURE on record ${rectype}:\n";
		dumpit('original', $rec);
		dumpit('re-coded', $newrec);
		$print_rec ||= rec_to_string($rec, $rectype, $id, $plugin, $newflags, $unk);
		warn "Full Record:\n$print_rec\n";
	    }
	    if ((my $new_hdr = pack("a4LLL", $rectype, length($rec), $unk, $newflags)) ne $rec_hdr) {
		warn "CODEC FAILURE on ${rectype} Record Header:\n";
		dumpit('original', $rec_hdr);
		dumpit('re-coded', $new_hdr);
		$print_rec ||= rec_to_string($rec, $rectype, $id, $plugin, $newflags, $unk);
		warn "Full Record:\n$print_rec\n";
	    }
	}
	return($newrec, $newflags);
    };
    process_plugin_for_update($plugin, $fun, "test_");
} # cmd_codectest

sub cmd_wikiout {
    foreach my $cmd (sort keys %CMDS) {
	next if (($cmd eq 'help') or ($cmd =~ /^-/));
	my $usage = eval "\$@{[uc $cmd]}_USAGE";
	$usage =~ s/'/''/g;
	print "==$cmd==\n{{{\n$usage\n}}}\n\n";
    }
}

sub cmd_multipatch {
    find_datadir();
    print "Data Files is: $DATADIR\nScanning Active Plugins...\n";
    my $patch_file = "multipatch.esp";
    my $patch_path = "$DATADIR/$patch_file";
    my %fogcell;		# fogbugged cells
    my %rencell;		# cells with reverted renamings
    foreach my $plugin (load_order()) {
	next if ($plugin eq $patch_file);
	next if (($plugin eq "fogpatch.esp") or ($plugin eq "cellnamepatch.esp"));
	print "Scanning plugin: $plugin\n" if (DBG);
	my $inp = open_for_read("$DATADIR/$plugin");
	my $expected = "TES3";
	eval {
	    while (my($rectype, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
		$expected = undef;
		last if (not defined $rectype);
		if ($rectype eq 'CELL') {
		    my $srh = parse_subrec_hash($rec);
		    my $data = $srh->{DATA}[0];
		    my($flags, $fog_den_data) = unpack("Lx[L]f", $data);
		    if (is_interior($srh)) {
			# only check interior cells for fogbug
			unless ($flags & 128) { # behave like exterior
			    my $name = chop_nulls($srh->{NAME}[0]);
			    my $ambi = $srh->{AMBI}[0];
			    my $fog_den_ambi;
			    my $ambilen = length($ambi);
			    if ($ambilen == 16) {
				my $fog_den_ambi = unpack("x[L3]f", $ambi);
				if ($fog_den_ambi != $fog_den_data) {
				    $fog_den_data = 0.0 if ($fog_den_ambi == 0.0);
				    print "Warning, Fog Density in DATA ($fog_den_data) != AMBI ($fog_den_ambi)\n" if ($fog_den_data == 0.0);
				}
				if (0.0 == $fog_den_data) {
				    print "FOGBUG: $plugin\t\tCELL: $name\n";
				    $fogcell{$name} = [$data, $ambi, $plugin];
				} else {
				    if (defined($fogcell{$name})) {
					print qq{\t$plugin CORRECTED fogbug in CELL: $name\n};
					delete $fogcell{$name};
				    }
				}
			    } else {
				print "Error: $plugin, CELL: $name, len(AMBI) subrec $ambilen != 16, skipping\n"
				    if ($ambilen != 0);
			    }
			}
		    } else {
			# only check exterior cells for rename reversion problem
			my $name = chop_nulls($srh->{NAME}[0]);
			my $coord = join(", ", unpack("x[L]ll", $srh->{DATA}[0]));
			if (exists $rencell{$coord}->{NAME}) {
			    my $prevname = $rencell{$coord}->{NAME};
			    if ($prevname ne $name) {
				if ($name eq $rencell{$coord}->{ORIGNAME}) {
				    print qq{CELL: ($coord) RENAME REVERTED by: [$plugin] from: "$prevname" to: "$name". Reversion will be undone.\n};
				    $rencell{$coord}->{OUTPUTFLAG}++;
				} elsif ($name) {
				    print qq{CELL: ($coord) Renamed by: [$plugin] from: "$prevname" to: "$name"\n};
				    my $prevname = $rencell{$coord}->{NAME};
				    my $prevplug = $rencell{$coord}->{PLUG};
				    print qq{CELL: ($coord) Replacing: [$prevplug]:"$prevname" with: [$plugin]:"$name"\n};
				    my $newrec = subrec("NAME", "$name\000") . subrec("DATA", $data);
				    $rencell{$coord}->{NAME} = $name;
				    $rencell{$coord}->{PLUG} = $plugin;
				    $rencell{$coord}->{REC} = [$rectype, $newrec, $flags, $unk];
				} else {
				    print qq{CELL: ($coord) Skipping null name: [$plugin]:"$name"\n};
				}
			    }
			} else {
			    $rencell{$coord}->{ORIGNAME} = $name;
			    $rencell{$coord}->{ORIGPLUG} = $plugin;
			    $rencell{$coord}->{NAME} = $name;
			    $rencell{$coord}->{PLUG} = $plugin;
			}
		    }
		}
	    }
	};
	print $@ if ($@);
	close($inp);
    }
    my $fogbugs = scalar keys %fogcell;
    my $renrevs = scalar keys %rencell;
    if ($fogbugs or $renrevs) {
	my $out = open_for_write($patch_path);
	if ($renrevs) {
	    print "\nPreserving the following CELL renamings:\n";
	    print $out make_header({description => "MultiPatch\n\nVersion: $::VERSION"});
	    foreach my $coord (%rencell) {
		if ($rencell{$coord}->{OUTPUTFLAG}) {
		    my $recref = $rencell{$coord}->{REC};
		    if ($recref) {
			print qq{  CELL: ($coord) -> NAME: "$rencell{$coord}->{NAME}"\n};
			write_rec($out, @{$recref});
		    }
		}
	    }
	}
	if ($fogbugs) {
	    print qq{\nPatching $fogbugs fogbugged cells:\n};
	    foreach my $name (sort keys %fogcell) {
		my($data, $ambi, $plugin) = @{$fogcell{$name}};
		print "  CELL: $name\t\t[$plugin]\n";
		# put in a non-zero fog density
		substr($data, 8, 4) = substr($ambi, 12, 4) = pack("f", 0.01);
		# write NAME, DATA, AMBI
		my $newrec = subrec("NAME", "$name\000") . subrec("DATA", $data) . subrec("AMBI", $ambi);
		write_rec($out, 'CELL', $newrec);
	    }
	}
	close($out);
	$opt_header_update_record_count = 1;
	update_header($patch_path, QUIET);
    } else {
	print qq{\nNo patching necessary. "multipatch.esp" not generated.\n};
    }
} # cmd_multipatch

sub cmd_overdial {
    my(@plugins) = @_;
    my %dialog;
    foreach my $plugin (@plugins) {
	read_dialogs($plugin, \%dialog);
    }
    my @testplugins = ($opt_overdial_single) ? ($plugins[0]) : sort keys %dialog;
    foreach my $plugin1 (sort keys %dialog) {
	foreach my $plugin2 (@testplugins) {
	    if ($plugin1 ne $plugin2) {
		foreach my $id1 (keys %{$dialog{$plugin1}}) {
		    foreach my $id2 (keys %{$dialog{$plugin2}}) {
			if (length($id1) > length($id2) and $id1 =~ /\b$id2\b/i) {
			    printf qq{%-40s "$id1"\n%-40s "$id2"\n\n}, "$plugin1:", "$plugin2:";
			}
		    }
		}
	    }
	}
    }
}

# find objects in common between 2 plugins
sub cmd_common {
    my($plugin1, $plugin2) = @_;
    # swap plugins if plugin1 is larger than plugin2
    ($plugin1, $plugin2) = ($plugin2, $plugin1)
	if (-s $plugin1 > -s $plugin2);
    # read objects from smaller plugin
    my $objects1 = read_objects($plugin1);
    # compare to objects second plugin
    my $compare_fun = sub {
	my($rectype, $id) = @_;
	if ($objects1->{$rectype}->{$id} and ($rectype ne 'TES3')) {
	    warn "  $rectype: $id\n";
	}
    };
    read_objects($plugin2, $compare_fun);
}

sub output_diff {
    my($diff_file, $diff) = @_;
    if (@{$diff}) {
	my $fh = IO::Handle->new();
	if (open($fh, ">$diff_file")) {
	    print $fh join("\n", @{$diff});
	    close($fh);
	} else {
	    warn "Error opening $diff_file for output ($!)\n";
	}
    }
}

sub cmd_diff {
    my($plugin1, $plugin2) = @_;
    my $ignore;
    if (@opt_diff_ignore_type) {
	$ignore = '^(\s+(?:' . join('|', @opt_diff_ignore_type) . '):)\s.*$';
    }
    warn "IGNORE = $ignore\n" if (DBG);
    my $obj1 = read_objects($plugin1);
    my $obj2 = read_objects($plugin2);
    my @p1_not_p2;	     # objects in plugin1 that do not exist in plugin2
    my @p2_not_p1;	     # objects in plugin2 that do not exist in plugin1
    my @p1_equal_p2;	     # objects in plugin1 that are equal in plugin2
    my @p1_diff_p2;	     # objects in plugin1 that are different in plugin2
    my @diffs;		     # detailed diffs
    my(@diff1, @diff2);
    foreach my $rectype (sort keys %{$obj1}) {
	next if ($rectype eq 'TES3');
	foreach my $id (sort keys %{$obj1->{$rectype}}) {
	    if (defined(my $rec2 = $obj2->{$rectype}->{$id})) {
		my $rec1 = $obj1->{$rectype}->{$id};
		my $print_rec1 = rec_to_string($rec1, $rectype, $id, $plugin1);
		$print_rec1 =~ s/$ignore/$1 (IGNORED)/gmi if ($ignore);
		$print_rec1 =~ s/CELL.FRMR: ObjIdx: \d+ ModIdx: 0/CELL.FRMR: ObjIdx: (IGNORED) ModIdx: 0/gm;
		my $print_rec2 = rec_to_string($rec2, $rectype, $id, $plugin2);
		$print_rec2 =~ s/$ignore/$1 (IGNORED)/gmi if ($ignore);
		$print_rec2 =~ s/CELL.FRMR: ObjIdx: \d+ ModIdx: 0/CELL.FRMR: ObjIdx: (IGNORED) ModIdx: 0/gm;
		if ($print_rec1 eq $print_rec2) {
		    push(@p1_equal_p2, "$rectype: $id") if ($opt_diff_equal);
		} elsif ($opt_diff_not_equal) {
		    push(@p1_diff_p2, "$rectype: $id");
		    push(@diff1, "\n$rectype: $id");
		    push(@diff1, $print_rec1);
		    push(@diff2, "\n$rectype: $id");
		    push(@diff2, $print_rec2);
		}
	    } else {
		push(@p1_not_p2, "$rectype: $id") if ($opt_diff_1_not_2);
	    }
	}
    }
    foreach my $rectype (sort keys %{$obj2}) {
	foreach my $id (sort keys %{$obj2->{$rectype}}) {
	    unless (defined $obj1->{$rectype}->{$id}) {
		push(@p2_not_p1, "$rectype: $id") if ($opt_diff_2_not_1);
	    }
	}
    }
    # now print the diff report
    if ($opt_diff_1_not_2 and my $n = @p1_not_p2) {
	print qq{\nRecords in "$plugin1" not in "$plugin2" ($n):\n};
	foreach (@p1_not_p2) { print "$_\n"; }
    }
    if ($opt_diff_2_not_1 and my $n = @p2_not_p1) {
	print qq{\nRecords in "$plugin2" not in "$plugin1" ($n):\n};
	foreach (@p2_not_p1) { print "$_\n"; }
    }
    if ($opt_diff_equal and my $n  = @p1_equal_p2) {
	print qq{\nRecords that are equal in "$plugin1" and "$plugin2" ($n):\n};
	foreach (@p1_equal_p2) { print "$_\n"; }
    }
    if ($opt_diff_not_equal) {
	my $diff1_file = fileparse($plugin1) . ".diff"; # get file basename
	my $diff2_file = fileparse($plugin2) . ".diff"; # get file basename
	if (my $n = @p1_diff_p2) {
	    print qq{\nRecords that are different between "$plugin1" and "$plugin2" ($n):\n(Compare $diff1_file to $diff2_file)\n};
	    foreach (@p1_diff_p2) {
		print "$_\n";
	    }
	}
	output_diff($diff1_file, \@diff1);
	output_diff($diff2_file, \@diff2);
    }
} # cmd_diff

sub cmd_delete {
    my($plugin) = @_;
    my $delete_subrecords = $opt_sub_match or $opt_sub_no_match;
    my $delete_cell_objects = $opt_cell_object_match or $opt_cell_object_no_match;
    my $fun = sub {
	my($rec_match, $rectype, $id, $rec, $srh, $flags, $unk, $rec_hdr, $print_rec) = @_;
	# we pass through all records that did not match the standard record selection switches of rec_match()
	return($rec, $flags) unless ($rec_match);
	if ($delete_subrecords) {
	    # we are processing sub-records
	    my $newrec = '';
	    foreach my $subr (@{parse_subrec_list($rec)}) {
		my($subtype, $subrec) = @{$subr};
		my $subrec_str = ($TOSTR{"$rectype.$subtype"} || $TOSTR{$subtype} || $TOSTR_UNK)->($subrec);
		if ($opt_sub_match or $opt_sub_no_match) {
		    if (((not $opt_sub_match) or ($subrec_str =~ /$opt_sub_match/i)) and
			((not $opt_sub_no_match) or ($subrec_str !~ /$opt_sub_no_match/i))) {
			print "[$rectype $id] DELETED SUBRECORD: $subrec_str\n";
		    } else {
			$newrec .= pack("a4L/a*", $subtype, $subrec);
		    }
		}
	    }
	    return($newrec, $flags);
	} elsif ($delete_cell_objects) {
	    my $newrec = '';
	    if ($rectype eq 'CELL') {
		my($cellhdr, $objs, $objidx) = parse_cell_objects($rec);
		my @new_objs;
		warn "objs: " . Dumper($objs) . "\n";
		foreach my $obj (@$objs) {
		    if ($obj eq 'NAM0') { push(@new_objs, $obj); next; }
		    my $objstr;
		    foreach my $subr (@{parse_subrec_list($obj->[1])}) {
			my($subtype, $subrec) = @{$subr};
			my $tostr = ($TOSTR{"$rectype.$subtype"} || $TOSTR{$subtype} || $TOSTR_UNK)->($subrec);
			$objstr .= "$subtype: $tostr\n";
		    }
		    warn "objstr = $objstr\n";
		    if (((not $opt_cell_object_match) or ($objstr =~ /$opt_cell_object_match/i)) and
			((not $opt_cell_object_no_match) or ($objstr !~ /$opt_cell_object_no_match/i))) {
			my $obj_info = chop_nulls(parse_subrec_hash($obj->[1])->{NAME}[0]) . " FRMR:" . $obj->[0]->[0];
			print "[CELL: $id] DELETED CELL OBJECT: $obj_info\n";
		    } else {
			push(@new_objs, $obj);
		    }
		}
		$newrec = assemble_cell_objects($cellhdr, \@new_objs);
	    } else {
		return($newrec, $flags);
	    }
	} else {
	    # we are deleting whole records
	    $print_rec ||= rec_to_string($rec, $rectype, $id, $plugin);
	    print "\nDELETED RECORD:$print_rec\n";
	    return(undef);
	}
    };
    process_plugin_for_update($plugin, $fun);
} # cmd_delete

sub cmd_modify {
    my($plugin) = @_;
    # load Perl program if specified with --program-file
    if ($opt_modify_program_file) {
	unless (do $opt_modify_program_file) {	# execute perl file
	    die "Error processing $opt_modify_program_file ($@)\n" if ($@);
	}
	$opt_modify_run = 'main($rectype, $r, $flags, $unk);' unless ($opt_modify_run);
    }
    $opt_match ||= '.'; 		# default is to match any record.
    my($inp, $out) = make_temp($plugin);
    my $expected = "TES3";
    my($wanted_ids, $wanted_types, $wanted_flags) = get_wanted();
    my $modified = 0;
    eval {
	while (my($rectype, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if (not defined $rectype);
	    next if ($wanted_flags and not ($flags & $wanted_flags));
	    warn "REC=$rectype flags=$flags\n" if (DBG);
	    my $nomodify = 0;
	    my $recid;
	    my $srh;
	    if ($wanted_ids) {
		$srh ||= parse_subrec_hash($rec);
		$recid = rec_id($srh, $rectype);
		$nomodify = 1 if ($recid !~ /$wanted_ids/i);
	    }
	    $nomodify = 1 if ($wanted_types and not $wanted_types->{$rectype});
	    if ($nomodify) {
		write_rec($out, $rectype, $rec, $flags, $unk);
		next;
	    }
	    if ($rectype eq 'CELL') {
		$srh ||= parse_subrec_hash($rec);
		if (is_interior($srh)) {
		    next if ($opt_exterior);
		} else {
		    next if ($opt_interior);
		}
	    }
	    my $p = 0;
	    my $rec_len = length($rec);
	    my $first = 1;
	    my $print_rec = "";
	    my $newrec = "";
	    my @subrecs = ();
	    while ($p < $rec_len) {
		my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
		$p += 8;
		my $subrec = substr($rec, $p, $subrec_len);
		$p += $subrec_len;
		if (defined $subrec) {
		    my $full_type = "${rectype}.${subrec_type}";
		    unless ($wanted_types and not $wanted_types->{$rectype}) {
			my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type} || $TOSTR_UNK;
			my($hr) = decoder($rectype, $subrec_type)->($subrec);
			my $subrec_str = $tostr->($subrec);
			if ($opt_sub_match or $opt_sub_no_match) {
			    if (((not $opt_sub_match) or ($subrec_str =~ /$opt_sub_match/i)) and
				((not $opt_sub_no_match) or ($subrec_str !~ /$opt_sub_no_match/i))) {
				# subrecord matches, so run our code on it ...
				warn "full_type=$full_type\n";
				if (my $newhr = run_code($full_type, $hr)) {
				    my $encoder = encoder($rectype, $subrec_type);
				    $subrec = $encoder->($newhr);
				    $modified++;
				    $subrec_str = $tostr->($subrec);
				    warn "MODIFIED SUBRECORD: $subrec_str\n";
				} else {
				    $subrec = undef;
				}
			    }
			}
			push(@subrecs, [$subrec_type, $hr]);
			$print_rec .= "   $full_type: $subrec_str\n";
		    }
		    $newrec .= pack("a4La*", $subrec_type, $subrec_len, $subrec);
		} else {
		    my $id = rec_id(parse_subrec_hash($rec), $rectype);
		    warn "$plugin: Error, malformed subrec for ($rectype $id) type=$subrec_type pos=$p len=$subrec_len\n";
		}
	    }
	    if ($opt_sub_match or $opt_sub_no_match) {
		write_rec($out, $rectype, $newrec, $flags, $unk);
	    } else {
		if (((not $opt_match) or ($print_rec =~ /$opt_match/i)) and
		    ((not $opt_no_match) or ($print_rec !~ /$opt_no_match/i))) {
		    $R = \@subrecs;
		    if (my $modrec = run_code($rectype, $flags, $unk)) {
			#warn "Record was modified, encoding modified record\n";
			my $newrec = '';
			$newrec = encode_rec($rectype, $modrec);
			if ($newrec ne $rec) {
			    $rec = $newrec;
			    my $id = rec_id(parse_subrec_hash($rec), $rectype);
			    warn "MODIFIED RECORD:\n" . rec_to_string($rec, $rectype, $id, $plugin) . "\n";
			    $modified++;
			}
		    }
		}
		write_rec($out, $rectype, $rec, $flags, $unk);
	    }
	}
    };
    if ($@) {
	warn $@;
	$modified = 0;
    }
    fix_output($inp, $out, $plugin, $modified);
} # cmd_modify

sub cmd_rename {
    my($plugin) = @_;
    my($inp, $out) = ($opt_report_only) ? open_for_read($plugin) : make_temp($plugin);
    my $modified = 0;
    unless ($opt_report_only) {
	warn "\n$plugin: RENAMING Records:\n";
    }
    my $expected = "TES3";
    eval {
	while (my($rectype, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if (not defined $rectype);
	    warn "REC=$rectype flags=$flags\n" if (DBG);
	    if ($rectype eq 'SCPT') {
		my $renamed_schd = 0;
		my $renamed_sctx = 0;
		my $srl = parse_subrec_list($rec);
		foreach my $subrec (@{$srl}) {
		    my $subtype = $subrec->[0];
		    if ($subtype eq "SCHD") {
			my($name, @schd_longs) = unpack("Z32L5", $subrec->[1]);
			if ($opt_report_only) { # only list records
			    printf qq{  $rectype.$subtype  %-30s\n}, $name;
			} else {
			    my $newname;
			    eval qq{(\$newname = \$name) =~ s!$RENAME_FROM!$RENAME_TO!g};
			    if (length($newname) < 32) {
				if ($name ne $newname) {
				    $subrec->[1] = pack("a32L5", $newname, @schd_longs);
				    $renamed_schd = 1;
				    printf qq{    Renaming: $rectype.$subtype %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
				}
			    } else {
				warn qq{New name for script: "$newname" is too long, must be less than 32 bytes\n};
			    }
			}
		    } elsif ($subtype eq "SCTX") {
			my $script = $subrec->[1];
			my $name = ($script =~ m!^[^;]*?\bbegin\s+(\S+)!im) ? $1 : "unknown";
			if ($opt_report_only) { # only list records
			    printf qq{  $rectype.$subtype  %-30s\n}, $name;
			} else {
			    my $newname;
			    eval qq{(\$newname = \$name) =~ s!$RENAME_FROM!$RENAME_TO!g};
			    if ($name ne $newname) {
				$script =~ s/^[^;]*?\bbegin\s+(\S+)/Begin $newname/im;
				$subrec->[1] = $script;
				$renamed_sctx = 1;
				printf qq{    Renaming: $rectype.$subtype %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			    }
			}
		    }
		}
		unless ($opt_report_only) {
		    if ($renamed_schd and $renamed_sctx) {
			$modified++;
			$rec = new_rec($srl);
		    } else {
			my $what = "";
			$what .= " SCHD" unless $renamed_schd;
			$what .= " SCTX" unless $renamed_sctx;
			warn "Error renaming$what, record NOT updated.\n";
		    }
		}
	    } elsif ($rectype eq $RENAME_TYPE) {
		my $renamed = 0;
		my $srl = parse_subrec_list($rec);
		my $name_idx = ($srl->[0]->[0] eq 'NAME') ? 0 : undef;
		if (defined($name_idx) and
		    my $name = chop_nulls($srl->[$name_idx]->[1])) {
		    if ($opt_report_only) { # only list records
			my $recstr = pprec($rec, $RENAME_SUBTYPE);
			printf qq{  $rectype  %-30s [%s]\n}, $name, $recstr;
		    } else {	# rename records
			my $do_rename = 1;
			$do_rename = 0 if ($rectype eq "CELL" and not allowed_cell_type($srl));
			if ($do_rename) {
			    my $newname;
			    eval qq{(\$newname = \$name) =~ s!$RENAME_FROM!$RENAME_TO!g};
			    if ($name ne $newname) {
				$srl->[$name_idx]->[1] = "$newname\000";
				$renamed = 1;
				$modified++;
				printf qq{    Renaming: $RENAME_TYPE %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			    }
			}
		    }
		} else {
		    warn "Error, Record has no $RENAME_SUBTYPE subrecord: $rec\n";
		}
		$rec = new_rec($srl) if $renamed;
	    }
	    write_rec($out, $rectype, $rec, $flags, $unk) unless ($opt_report_only);
	}
    };
    if ($@) {
	warn $@;
	$modified = 0;
    }
    if ($opt_report_only) {
	cleanup_temp($inp, $plugin);
    } else {
	fix_output($inp, $out, $plugin, $modified);
    }
} # cmd_rename

sub cmd_header {
    my($plugin) = @_;
    if ($opt_header_author or $opt_header_description or $opt_header_update_record_count or $opt_header_update_masters) {
	# if updating make backup of plugin before making changes
	my $backup = unique_backup_name($plugin);
	copy($plugin, $backup) or die "Error, copy failed $plugin -> $backup ($!)\n";
    }
    update_header($plugin);
}

sub convert_plugin {
    my($input) = @_;
    my $output;
    my $byte_expected;
    my $byte_new;
    if ($input =~ /\.esp$/i) {
	# convert plugin to master
	$byte_expected = "\000";
	$byte_new = "\001";
	($output = $input) =~ s/\.esp$/.esm/i;
    } else {
	# convert master to plugin
	$byte_expected = "\001";
	$byte_new = "\000";
	($output = $input) =~ s/\.esm$/.esp/i;
    }
    die qq{Error, $output already exists! (Use --overwrite to overwrite)\n}
	if (-f $output and not $opt_overwrite);
    copy($input, $output) or die "Error, copy failed $input -> $output ($!)\n";
    eval {
	open(OUT, "+<$output") or die qq{Error opening "$output" for read/write ($!)};
	binmode(OUT) or die "Error setting binmode on $output ($!)";
	my $magic;
	(sysread(OUT, $magic, 4) == 4) or die "$output: Error reading magic ($!)";
	if ($magic eq "TES3") {
	    sysseek(OUT, 28, SEEK_SET) or die "sysseek";
	    my $byte;
	    (sysread(OUT, $byte, 1) == 1) or die "$output: Error reading master byte ($!)\n";
	    my $val = unpack("C", $byte);
	    #warn "masterbyte = $val\n";
	    ($byte eq $byte_expected) or
		die qq{Error, expected master byte value of @{[unpack("C",$byte_expected)]}, got $val instead};
	    sysseek(OUT, 28, SEEK_SET) or die "sysseek";
	    (syswrite(OUT, $byte_new, 1) == 1) or die "$output: Error writing master byte ($!)\n";
	} elsif ($magic eq "TES4") {
	    die "This function is not yet implemented for TES4 files";
	} else {
	    die "$output: Error, this does not appear to be Morrowind plugin";
	}
	close(OUT);
    };
    if ($@) {
	warn "$@\n";
	close(OUT);
	unlink($output);
	return;
    }
    my($atime, $mtime) = (stat($input))[8,9];
    utime($atime, $mtime, $output);
    warn "$input copied to $output\n"
} # convert_plugin

# convert a master to a plugin
sub cmd_esp {
    my($master) = @_;
    die "Error, input must be a master (.esm)\n"
	unless ($master =~ /\.esm$/i);
    convert_plugin($master);
}

# convert a plugin to a master
sub cmd_esm {
    my($plugin) = @_;
    die "Error, input must be a plugin (.esp)\n"
	unless ($plugin =~ /\.esp$/i);
    convert_plugin($plugin);
}

my %gmst_type = ('i' => 'INTV', 'f' => 'FLTV', 's' => 'STRV');
sub cmd_clean {
    my($plugin) = @_;
    if ($plugin =~ /\.ess$/) {
	warn "Don't know how to clean savegames: $plugin ... yet\n";
	return;
    }
    if ($plugin =~ /^(Morrowind|Tribunal|Bloodmoon)\.esm$/i) {
	warn "Skipping Bethesda Master: $plugin\n";
	return;
    }
    if ($plugin =~ /^GMST (Fix|Vaccine)\.esp$/i) {
	warn "Skipping plugin that intentionally contain Evil GMSTs: $plugin\n";
	return;
    }
    if ($plugin =~ /~\d+\.es[mps]$/i) {
	warn "Skipping Backup: $plugin\n";
	return;
    }
    print qq{\nCLEANING: "$plugin" ...\n};
    my %duptype;
    $duptype{$_}++ foreach (@CLEAN_DUP_TYPES);
    my %my_master;
    my $fun = sub {
	my($rec_match, $rectype, $id, $rec, $srh, $flags, $unk) = @_;
	my $newrec = $rec;
	my $newflags = $flags;
	my $r;
	if ($rectype eq 'GMST') {
	    if ($opt_clean_gmsts) {
		my $type = $gmst_type{substr($id, 0, 1)};
		my $val = $srh->{$type}[0];
		my $hexval = unpack("H*", "$type $val");
		if ($EVIL_BM{$id} eq $hexval) {
		    print " Cleaned Evil GMST Bloodmoon: $id\n";
		    return;
		} elsif ($EVIL_TB{$id} eq $hexval) {
		    print " Cleaned Evil GMST Tribunal:  $id\n";
		    return;
		}
	    }
	} elsif ($rectype eq 'CELL') {
	    my $cleaned_ambi;
	    my $cleaned_whgt;
	    my $plug_srl;
	    if ($opt_clean_cell_objects) {
		# CLEAN CELL OBJECTS
		my($p_hdr, $p_objs, $p_objidx) = parse_cell_objects($rec);
		my @new_objs;
		foreach my $obj (@$p_objs) {
		    if ($obj eq 'NAM0') { push(@new_objs, $obj); next; }
		    my $object_body = $obj->[1];
		    my $cleaned_obj = 0;
		    foreach my $master (keys %{my_master}) {
			if (my $lref = $MASTER_ID->{$master}->{$id}->{CELL}) {
			    my($mast_srh, $mast_rec) = @{$lref};
			    my($m_hdr, $m_objs, $m_objidx) = parse_cell_objects($mast_rec);
			    if ($m_objidx->{$object_body}->[0] == $obj->[0]->[0]) { # compare master and plugin FRMR object indices
				$cleaned_obj++;
				last;
			    }
			}
		    }
		    if ($cleaned_obj) {
			my $obj_info = chop_nulls(parse_subrec_hash($obj->[1])->{NAME}[0]) . " FRMR:" . $obj->[0]->[0];
			print " Cleaned redundant object ($obj_info) from CELL: $id\n";
		    } else {
			push(@new_objs, $obj);
		    }
		}
		if (scalar(@new_objs) != scalar(@$p_objs)) {
		    $rec = assemble_cell_objects($p_hdr, \@new_objs);
		    $r = decode_rec($plugin, $rectype, $rec);
		    $plug_srl = parse_subrec_list($rec);
		}
	    }
	    # we check plugin against all masters, as we can't know with which masters the author created it
	    # and ideally, we don't want the result of cleaning to be dependent on load order.
	    foreach my $master (keys %{my_master}) {
		if (my $lref = $MASTER_ID->{$master}->{$id}->{CELL}) {
		    my($mast_srh, $mast_rec) = @{$lref};
		    if (is_interior($srh)) {
			if ($opt_clean_cell_params) { # check for redundant AMBI/WHGT
			    # CLEAN AMBI
			    $r ||= decode_rec($plugin, $rectype, $rec);
			    unless ($cleaned_ambi) {
				if (defined($srh->{AMBI}) and ($srh->{AMBI}[0] eq $mast_srh->{AMBI}[0])) {
				    $r = remove_subrec($r, 'AMBI');
				    $cleaned_ambi++;
				}
			    }
			    # CLEAN WHGT
			    # (some plugins, like Morrowind.esm, use an INTV subrecord instead of WHGT)
			    unless ($cleaned_whgt) {
				my $plugin_whgt = (defined($srh->{WHGT}) and $srh->{WHGT}[0]) ? unpack("f", $srh->{WHGT}[0]) : undef;
				my $whgt_type = 'WHGT';
				unless (defined $plugin_whgt) {
				    $plug_srl ||= parse_subrec_list($rec);
				    if ($plug_srl->[2]->[0] eq 'INTV') {
					# this would be unusual. I think INTV water heights must be from very old Construction Sets.
					$plugin_whgt = unpack("l", $plug_srl->[2]->[1]);
					$whgt_type = 'INTV';
				    }
				}
				my $master_whgt = ($mast_srh->{WHGT}[0]) ? unpack("f", $mast_srh->{WHGT}[0]) : undef;
				unless (defined $master_whgt) {
				    my $mast_srl = parse_subrec_list($mast_rec);
				    if ($mast_srl->[2]->[0] eq 'INTV') {
					$master_whgt = unpack("l", $mast_srl->[2]->[1]);
				    }
				}
				if (defined($plugin_whgt) and defined($master_whgt) and ($plugin_whgt == $master_whgt)) {
				    $r = remove_subrec($r, $whgt_type, 1);
				    $cleaned_whgt++;
				}
			    }
			}
		    }
		    if ($opt_clean_junk_cells) {
			if ((scalar keys %{$srh}) < 4) {
			    # junk cells always contain less than 4 subrecords
			    my $modified = 0;
			    for my $type (keys %{$srh}) {
				if (not $JUNKCELL_SUBTYPE{$type} or
				    $srh->{$type}[0] ne $mast_srh->{$type}[0]) {
				    # record contains subrecords or some modified data, so it isn't junk
				    $modified++;
				    last;
				}
			    }
			    unless ($modified) {
				print " Cleaned Junk CELL:  $id\n";
				return;
			    }
			}
		    }
		}
	    }
	    my @what;
	    push(@what, 'AMBI') if ($cleaned_ambi);
	    push(@what, 'WHGT') if ($cleaned_whgt);
	    if (@what) {
		print " Cleaned redundant " . join(',', @what) . " from CELL: $id\n";
	    }
	} elsif ($rectype eq 'TES3') {
	    foreach my $mast (@{$srh->{MAST}}) {
		my $master = chop_nulls($mast);
		$my_master{lc($master)}++;
		load_master($master);
	    }
	}
	if ($opt_clean_dups) {
	    foreach my $master (keys %{my_master}) {
		if (my $lref = $MASTER_ID->{$master}->{$id}->{$rectype}) {
		    my($mast_srh, $mast_rec, $mast_flags) = @{$lref};
		    if ($duptype{$rectype} and ($rec eq $mast_rec) and ($flags eq $mast_flags)) {
			print " Cleaned Duplicate $rectype:  $id\n";
			return;
		    }
		}
	    }
	}
	$newrec = encode_rec($rectype, $r) if ($r); # update record buffer if we have modified it
	return($newrec, $newflags);
    };
    if ($opt_clean_replace) {
	process_plugin_for_update($plugin, $fun);
    } else {
	process_plugin_for_update($plugin, $fun, "Clean_");
    }
} # cmd_clean

sub cmd_dump {
    my($plugin) = @_;
    my $dump_banner;
    unless ($opt_no_banner) {
	$dump_banner = "\nPlugin: $plugin\n";
	$dump_banner = "#(Dump_Version: $DUMP_VERSION)\n$dump_banner" if ($opt_dump_canon);
    }
    my $fun = sub {
	my($rec_match, $rectype, $id, $rec, $srh, $flags, $unk, $rec_hdr, $print_rec) = @_;
	return unless ($rec_match);
	my $unkstr = (DBG) ? sprintf("  Unk:%04x", $unk) : '';
	my $flagstr = decode_flags($flags, \%REC_FLAGS);
	if ($dump_banner) {
	    print $dump_banner;
	    $dump_banner = "";
	}
	if ($opt_dump_canon) {
	    # print new canonical dump format
	    my $dial_str = ($rectype eq 'INFO') ? " $CURRENT_DIAL" : '';
	    print qq{\nRecord: $rectype "$id"$dial_str Flags: $flagstr${unkstr}\n};
	    dumprec(decode_rec($plugin, $rectype, $rec));
	} else {
	    # do the old "print" style
	    $print_rec ||= rec_to_string($rec, $rectype, $id, $plugin, $flags, $unk);
	    if ($opt_list) {
		if ($rectype eq 'CELL') {
		    my $objcnt = (defined $srh->{FRMR}) ? scalar(@{$srh->{FRMR}}) : 0;
		    printf "$rectype: %-45s\t%5d objects\n", $id, $objcnt;
		} else {
		    print "$rectype: $id\n";
		}
	    } elsif ($opt_dump_raw) {
		if ($opt_cell_object_match and ($rectype eq 'CELL')) {
		    my @frmr_data;
		    my $frmr_match = 0;
		    my $srl = parse_subrec_list($rec);
		    my @newrec = ();
		    my $first_frmr_seen = 0;
		    my $subrec_str = '';
		    my $tostr;
		    while (@$srl) {
			my $subrecref = shift(@$srl);
			my($subtype, $subrec) = @$subrecref;
			$tostr = $TOSTR{"CELL.$subtype"} || $TOSTR{$subtype};
			$subrec_str .= $tostr->($subrec);
			if ($first_frmr_seen) {
			    if ($subtype eq 'FRMR') {
				if ($subrec_str =~ /$opt_cell_object_match/i) {
				    $frmr_match++;
				    push(@newrec, @frmr_data);
				}
				$subrec_str = '';
				@frmr_data = (); # start a new group
			    }
			    push(@frmr_data, pack("a4L/a", $subtype, $subrec));
			} else {
			    if ($subtype eq 'FRMR') {
				$first_frmr_seen = 1;
				push(@frmr_data, pack("a4L/a", $subtype, $subrec));
			    } else {
				push(@newrec, pack("a4L/a", $subtype, $subrec));
			    }
			}
		    }
		    if ($subrec_str =~ /$opt_cell_object_match/i) {
			$frmr_match++;
			push(@newrec, @frmr_data);
		    }
		    if ($frmr_match) {
			my $newrec = join("", @newrec);
			print $RAWOUT pack("a4LLLa*", $rectype, length($newrec), $unk, $flags, $newrec);
		    }
		} else {
		    print $RAWOUT pack("a4LLLa*", $rectype, length($rec), $unk, $flags, $rec);
		}
	    } else {
		print "\n$print_rec\n" if ($print_rec);
	    }
	}
    };
    process_plugin_for_read($plugin, $fun);
} # cmd_dump

sub cmd_recover {
    my($plugin) = @_;
    my($inp, $out) = make_temp($plugin);
    my $typlen = $RECTYPE_LEN - 1;
    my $buff;
    my $buff_size = 4096;
    my $expected = "TES3";
    my $inp_len = sysseek($inp, 0, SEEK_END); # seek to end
    my $inp_offset = sysseek($inp, 0, SEEK_SET); # seek to start
    my $rectypes = join('|', keys %RECDEF);
    my %valid_type; $valid_type{$_}++ foreach (keys %RECDEF);
    my %valid_subtype; $valid_subtype{$_}++ foreach (@SUBRECTYPES);
    print qq{$plugin: length = $inp_len\n};
    my @removed;
  READREC:
    while ($inp_offset < $inp_len) {
	my($rectype, $rec, $flags, $unk);
	eval {
	    ($rectype, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin);
	    $expected = undef;
	    die "Error, Invalid record type: $rectype\n" unless ($valid_type{$rectype});
	    my $srh = parse_subrec_hash($rec);
	    foreach my $subtype (keys %$srh) {
		die qq{Error, Invalid record subtype: "$subtype"\n} unless ($valid_subtype{$subtype});
	    }
	    my $id = rec_id($srh, $rectype);
	    printf "Offset: %8d  Found: $rectype $id\n", $inp_offset if (DBG);
	};
	if ($@) {
	    warn $@;
	    # start a scan from last input offset for something that looks like a record header
	    my $start_offset = $inp_offset;
	    print qq{READ ERROR on record starting at: $start_offset\n};
	    $inp_offset = sysseek($inp, $inp_offset + 1, SEEK_SET);
	    print qq{Scanning for records from: $inp_offset\n};
	    while (1) {
		my $n_read = sysread($inp, $buff, $buff_size + $typlen);
		last READREC if ($n_read == 0); # EOF
		if (my($stuff, $rectype) = split(/($rectypes)/, $buff)) {
		    my $new_offset = $inp_offset + length($stuff);
		    print qq{Scan found $rectype at: $new_offset\n};
		    $inp_offset = sysseek($inp, $new_offset, SEEK_SET);
		    push(@removed, [$start_offset, $new_offset]);
		    last;
		} else {
		    # Just in case record header started at end boundary, back up by len of rec ID
		    $inp_offset = sysseek($inp,  0 - $typlen, SEEK_CUR) if ($n_read == ($buff_size + $typlen));
		}
	    }
	} else {
	    # everything was AOK
	    write_rec($out, $rectype, $rec, $flags, $unk);
	    $inp_offset = sysseek($inp, 0, SEEK_CUR); # set inp_offset to current seek position
	}
    }
    if (@removed) {
	my $n = scalar(@removed);
	print "Recovery removed $n section@{[($n > 1) ? 's' : '']} of bad data:\n";
	my $total = 0;
	foreach my $chunk (@removed) {
	    my $lost = $chunk->[1] - $chunk->[0];
	    printf "  From: %8d To: %8d  (lost %d bytes)\n",
		$chunk->[0], $chunk->[1], $lost;
	    $total += $lost;
	}
	if (scalar(@removed) > 1) {
	    print "Total bytes lost: $total\n";
	}
	fix_output($inp, $out, $plugin, 1);
    } else {
	print "Recovery found no bad data in $plugin\n";
	cleanup_temp($inp, $plugin);
    }
} # cmd_recover

sub main {
    die $USAGE_ALL if ((scalar(@ARGV) == 0) or
		       (scalar(@ARGV) == 1 and $ARGV[0] =~ /help/i));
    my $cmd_ref;
    my $cmd_name = shift(@ARGV);
    die $USAGE_ALL unless ($cmd_ref = $CMDS{$cmd_name});
    my($cmd_getopts, $cmd, $type) = @{$cmd_ref};
    $cmd_getopts->();
    my @plugins;
    foreach my $arg (@ARGV) {
	if ($arg =~ /[$GLOBCHARS]/) {
	    push(@plugins, glob($arg));
	} else {
	    push(@plugins, $arg);
	}
    }
    if ($opt_output_dir and not -d $opt_output_dir) {
	eval { mkdir($opt_output_dir, 0755); };
	die $@ if ($@);
    }
    if ($type eq 'm') {
	# these commands process multiple plugins at once
	$cmd->(@plugins);
    } else {		    # type eq 's'
	# these commands process a single plugin at a time
	die $USAGE_ALL if (scalar(@plugins) == 0);
	for my $plugin (@plugins) {
	    $cmd->($plugin);
	}
    }
} # main

main();
