#!/usr/bin/perl
#Version: 0.2
# tes3cmd: command line tool to do various hackage on a TES3 plugin
# Copyright 2009 by John Moonsugar
# Distributed as part of the mlox project:
#   http://code.google.com/p/mlox/
# under the MIT License:
#   http://code.google.com/p/mlox/source/browse/trunk/License.txt

use Getopt::Std;
use Data::Dumper;
use strict;

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant DBG => grep(/^(?:-D)$/, @ARGV);
}

my $OVERDIAL_USAGE = q{Usage: tes3cmd overdial OPTIONS plugin...

OPTIONS
 -D   turn on debug output
 -1   only test to see if dialog in the first plugin is overlapped. (by default
      all plugins are checked against all other plugins, which is an n-squared
      operation).

Prints the IDs of dialog records that overlap from the set of given plugins.
An overlap is defined as a dialog (DIAL) Topic from one plugin that entirely
contains a dialog Topic from another plugin. For example, White Wolf of Lokken
has a dialog topic "to rescue me" which overlaps with the dialog topic "rescue
me" from Suran Underworld, which causes the "Special Guest" quest to get stuck
because Ylarra won't offer the topic "rescue me" when you find her in her
cell.

Overlap would only be a problem if the plugins are loaded in the order they
are listed in the output.

Example:

# Show dialog overlaps between Lokken and SU:
tes3cmd overdial BT_Whitewolf_2_0.esm Suran_Underworld_2.5.esp
};

sub opts_overdial {
    $_[0] && do { warn $OVERDIAL_USAGE; exit(0); };
    getopts('1D') or die $OVERDIAL_USAGE;
}


my $COM_USAGE = q{Usage: tes3cmd common OPTIONS plugin1 plugin2

OPTIONS
 -D   turn on debug output

Prints the IDs of records that the 2 given plugins have in common.

Example:

# Show what is common between my plugin and Morrowind.esm:
tes3cmd common myplugin.esp Morrowind.esm
};

sub opts_com {
    $_[0] && do { warn $COM_USAGE; exit(0); };
    getopts('D') or die $COM_USAGE;
}


my $DUMP_USAGE = q{Usage: tes3cmd dump OPTIONS plugin...

OPTIONS
 -D        turn on debug output
 -i ids    only print out the ids matching the given comma-delimited list
           of regular expression patterns.
 -m regex  only print records that match given regular expression.
 -t types  only print out the records matching the given comma-delimted
           list of record types.

Dumps the plugin to stdout in text form for easy perusal. For large plugins,
the output can be voluminous.

Examples:

# Dump all records from a plugin:
tes3cmd dump plugin.esp

# Dump all records whos IDs match "foo":
tes3cmd dump -i foo plugin.esp

# Dump all the CELL records from a plugin:
tes3cmd dump -t cell plugin.esp

# Dump all cells from bradhia_v1_4.esp containing NPC named: "Maeve Jaste"
tes3cmd dump -t cell -m "NAME:.*maeve.jaste" bradhia_v1_4.esp
};

my @CELL_FLAGS = ([0x02, "Has Water"],
		  [0x041, "Illegal to Sleep Here"],
		  [0x80, "Behave like Exterior"]);

my %INFO_FUN = ('sX' => "Global/Local/Not Local types",
		'JX' => "Journal type",
		'IX' => "Item Type",
		'DX' => "Dead Type",
		'XX' => "Not ID Type",
		'FX' => "Not Faction",
		'CX' => "Not Class",
		'RX' => "Not Race",
		'LX' => "Not Cell");

my %INFO_SCVR_type =
    ('0' => "Nothing",
     '1' => "Function",
     '2' => "Global",
     '3' => "Local",
     '4' => "Journal",
     '5' => "Item",
     '6' => "Dead",
     '7' => "Not ID",
     '8' => "Not Faction",
     '9' => "Not Class",
     'A' => "Not Race",
     'B' => "Not Cell",
     'C' => "Not Local");

my %INFO_SCVR_cmp =
    ('0' => '=',
     '1' => '!=',
     '2' => '>',
     '3' => '>=',
     '4' => '<',
     '5' => '<=');

my %SEX = (0 => "Male", 1 => "Female", 0xFF => "None");
my %SPECIALIZATION = (0 => "Combat", 1 => "Magic", 2 => "Stealth");

my %SKILL = ( 0 => "Block",
	      1 => "Armorer",
	      2 => "MediumArmor",
	      3 => "HeavyArmor",
	      4 => "BluntWeapon",
	      5 => "LongBlade",
	      6 => "Axe",
	      7 => "Spear",
	      8 => "Athletics",
	      9 => "Enchant",
	     10 => "Destruction",
	     11 => "Alteration",
	     12 => "Illusion",
	     13 => "Conjuration",
	     14 => "Mysticism",
	     15 => "Restoration",
	     16 => "Alchemy",
	     17 => "Unarmored",
	     18 => "Security",
	     19 => "Sneak",
	     20 => "Acrobatics",
	     21 => "LightArmor",
	     22 => "ShortBlade",
	     23 => "Marksman",
	     24 => "Mercantile",
	     25 => "SpeechCraft",
	     26 => "HandToHand");

my %ATTRIBUTE = (0 => "Strength",
		 1 => "Intelligence",
		 2 => "Willpower",
		 3 => "Agility",
		 4 => "Speed",
		 5 => "Endurance",
		 6 => "Personality",
		 7 => "Luck");

my @AUTOCALC_FLAGS = ([0x00001, "Weapon"],
		      [0x00002, "Armor"],
		      [0x00004, "Clothing"],
		      [0x00008, "Books"],
		      [0x00010, "Ingredient"],
		      [0x00020, "Picks"],
		      [0x00040, "Probes"],
		      [0x00080, "Lights"],
		      [0x00100, "Apparatus"],
		      [0x00200, "Repair"],
		      [0x00400, "Misc"],
		      [0x00800, "Spells"],
		      [0x01000, "Magic Items"],
		      [0x02000, "Potions"],
		      [0x04000, "Training"],
		      [0x08000, "Spellmaking"],
		      [0x10000, "Enchanting"],
		      [0x20000, "Repair Item"]);

my %DIAL_TYPE = (0 => "Topic",
		 1 => "Voice",
		 2 => "Greeting",
		 3 => "Persuasion",
		 4 => "Journal");

my %ENCHANT_TYPE = (0 => "Cast Once",
		    1 => "Cast on Strike",
		    2 => "Cast when Used",
		    3 => "Constant Effect");

my %RANGE_TYPE = (0 => "Self", 1 => "Touch", 2 => "Target");

my @MGEF_FLAGS = ([0x0200, "Spellmaking"],
		  [0x0400, "Enchanting"],
		  [0x0800, "Negative"]);

my %MAGIC_SCHOOL = (0 => "Alteration",
		    1 => "Conjuration",
		    2 => "Destruction",
		    3 => "Illusion",
		    4 => "Mysticism",
		    5 => "Restoration");

my %SPEL_TYPE = (0 => "Spell",
		 1 => "Ability",
		 2 => "Blight",
		 3 => "Disease",
		 4 => "Curse",
		 5 => "Power");

my @SPEL_FLAGS = ([0x0001, "AutoCalc"],
		  [0x0002, "PC Start"],
		  [0x0004, "Always Succeeds"]);

my %WEAPON_TYPE = (0 => "ShortBladeOneHand",
		   1 => "LongBladeOneHand",
		   2 => "LongBladeTwoClose",
		   3 => "BluntOneHand",
		   4 => "BluntTwoClose",
		   5 => "BluntTwoWide",
		   6 => "SpearTwoWide",
		   7 => "AxeOneHand",
		   8 => "AxeTwoHand",
		   9 => "MarksmanBow",
		   10 => "MarksmanCrossbow",
		   11 => "MarksmanThrown",
		   12 => "Arrow",
		   13 => "Bolt");

my %WEAPON_FLAGS = (1 => "[Ignores Normal Weapon Resistance]");

my @CONTAINER_FLAGS = ([0x0001, "Organic"],
		       [0x0002, "Respawns, Organic only"],
		       [0x0008, "Default"]);

my @CREATURE_FLAGS = ([0x0001, "Biped"],
		      [0x0002, "Respawn"],
		      [0x0004, "Weapon and shield"],
		      [0x0008, "None"],
		      [0x0010, "Swims"],
		      [0x0020, "Flies"],
		      [0x0040, "Walks"],
		      [0x0048, "Default"],
		      [0x0080, "Essential"],
		      [0x0400, "Skeleton Blood"],
		      [0x0800, "Metal Blood"]);

my %ARMOR_TYPE = (0 => "Helmet",
		  1 => "Cuirass",
		  2 => "L. Pauldron",
		  3 => "R. Pauldron",
		  4 => "Greaves",
		  5 => "Boots",
		  6 => "L. Gauntlet",
		  7 => "R. Gauntlet",
		  8 => "Shield",
		  9 => "L. Bracer",
		  10 => " R. Bracer");

my %ARMOR_INDEX = (0 => "Head",
		   1 => "Hair",
		   2 => "Neck",
		   3 => "Cuirass",
		   4 => "Groin",
		   5 => "Skirt",
		   6 => "Right Hand",
		   7 => "Left Hand",
		   8 => "Right Wrist",
		   9 => "Left Wrist",
		   10 => "Shield",
		   11 => "Right Forearm",
		   12 => "Left Forearm",
		   13 => "Right Upper Arm",
		   14 => "Left Upper Arm",
		   15 => "Right Foot",
		   16 => "Left Foot",
		   17 => "Right Ankle",
		   18 => "Left Ankle",
		   19 => "Right Knee",
		   20 => "Left Knee",
		   21 => "Right Upper Leg",
		   22 => "Left Upper Leg",
		   23 => "Right Pauldron",
		   24 => "Left Pauldron",
		   25 => "Weapon",
		   26 => "Tail");

my @NPC_FLAGS = ([0x0001, "Female"],
		 [0x0002, "Essential"],
		 [0x0004, "Respawn"],
		 [0x0010, "Autocalc"],
		 [0x0400, "Blood Skel"],
		 [0x0800, "Blood Metal"]);

my %LEVI_DATA = (1 => "Calc from all levels <= PC level",
		 2 => "Calc for each item");

sub decode_flags {
    my($flags, $flagdefs) = @_;
    my @list = ();
    foreach my $ref (@{$flagdefs}) {
	my($val, $name) = @$ref;
	push(@list, $name) if ($flags & $val);
    }
    return("(" . join(", ", @list) . ")");
}

sub dump_lookup {
    my($key, $hashref) = @_;
    return($hashref->{$key} || $key . "???");
}

my $NREC;

my $DEFAULT_UNPACK = 
    sub { "hex:" . unpack("h*", $_[0]) . '  str:"' . substr((($_ = $_[0]) =~ tr/\000-\037\177-\377//d, $_), 0, 60) . '"' };
my %UNPACK =
    ("TES3.HEDR" => sub { my($ver, $unk, $auth, $desc, $nrec) = unpack("fLZ32Z256L", $_[0]);
			  $NREC = $nrec;
			  qq{  Ver:$ver  Unk:$unk\n\t\tAuthor:"$auth"\n\t\tDescription:"$desc"\n\t\tNRec:$NREC}; },
     "TES3.MAST" => sub { sprintf qq{"%s"}, unpack("Z*", $_[0]) },
     "TES3.DATA" => sub { my($l1, $l2) = unpack("LL", $_[0]);
			  my $size = $l1 + ($l2 << 32);
			  "Length:     $size"; },
     "ARMO.AODT" => sub { my($type, $weight, $value, $health, $epts, $armor) = unpack("LfLLLL", $_[0]);
			  sprintf "Type: %s  Weight: %0.2f  Value: %d  Health %d  EnchPoints: %d  ArmorRating: %d",
			      $ARMOR_TYPE{$type}, $weight, $value, $health, $epts, $armor},
     "ARMO.INDX" => sub { $ARMOR_INDEX{unpack("C", $_[0])} },
     "CELL.AMBI" => sub { sprintf("Ambient Color: 0x%08x  Sunlight Color: 0x%08x  Fog Color: 0x%08x  Fog Density: %0.2f",
				unpack("lllf", $_[0])); },
     "CELL.DATA" => sub {
	 if (length($_[0]) == 24) {
	     sprintf("Position x: %0.2f y: %0.2f z: %0.2f   Angle x: %0.2f y: %0.2f z: %0.2f", unpack("f6", $_[0]));
	 } else {
	     my($flags, $fog_den_data) = unpack("Lx[L]f", $_[0]);
	     my @flags = ();
	     my $coord = "";
	     my $data_fog_str = "";
	     if ($flags & 0x01) {
		 push(@flags, "Interior");
		 $data_fog_str = sprintf "FogDensity: %0.2f ", $fog_den_data;
	     } else {
		 push(@flags, "Exterior");
		 my($x, $y) = unpack("x[L]ll", $_[0]);
		 $coord = "Coordinates: ($x, $y) ";
	     }
	     my $flags_str = "Flags: " . decode_flags($flags, \@CELL_FLAGS);
	     $coord . $data_fog_str . $flags_str;
	 }
     },
     "CLAS.CLDT" => sub { my($attr1, $attr2, $spec, $min1, $maj1, $min2, $maj2, $min3, $maj3, $min4, $maj4, $min5, $maj5, $flags, $autoflags) =
			      unpack("L15", $_[0]);
			  "  " . join("\n\t\t",
				      "Primary Attribute:   $ATTRIBUTE{$attr1}",
				      "Secondary Attribute: $ATTRIBUTE{$attr2}",
				      "Specialization: $SPECIALIZATION{$spec}",
				      "Major-Skill-1: $SKILL{$maj1}",
				      "Major-Skill-2: $SKILL{$maj2}",
				      "Major-Skill-3: $SKILL{$maj3}",
				      "Major-Skill-4: $SKILL{$maj4}",
				      "Major-Skill-5: $SKILL{$maj5}",
				      "Minor-Skill-1: $SKILL{$min1}",
				      "Minor-Skill-2: $SKILL{$min2}",
				      "Minor-Skill-3: $SKILL{$min3}",
				      "Minor-Skill-4: $SKILL{$min4}",
				      "Minor-Skill-5: $SKILL{$min5}",
				      "Flags: " . (($flags) ? "Playable" : "Non-playable"),
				      "AutoCalc Flags: " . decode_flags($autoflags, \@AUTOCALC_FLAGS));
		      },
     "CONT.FLAG" => sub { decode_flags(unpack("L", $_[0]), \@CONTAINER_FLAGS) },
     "CREA.FLAG" => sub { decode_flags(unpack("L", $_[0]), \@CREATURE_FLAGS) },
     "DIAL.DATA" => sub { $DIAL_TYPE{unpack("C", $_[0])} },
     "ENCH.ENDT" => sub { my($type, $cost, $chrg, $auto) = unpack("LLLL", $_[0]);
		      sprintf "Type: %s  Cost: %d  Charge: %d  Autocalc: %d", $ENCHANT_TYPE{$type}, $cost, $chrg, $auto },
     "ENCH.ENAM" => sub { my($effect, $skill, $attr, $range, $area, $dur, $mmin, $mmax) = unpack("SccLLLLL", $_[0]);
		      sprintf "EffectID: %d  Skill: %s  Attribute: %s  RangeType: %s  Area: %d  Duration: %d  Magnitude Min: %d  Max: %d",
			  $effect, $SKILL{$skill}, $ATTRIBUTE{$attr}, $RANGE_TYPE{$range}, $area, $dur, $mmin, $mmax },
     "INFO.INAM" => sub { sprintf qq{"%s"}, unpack("Z*", $_[0]) },
     "INFO.DATA" => sub { my($disp, $rank, $sex, $pcrank) = unpack("x[L]LCCC", $_[0]);
			  "Disp:$disp  Rank:$rank  Sex:$SEX{$sex}  PCRank:$pcrank"; },
     "INFO.ANAM" => sub { sprintf qq{Cell:       "%s"}, unpack("Z*", $_[0]) },
     "INFO.BNAM" => sub { sprintf qq{Result:     "%s"}, unpack("Z*", $_[0]) },
     "INFO.CNAM" => sub { sprintf qq{Class:      "%s"}, unpack("Z*", $_[0]) },
     "INFO.DNAM" => sub { sprintf qq{PC Faction: "%s"}, unpack("Z*", $_[0]) },
     "INFO.FNAM" => sub { sprintf qq{Faction:    "%s"}, unpack("Z*", $_[0]) },
     "INFO.NAME" => sub { sprintf qq{Response:   "%s"}, unpack("Z*", $_[0]) },
     "INFO.NNAM" => sub { sprintf qq{Next ID:    "%s"}, unpack("Z*", $_[0]) },
     "INFO.ONAM" => sub { sprintf qq{Actor:      "%s"}, unpack("Z*", $_[0]) },
     "INFO.PNAM" => sub { sprintf qq{Prev ID:    "%s"}, unpack("Z*", $_[0]) },
     "INFO.RNAM" => sub { sprintf qq{Race:       "%s"}, unpack("Z*", $_[0]) },
     "INFO.SCVR" => sub { my($idx, $typ, $fun, $cmp, $nam) = unpack("aaa2aZ*", $_[0]);
			  sprintf "Index:$idx  Type:%s  Fun:%s  Cmp:%s  Name:$nam",
			      dump_lookup($fun, \%INFO_FUN), dump_lookup($typ, \%INFO_SCVR_type), dump_lookup($cmp, \%INFO_SCVR_cmp); },
     "LEVC.DATA" => sub { "List Data: %d (1 = Calc from all levels <= PC level)", unpack("L", $_[0]) },
     "LEVC.NNAM" => sub { sprintf "ChanceNone: %d", unpack("C", $_[0]) },
     "LEVI.DATA" => sub { "List Data: %s ", $LEVI_DATA{unpack("L", $_[0])} },
     "LEVI.NNAM" => sub { sprintf "ChanceNone: %d", unpack("C", $_[0]) },
     "LTEX.DATA" => sub { unpack("Z*", $_[0]) },
     "MGEF.MEDT" => sub { my($school, $base, $flags, $red, $blue, $green, $speed, $size, $sizecap) = unpack("LfLLLLfff", $_[0]);
			  sprintf "School: %s  BaseCost: %0.2f  Flags: %s  RGB: (%d, %d, %d)  SizeX: %0.2f  SizeCap: %0.2f",
			      $MAGIC_SCHOOL{$school}, $base, decode_flags($flags, \@MGEF_FLAGS), $red, $blue, $green, $size, $sizecap },
     "MISC.MCDT" => sub { sprintf "Weight: %0.2f  Value: %d", unpack("fL", $_[0]) },
     "NPC_.FLAG" => sub { decode_flags(unpack("L", $_[0]), \@NPC_FLAGS) },
     "NPC_.NPDT" => sub { my $len = length($_[0]);
			  if ($len == 12) {
			      my($lev, $disp, $fact, $rank, $gold) = unpack("SC3x[C3]L", $_[0]);
			      sprintf "Level: %d  Disposition: %d  Faction: %d  Rankd: %d", $lev, $disp, $fact, $rank, $gold;
			  } elsif ($len == 52) {
			      my $skills = "";
			      my $n = 0;
			      foreach (unpack('x[SC8]C27', $_[0])) {
				  $skills .= "\n\t\t" if (($n % 7) == 0);
				  $skills .= " $SKILL{$n}: $_";
				  $n++;
			      }
			      my($lev, $str, $int, $wil, $agi, $spd, $end, $per, $lck, $rep, $hlth, $spelpts, $fat, $disp, $fact, $rank, $gold) =
				  unpack("SC8x[C27]CSSSCCCCxCL", $_[0]);
			      sprintf "  Level: %d  Str: %d  Int: %d  Wil: %d  Agi: %d  Spd: %d  End: %d  Per: %d  Lck: %d\n\t\tRep: %d  Health: %d SpellPts: %d  Fatigue: %d  Disp: %d  Faction: %d  Rank: %d  Gold: %d\n\t\tSkills:$skills",
				  $lev, $str, $int, $wil, $agi, $spd, $end, $per, $lck, $rep, $hlth, $spelpts, $fat, $disp, $fact, $rank, $gold;
			  } else {
			      "BAD NPDT length ($len) is not 12 or 52!";
			  }
		      },
     "REGN.WEAT" => sub { sprintf "Clear: %d  Cloudy: %d  Foggy: %d  Overcast: %d  Rain: %d  Thunder: %d  Ash: %d  Blight: %d",
			      unpack("C8", $_[0]) },
     "REGN.CNAM" => sub { "Map Color RGB: (%d, %d, %d)", unpack("C3", $_[0]) },
     "REGN.SNAM" => sub { "Chance: %3d  SoundName: %s", unpack("Z32C", $_[0]) },
     "SCPT.SCDT" => sub { "(Compiled script data)" },
     "SCPT.SCHD" => sub { sprintf "Name: %s  NumShorts: %d  NumLongs: %d  NumFloats: %d  ScriptDataSize: %d  LongVarSize: %d",
			      unpack("Z32LLLLL", $_[0]); },
     "SCPT.SCVR" => sub { "Script Variables: " . join(',', split(/\000/, unpack('a*', $_[0]))) },
     "SCPT.SCTX" => sub { "Script:\n" . unpack("Z*", $_[0]) },

     "SKIL.SKDT" => sub { my($attr, $spec, @usevals) = unpack("LLf4", $_[0]);
			  sprintf "Attribute: %s  Specialization: %s  UseValues: %0.2f %0.2f %0.2f %0.2f",
			      $ATTRIBUTE{$attr}, $SPECIALIZATION{$spec}, @usevals},
     "SPEL.SPDT" => sub { my($type, $cost, $flags) = unpack("LLL", $_[0]);
		      sprintf "Type: %s  Cost: %d  Flags: %s", $SPEL_TYPE{$type}, $cost, decode_flags($flags, \@SPEL_FLAGS) },
     "SPEL.ENAM" => sub { join(",", unpack("C24", $_[0])) },
     "SOUN.DATA" => sub { sprintf "Volume: %d  MinRange: %d  MaxRange: %d", unpack("CCC", $_[0]) },
     "WEAP.WPDT" => sub { my($weight, $value, $type, $health, $speed, $reach, $epts, $chopmin, $chopmax, $slashmin, $slashmax, $pokemin, $pokemax, $flags) = unpack("fLSSffSC6L", $_[0]);
		      sprintf "  Wght: %0.2f  Val: %d  Typ: %s  Hlth: %d  Spd: %0.2f  Rch: %0.2f\n\t\tEnchPts: %d  Chop: %d-%d  Slash: %d-%d Thrust: %d-%d  Flags: %s",
			  $weight, $value, $WEAPON_TYPE{$type}, $health, $speed, $reach, $epts, $chopmin, $chopmax, $slashmin, $slashmax, $pokemin, $pokemax, $WEAPON_FLAGS{$flags}},

     # The following are common subrecord formats
     DODT => sub { sprintf "Position x: %0.2f y: %0.2f z: %0.2f   Angle x: %0.2f y: %0.2f z: %0.2f", unpack("f6", $_[0]) },
     FLAG => sub { sprintf "hexflags:0x%04x", unpack("L", $_[0]) },
     NPCO => sub { sprintf 'Count=%d  Name="%s"', unpack("lZ*", $_[0]) },
    );

# subrecords that decode as signed 32-bit longs:
foreach (qw(INTV)) {
    $UNPACK{$_} = sub { unpack("l", $_[0]) }; }

# subrecords that decode as unsigned 32-bit longs:
foreach (qw(FRMR INDX NAM0))
    { $UNPACK{$_} = sub { unpack("L", $_[0]) }; }

# subrecords that decode as 32-bit floats:
foreach (qw(FLTV WHGT XSCL))
    { $UNPACK{$_} = sub { sprintf "%0.2f", unpack("f", $_[0]) }; }

# subrecords that decode as variable length Z-strings:
foreach (qw(ANAM ASND AVFX BNAM BSND BVFX CNAM CSND CVFX DESC DNAM ENAM FNAM
HSND HVFX ITEX KNAM MODL NAME NPCS PTEX RGNN RNAM SCIP SCPT SCRI SNAM STRV
TEXT TNAM WNAM))
    { $UNPACK{$_} = sub { sprintf qq{"%s"}, unpack("Z*", $_[0]) }; }

sub opts_dump {
    $_[0] && do { warn $DUMP_USAGE; exit(0); };
    getopts('Dt:i:m:') or die $DUMP_USAGE;
}

my $REN_USAGE = q{Usage: tes3cmd rename OPTIONS RECTYPE.SUBTYPE FROM TO plugin...

This first form of the command renames all records of type RECTYPE, replacing
the Perl regular expression FROM with the value of TO (which may contain
backreferences). The rename only happens if the CELL.NAME subrecord matches
the given FROM regular expression. For more on regular expressions, see:
http://www.perl.com/doc/manual/html/pod/perlre.html

tes3cmd rename -l RECTYPE.SUBTYPE plugin...

When the -l switch is given, records of the given type are only listed.

OPTIONS
 -D   turn on debug output
 -i   only rename if the record is an interior CELL.
 -e   only rename if the record is an exterior CELL.
 -l   just list the records, do not rename them.
 -w   size of printable window for record contents printed with -l switch.

The original input file is never modified, the changes are made in a new file
"<plugin_name>_new.esp".

Examples:

# rename all exterior cells to the null string:
tes3cmd rename -e CELL.NAME '.*' '' plugin.esp

# do a caseless comparison:
tes3cmd rename cell.name '(?i)pelagaid' 'Pelagiad' plugin.esp
(This would rename any name that has the string "pelagaid" in it with any form
of capitalization, to "Pelagiad").

# substitute backreferences:
tes3cmd rename npc_.fnam '^(\S+)\s(\S+)$' '$2 $1' plugin.esp
(This would swap the first and last name of all NPCs).
};

my($REN_FROM, $REN_TO, $REN_TYPE, $REN_SUBTYPE);
my @ren_valid_types = qw(GMST.NAME CLAS.NAME CLAS.FNAM FACT.NAME FACT.FNAM RACE.NAME RACE.FNAM
		     SOUN.NAME SOUN.FNAM REGN.NAME REGN.FNAM BSGN.NAME BSGN.FNAM STAT.NAME
		     DOOR.NAME DOOR.FNAM MISC.NAME MISC.FNAM WEAP.NAME WEAP.FNAM CONT.NAME
		     CONT.FNAM SPEL.NAME SPEL.FNAM CREA.NAME CREA.FNAM LIGH.NAME LIGH.FNAM
		     ENCH.NAME NPC_.NAME NPC_.FNAM ARMO.NAME ARMO.FNAM CLOT.NAME CLOT.FNAM
		     REPA.NAME REPA.FNAM ACTI.NAME ACTI.FNAM APPA.NAME APPA.FNAM LOCK.NAME
		     LOCK.FNAM PROB.NAME PROB.FNAM INGR.NAME INGR.FNAM BOOK.NAME BOOK.FNAM
		     ALCH.NAME ALCH.FNAM LEVI.NAME CELL.NAME DIAL.NAME);
my %VALID_TYPES;
$VALID_TYPES{$_}++ foreach (@ren_valid_types);

sub opts_rename {
    $_[0] && do { warn $REN_USAGE; exit(0); };
    $::opt_v = 0;
    $::opt_l = 0;
    $::opt_i = 0;
    $::opt_e = 0;
    $::opt_w = 38;
    getopts('Deilvw:') or die $REN_USAGE;

    my $type = uc(shift(@ARGV)) or die "Missing required RECTYPE.SUBTYPE\n$REN_USAGE";
    die "Error: Invalid record type.subtype requested: $type\n\nI only know these:\n@ren_valid_types\n" unless ($VALID_TYPES{$type});
    ($REN_TYPE, $REN_SUBTYPE) = split(/\./, $type);

    unless ($::opt_l) {
	$REN_FROM = shift(@ARGV) or die "Missing required FROM\n$REN_USAGE";
	$REN_TO = shift(@ARGV) or die "Missing required TO\n$REN_USAGE";
    }
}

my $HDR_USAGE = q{Usage: tes3cmd header OPTIONS plugin...

OPTIONS
 -D      turn on debug output
 -a XXX  set the Author field to XXX
 -d YYY  set the Desciption field to YYY
 -m      multiline output for listing field contents.

When -a and -d are not given, the current Author/Description field contents
are printed.

Field values are normally replaced by the given string. But if the string
begins with a "+", the field is appended with the new value.

If a field value contains the string \\n, it will be replaced by a CRLF.

If the value supplied won't fit into the plugin header field, you will be
warned.

Examples:

# Show the Author/Description fields for a plugin:
tes3cmd header plugin.esp

# Set the Author field to "john.moonsugar":
tes3cmd header -a john.moonsugar plugin.esp

# Append " and friends" to the Author field:
tes3cmd header -a "+ and friends" plugin.esp

# Add a Version number to a plugin Description field:
tes3cmd header -d "+\nVersion: 1.0" plugin.esp
};

my $HDR_AUTH_OFFSET = 32;
my $HDR_AUTH_LENGTH = 32;
my $HDR_DESC_OFFSET = $HDR_AUTH_OFFSET + $HDR_AUTH_LENGTH;
my $HDR_DESC_LENGTH = 256;

sub opts_header {
    $_[0] && do { warn $HDR_USAGE; exit(0); };
    $::opt_v = 0;
    $::opt_a = "";
    $::opt_d = "";
    $::opt_m = undef;
    $::opt_v = 0.0;
    getopts('Da:d:mv:') or die $HDR_USAGE;
}

my %CMDS = (
	    "common"   => [ \&opts_com,      \&cmd_com ],
	    "overdial" => [ \&opts_overdial, \&cmd_overdial ],
	    "dump"     => [ \&opts_dump,     \&cmd_dump ],
	    "header"   => [ \&opts_header,   \&cmd_header ],
	    "help"     => [ \&opts_help,     undef ],
	    "rename"   => [ \&opts_rename,   \&cmd_rename ],
	   );

my $USAGE_ALL = qq{Usage: tes3cmd COMMAND OPTIONS plugins...

For help on commands: tes3cmd help command

COMMANDS
@{[join", ", keys %CMDS]}

};
sub add_alias {
    my($name, $alias) = @_;
    $CMDS{$alias} = $CMDS{$name};
    $USAGE_ALL .= " $alias is an alias for: $name\n"
}
# add shortcut aliases for convenience
add_alias("header", "hdr");
add_alias("rename", "ren");
add_alias("common", "com");
add_alias("overdial", "od");

sub opts_help {
    if (my $cmd_name = shift(@ARGV)) {
	if (my $cmd_ref = $CMDS{$cmd_name}) {
	    $cmd_ref->[0]->(1);	# exits
	} else {
	    die $USAGE_ALL;
	}
    }
    die $USAGE_ALL;
}

sub chop_nulls {
    my($str) = @_;
    return(unpack("Z*", $str));
}

sub write_header_field {
    my($plugin, $origval, $val, $label, $offset, $fieldlen) = @_;
    if ($val =~ /^\+(.*)$/) {
	$val = $origval . $1;
    }
    $val =~ s/(\\r|\r)?(\\n|\n)/\r\n/g;
    # create an empty null padded field
    my $valz = "\000" x $fieldlen;
    # truncate $val to fit in the field, if necessary
    my $origlen = length($val);
    $val = substr($val, 0, $fieldlen - 1);
    if (length($val) < $origlen) {
	warn "Warning, input $label truncated because it exceeded field length of: $fieldlen\n";
    }
    # and plop the given string value into it, with at least one ending null
    substr($valz, 0, length($val)) = $val;
    unless(seek(PLUG, $offset, 0)) {
	warn "$plugin: Error seeking to start of $label field at offset: $offset ($!)\n";
	return(undef);
    }
    my $len = length($valz);
    my $nwritten = syswrite(PLUG, $valz);
    if ($nwritten != $len) {
	warn "$plugin: Error incomplete write to $label field ( ($!)\n";
	return(undef);
    }
    print qq{$plugin: $label set to: "$val"\n};
    return(1);
}

my $hdr_size = 16;
sub read_rec {
    my($expected_type) = @_;
    my $rec_hdr = "";
    my $n_read = sysread(INP, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef);
    }
    if ($n_read != $hdr_size) {
	warn "Error(hdr): asked for $hdr_size bytes, got $n_read\n";
	return(undef);
    }
    my($rec_type, $rec_len, $unk, $flags) = unpack("a4LLL", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rec_type) {
	warn "Error: Expected: $expected_type, got: $rec_type\n";
	return(undef);
    }
    my $rec = "";
    $n_read = sysread(INP, $rec, $rec_len);
    if ($n_read != $rec_len) {
	warn "Error(rec): asked for $rec_len bytes, got $n_read\n";
	return(undef);
    }
    return($rec_type, $rec, $unk, $flags);
}

sub write_rec {
    my($rec_type, $rec, $unk, $flags) = @_;
    print OUT pack("a4LLLa*", $rec_type, length($rec), $unk, $flags, $rec);
}

sub parse_subrec_list {
    my($rec) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @subrecs = ();
    my $name_idx;
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$name_idx = scalar(@subrecs) if ((not defined $name_idx) and ($subrec_type eq $REN_SUBTYPE));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@subrecs, [$subrec_type, $val]) if (defined $val);
	$p += $subrec_len;
    }
    return(\@subrecs, $name_idx);
}

# this version takes a little longer to execute
sub parse_subrec_hash_long {
    my($rec) = @_;
    warn "DBG: calling parse_subrec_hash_long for rec=$rec\n" if (DBG);
    my %r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@{$r{$subrec_type}}, $val) if (defined $val);
	$p += $subrec_len;
    }
    return(\%r);
}

sub parse_subrec_hash {
    my($rec) = @_;
    my %r = ();
    my @parts = eval { unpack("(a4L/a*)*", $rec); };
    return(parse_subrec_hash_long($rec)) if ($@);
    while (@parts) {
	my $subrec_type = shift(@parts);
	my $subrec_val = shift(@parts);
	push(@{$r{$subrec_type}}, $subrec_val)
	    if (defined $subrec_val);
    }
    return(\%r);
}

sub new_rec {
    my($sub_recs) = @_;
    my @rec;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	my $len = length($val);
	push(@rec, pack("a4La*", $type, $len, $val));
    }
    return(join("", @rec));
}

sub allowed_cell_type {
    my($sub_recs) = @_;
    return 1 unless ($::opt_i or $::opt_e);
    my $data;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	if ($type eq "DATA") {
	    $data = $val;
	    last;
	}
    }
    my($flags) = unpack("L", $data);
    if ($::opt_i) {
	return($flags & 1);	# is interior
    } else {			# opt_e
	return(not($flags & 1)); # is exterior
    }
}

sub pprec {
    my($rec, $subtype) = @_;
    print "DBG: pprec($rec)\n" if (DBG);
    my $recstr = join(":", grep(!/[^[:print:]]/, map { s/[\000]+$//gm; tr/\r\n/ /; $_; } split(/\000?([A-Z][A-Z_][A-Z_][A-Z_\d])...\000/, $rec)));
    $recstr =~ s/^:$subtype:.*?:// if ($subtype);
    $recstr =~ s/:([A-Z][A-Z_][A-Z_][A-Z_\d])/|$1/g;
    return(substr($recstr, 0, $::opt_w));
}

sub open_input_plugin {
    my($plugin, $mode) = @_;
    unless(open(INP, "<$plugin")) {
	warn qq{Error opening "$plugin" for input ($!)\n};
	return;
    }
    unless (binmode(INP)) {
	warn "Error setting binmode on $plugin ($!)\n";
	close(INP);
	return;
    }
}

sub ext_cell_name {
    my($r) = @_;
    my($x, $y) = unpack("x[L]ll", $r->{DATA}[0]);
    my $rgnn = chop_nulls($r->{RGNN}[0]) || "Wilderness";
    return("$rgnn ($x, $y)", $x, $y);
}

sub rec_id {
    my($r, $rec_type) = @_;
    if ($rec_type eq "INFO") {
	return(chop_nulls($r->{INAM}[0]));
    } elsif ($rec_type eq "CELL") {
	my $name = chop_nulls($r->{NAME}[0]);
	my $data = $r->{DATA}[0];
	my($flags) = unpack("L", $data);
	if ($flags & 1) {	# interior
	    return($name);
	} else {		# exterior
	    my($xname, $x, $y) = ext_cell_name($r);
	    return(($name) ? "$name ($x, $y)" : $xname);
	}
    } elsif ($rec_type eq "SCPT") {
	my $script = $r->{SCTX}->[0];
	my $name = ($script =~ m!^[^;]*?\bbegin\s+(\S+)!im) ? $1 : "unknown";
	return(lc($name));
    } elsif (defined $r->{NAME}) {
	return(lc(chop_nulls($r->{NAME}->[0])));
    } elsif (defined $r->{INDX}) {
	return(unpack("L", $r->{INDX}->[0]));
    } elsif ($rec_type eq "LAND") {
	my($x, $y) = unpack("ll", $r->{INTV}->[0]);
	return("($x, $y)");
    }
    return(undef);
}

sub read_object_ids {
    my($plugin, $fun) = @_;
    open_input_plugin($plugin);
    my %plugin_id = ();
    while(my($rec_type, $rec, $flags) = read_rec(undef)) {
	last if not defined $rec_type;
	if ($flags & 0x1000) {
	    print "plugin($plugin) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	if ($fun) {
	    $fun->($rec_type, $id);
	} else {
	    $plugin_id{$rec_type}->{$id} = 1 if (defined $id);
	}
    }
    close(INP);
    return(\%plugin_id) unless ($fun);
}

sub read_dialogs {
    my($plugin, $dialref) = @_;
    open_input_plugin($plugin);
    while(my($rec_type, $rec, $flags) = read_rec(undef)) {
	last if not defined $rec_type;
	if ($flags & 0x1000) {
	    print "plugin($plugin) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	next if ($rec_type ne "DIAL");
	my $r = parse_subrec_hash($rec);
	my $id = unpack("Z*", $r->{NAME}[0]);
	my $type = unpack("C", $r->{DATA}[0]);
	$dialref->{$plugin}->{$id}++ if ($type == 0 and $id);
    }
    close(INP);
}

sub cmd_overdial {
    my(@plugins) = @_;
    my %dialog;
    foreach my $plugin (@plugins) {
	read_dialogs($plugin, \%dialog);
    }
    my @testplugins = ($::opt_1) ? ($plugins[0]) : sort keys %dialog;
    foreach my $plugin1 (sort keys %dialog) {
	foreach my $plugin2 (@testplugins) {
	    if ($plugin1 ne $plugin2) {
		foreach my $id1 (keys %{$dialog{$plugin1}}) {
		    foreach my $id2 (keys %{$dialog{$plugin2}}) {
			if (length($id1) > length($id2) and $id1 =~ /\b$id2\b/i) {
			    printf qq{%-40s "$id1"\n%-40s "$id2"\n\n}, "$plugin1:", "$plugin2:";
			}
		    }
		}
	    }
	}
    }
}

# find objects in common between 2 plugins
sub cmd_com {
    my($plugin1, $plugin2) = @_;
    # swap plugins if plugin1 is larger than plugin2
    ($plugin1, $plugin2) = ($plugin2, $plugin1)
	if (-s $plugin1 > -s $plugin2);
    # read objects from smaller plugin
    my $objects1 = read_object_ids($plugin1);
    # compare to objects second plugin
    my $compare_fun = sub {
	my($rec_type, $id) = @_;
	if ($objects1->{$rec_type}->{$id}) {
	    print "  $rec_type: $id\n";
	}
    };
    read_object_ids($plugin2, $compare_fun);
}

sub cmd_dump {
    my($plugin) = @_;
    #my $plugin = (split(m![\\/]!, $plugin))[-1];
    warn "### Scanning $plugin\n" if ($::opt_v);
    open_input_plugin($plugin);
    my $expected = "TES3";
    my $wanted_ids;
    my $match;
    if ($::opt_i) {
	$wanted_ids = '(' . join('|', split(/,/, $::opt_i)) . ')';
    }
    my %wanted_types;
    my %wanted_subtypes;
    if ($::opt_t) {
	foreach (split(/,/, $::opt_t)) {
	    # TBD - validate types?
	    my($type, $subtype) = split(/\./, $_);
	    if (length($type) != 4) {
		warn qq{Invalid record type: "$_" (must be 4 characters long)\n};
		next;
	    }
	    $wanted_types{lc($type)}++;
	    if ($subtype) {
		if (length($subtype) == 4) {
		    $wanted_subtypes{lc("$type.$subtype")}++ if ($subtype);
		} else {
		    warn qq{Invalid record subtype: "$_" (must be 4 characters long)\n};
		    next;
		}
	    }
	}
    }
    my $plugin_banner = "\n$plugin:\n";
    my $n = 1;
    while (my($rec_type, $rec, $flags) = read_rec($expected)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	if ($flags & 0x1000) {
	    print "REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	if ($wanted_ids) {
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    next if ($id !~ /$wanted_ids/i);
	}
	next if (%wanted_types and not $wanted_types{lc($rec_type)});
	$n = 0 if ($rec_type eq "TES3");
	my $p = 0;
	my $rec_len = length($rec);
	my $name_idx;
	my $first = 1;
	my $print_rec = "";
	while ($p < $rec_len) {
	    my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	    $p += 8;
	    my $subrec = substr($rec, $p, $subrec_len);
	    $p += $subrec_len;
	    if (defined $subrec) {
		my $full_type = "${rec_type}.${subrec_type}";
		if (not (%wanted_subtypes and not $wanted_subtypes{lc($full_type)})) {
		    my $unpack = $UNPACK{$full_type} || $UNPACK{$subrec_type}  || $DEFAULT_UNPACK;
		    my $subrec_str = $unpack->($subrec);
		    $print_rec .= "   $full_type: $subrec_str\n";
		}
	    } else {
		warn "$plugin: Error: malformed subrec $subrec_type\n";
	    }
	}
	next if ($::opt_m and not $print_rec =~ /$::opt_m/i);
	if ($print_rec and $plugin_banner) {
	    print $plugin_banner;
	    $plugin_banner = undef;
	}
	if ($first) {
	    print "\nRecord: $n\n";
	    $first = 0;
	}
	print $print_rec;
	$n++;
    }
    close(INP);
}

sub cmd_rename {
    my($plugin) = @_;
    my $newplugin = $plugin;
    $newplugin =~ s/(\.es[mp])$/_new$1/i;
    if ($newplugin eq $plugin) {
	warn "Error, $plugin name does not end in .esm or .esp?\n";
	return;
    }
    print "\n$plugin: RENAMING CELLS:\n" unless ($::opt_l);
    open_input_plugin($plugin);
    unless($::opt_l) {
	unless(open(OUT, ">$newplugin")) {
	    warn qq{Error opening "$newplugin" for output ($!)\n};
	    return;
	}
	unless(binmode(OUT, ':raw')) {
	    warn qq{Error setting binmode on "$newplugin" ($!)\n};
	    close(OUT);
	    return;
	}
    }
    my $expected = "TES3";
    while (my($rec_type, $rec, $unk, $flags) = read_rec($expected)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	if ($rec_type eq $REN_TYPE) {
	    my $renamed = 0;
	    my($subrecs, $name_idx) = parse_subrec_list($rec);
	    if (defined($name_idx) and
		my $name = $subrecs->[$name_idx]->[1]) {
		$name = chop_nulls($name);
		if ($::opt_l) {	# only list records
		    my $recstr = pprec($rec, $REN_SUBTYPE);
		    printf qq{  $rec_type  %-30s [%s]\n}, $name, $recstr;
		} else {	# rename records
		    my $do_rename = 1;
		    $do_rename = 0 if ($rec_type eq "CELL" and not allowed_cell_type($subrecs));
		    if ($do_rename) {
			my $newname;
			eval qq{(\$newname = \$name) =~ s!$REN_FROM!$REN_TO!g};
			if ($name ne $newname) {
			    $subrecs->[$name_idx]->[1] = "$newname\000";
			    $renamed = 1;
			    printf qq{    Renaming: $REN_TYPE %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			}
		    }
		}
	    } else {
		print "Error, Record has no $REN_SUBTYPE subrecord: $rec\n";
	    }
	    $rec = new_rec($subrecs) if $renamed;
	}
	write_rec($rec_type, $rec, $unk, $flags) unless($::opt_l);
    }
    close(INP);
    unless ($::opt_l) {
	close(OUT);
	print "Output saved in: $newplugin\n";
    }
}

sub cmd_header {
    my($plugin) = @_;
    unless(open(PLUG, "+<$plugin")) {
	warn qq{Error opening "$plugin" for read/write ($!)\n};
	return;
    }
    unless(binmode(PLUG)) {
	warn "Error setting binmode on $plugin ($!)\n";
	close(PLUG);
	return;
    }
    my $block;
    my $nread = read(PLUG, $block, 4096);
    if ($nread == 0) {
	warn "$plugin: Error on intial read ($!)\n";
	close(PLUG);
	return;
    }
    my $magic = substr($block, 0, 4);
    if ($magic eq "TES3") {
	if ($nread >= 362) { 	# minimum TES3 plugin size
	    my $auth = chop_nulls(substr($block, $HDR_AUTH_OFFSET, $HDR_AUTH_LENGTH));
	    my $desc = chop_nulls(substr($block, $HDR_DESC_OFFSET, $HDR_DESC_LENGTH));
	    if ($::opt_a or $::opt_d) {
		if ($::opt_a) {
		    if (not defined write_header_field($plugin, $auth, $::opt_a, "AUTHOR", $HDR_AUTH_OFFSET, $HDR_AUTH_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
		if ($::opt_d) {
		    if (not defined write_header_field($plugin, $desc, $::opt_d, "DESCRIPTION", $HDR_DESC_OFFSET, $HDR_DESC_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
	    } else {
		if ($::opt_m) {
		    print "$plugin:\n  AUTH=$auth\n  DESC=$desc\n";
		} else {
		    print "$plugin: AUTH=$auth DESC=$desc\n";
		}
	    }
	}
    } elsif ($magic eq "TES4") {
	warn "This function is not yet implemented for TES4 files\n";
    } else {
	warn "$plugin: Error, this does not appear to be an elder scrolls plugin\n";
    }
    close(PLUG);
}

sub main {
    if (scalar(@ARGV) == 0) {
	print $USAGE_ALL;
	exit(0);
    }
    my $cmd_ref;
    my $cmd_name = shift(@ARGV);
    die $USAGE_ALL unless ($cmd_ref = $CMDS{$cmd_name});
    my($cmd_getopts, $cmd) = @{$cmd_ref};
    $cmd_getopts->();
    if ($cmd_name =~ /^(com(mon)?|overdial|od)$/i) {
	$cmd->(@ARGV);
    } else {
	for my $plugin (@ARGV) {
	    $cmd->($plugin);
	}
    }
}

main();
