#!/usr/bin/perl

use Getopt::Std;
use strict;

# command line tool to do various hackage on a TES3 plugin

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant DBG => grep(/^(?:-D)$/, @ARGV);
}

my $REN_USAGE = q{Usage: tes3cmd rename [-D] RECTYPE.SUBTYPE FROM TO plugin...

This first form of the command renames all records of type RECTYPE, replacing
the Perl regular expression FROM with the value of TO (which may contain
backreferences). The rename only happens if the CELL.NAME subrecord matches
the given FROM regular expression. For more on regular expressions, see:
http://www.perl.com/doc/manual/html/pod/perlre.html

tes3cmd rename -l RECTYPE.SUBTYPE plugin...

When the -l switch is given, records of the given type are only listed.

OPTIONS
 -D   turn on debug output
 -i   only rename if the record is an interior CELL.
 -e   only rename if the record is an exterior CELL.
 -l   just list the records, do not rename them.
 -w   size of printable window for record contents printed with -l switch.

The original input file is never modified, the changes are made in a new file
"<plugin_name>_new.esp".

Examples:

# rename all exterior cells to the null string:
tes3cmd rename -e CELL.NAME '.*' ''

# do a caseless comparison:
tes3cmd rename cell.name '(?i)pelagaid' 'Pelagiad'
(This would rename any name that has the string "pelagaid" in it with any form
of capitalization, to "Pelagiad").

# substitute backreferences:
tes3cmd rename npc_.fnam '^(\S+)\s(\S+)$' '$2 $1'
(This would swap the first and last name of all NPCs).
};

my($REN_FROM, $REN_TO, $REN_TYPE, $REN_SUBTYPE);
my @ren_valid_types = qw(GMST.NAME CLAS.NAME CLAS.FNAM FACT.NAME FACT.FNAM RACE.NAME RACE.FNAM
		     SOUN.NAME SOUN.FNAM REGN.NAME REGN.FNAM BSGN.NAME BSGN.FNAM STAT.NAME
		     DOOR.NAME DOOR.FNAM MISC.NAME MISC.FNAM WEAP.NAME WEAP.FNAM CONT.NAME
		     CONT.FNAM SPEL.NAME SPEL.FNAM CREA.NAME CREA.FNAM LIGH.NAME LIGH.FNAM
		     ENCH.NAME NPC_.NAME NPC_.FNAM ARMO.NAME ARMO.FNAM CLOT.NAME CLOT.FNAM
		     REPA.NAME REPA.FNAM ACTI.NAME ACTI.FNAM APPA.NAME APPA.FNAM LOCK.NAME
		     LOCK.FNAM PROB.NAME PROB.FNAM INGR.NAME INGR.FNAM BOOK.NAME BOOK.FNAM
		     ALCH.NAME ALCH.FNAM LEVI.NAME CELL.NAME DIAL.NAME);
my %VALID_TYPES;
$VALID_TYPES{$_}++ foreach (@ren_valid_types);

sub opts_rename {
    $_[0] && do { warn $REN_USAGE; exit(0); };
    $::opt_v = 0;
    $::opt_l = 0;
    $::opt_i = 0;
    $::opt_e = 0;
    $::opt_w = 38;
    getopts('Deilvw:') or die $REN_USAGE;

    my $type = uc(shift(@ARGV)) or die "Missing required RECTYPE.SUBTYPE\n$REN_USAGE";
    die "Error: Invalid record type.subtype requested: $type\n\nI only know these:\n@ren_valid_types\n" unless ($VALID_TYPES{$type});
    ($REN_TYPE, $REN_SUBTYPE) = split(/\./, $type);

    unless ($::opt_l) {
	$REN_FROM = shift(@ARGV) or die "Missing required FROM\n$REN_USAGE";
	$REN_TO = shift(@ARGV) or die "Missing required TO\n$REN_USAGE";
    }
}

my $HDR_USAGE = q{Usage: tes3cmd header OPTIONS plugin...

OPTIONS
 -D      turn on debug output
 -a XXX  set the Author field to XXX
 -d YYY  set the Desciption field to YYY
 -m      multiline output for listing field contents.

When -a and -d are not given, the current Author/Description field contents
are printed.

Field values are normally replaced by the given string. But if the string
begins with a "+", the field is appended with the new value.

If a field value contains the string \\n, it will be replaced by a CRLF.

If the value supplied won't fit into the plugin header field, you will be
warned.

Examples:
# Show the Author/Description fields for a plugin:
tes3cmd header plugin.esp
# Set the Author field to "john.moonsugar":
tes3cmd header -a john.moonsugar plugin.esp
# Append " and friends" to the Author field:
tes3cmd header -a "+ and friends" plugin.esp
# Add a Version number to a plugin Description field:
tes3cmd header -d "+\nVersion: 1.0" plugin.esp
};

my $HDR_AUTH_OFFSET = 32;
my $HDR_AUTH_LENGTH = 32;
my $HDR_DESC_OFFSET = $HDR_AUTH_OFFSET + $HDR_AUTH_LENGTH;
my $HDR_DESC_LENGTH = 256;

sub opts_header {
    $_[0] && do { warn $HDR_USAGE; exit(0); };
    $::opt_v = 0;
    $::opt_a = "";
    $::opt_d = "";
    $::opt_m = undef;
    $::opt_v = 0.0;
    getopts('Da:d:mv:') or die $HDR_USAGE;
}

my %CMDS = ("rename" => [\&opts_rename, \&cmd_rename],
	    "header" => [\&opts_header, \&cmd_header],
#	    "dump"   => [\&opts_dump, \&cmd_dump],
	    "help"   => [\&opts_help, undef],
	   );

my $USAGE_ALL = qq{Usage: tes3cmd {@{[join('|', sort keys %CMDS)]}} OPTIONS plugins...

For help on subcommands: tes3cmd help subcommand

};
sub add_alias {
    my($name, $alias) = @_;
    $CMDS{$alias} = $CMDS{$name};
    $USAGE_ALL .= " $alias is an alias for subcommand: $name\n"
}
# add shortcut aliases for convenience
add_alias("header", "hdr");
add_alias("rename", "ren");

sub opts_help {
    if (my $cmd_name = shift(@ARGV)) {
	if (my $cmd_ref = $CMDS{$cmd_name}) {
	    $cmd_ref->[0]->(1);	# exits
	} else {
	    die $USAGE_ALL;
	}
    }
    die $USAGE_ALL;
}

sub chop_nulls {
    my($str) = @_;
    $str =~ tr/\000//d;
    return($str);
}

sub write_header_field {
    my($plugin, $origval, $val, $label, $offset, $fieldlen) = @_;
    if ($val =~ /^\+(.*)$/) {
	$val = $origval . $1;
    }
    $val =~ s/(\\r|\r)?(\\n|\n)/\r\n/g;
    # create an empty null padded field
    my $valz = "\000" x $fieldlen;
    # truncate $val to fit in the field, if necessary
    my $origlen = length($val);
    $val = substr($val, 0, $fieldlen - 1);
    if (length($val) < $origlen) {
	warn "Warning, input $label truncated because it exceeded field length of: $fieldlen\n";
    }
    # and plop the given string value into it, with at least one ending null
    substr($valz, 0, length($val)) = $val;
    unless(seek(PLUG, $offset, 0)) {
	warn "$plugin: Error seeking to start of $label field at offset: $offset ($!)\n";
	return(undef);
    }
    my $len = length($valz);
    my $nwritten = syswrite(PLUG, $valz);
    if ($nwritten != $len) {
	warn "$plugin: Error incomplete write to $label field ( ($!)\n";
	return(undef);
    }
    print qq{$plugin: $label set to: "$val"\n};
    return(1);
}

my $hdr_size = 16;
sub read_rec {
    my($expected_type) = @_;
    my $rec_hdr = "";
    my $n_read = sysread(INP, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef);
    }
    if ($n_read != $hdr_size) {
	warn "Error(hdr): asked for $hdr_size bytes, got $n_read\n";
	return(undef);
    }
    my($rec_type, $rec_len, $unk, $flags) = unpack("a4LLL", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rec_type) {
	warn "Error: Expected: $expected_type, got: $rec_type\n";
	return(undef);
    }
    my $rec = "";
    $n_read = sysread(INP, $rec, $rec_len);
    if ($n_read != $rec_len) {
	warn "Error(rec): asked for $rec_len bytes, got $n_read\n";
	return(undef);
    }
    return($rec_type, $rec, $unk, $flags);
}

sub write_rec {
    my($rec_type, $rec, $unk, $flags) = @_;
    print OUT pack("a4LLLa*", $rec_type, length($rec), $unk, $flags, $rec);
}

sub parse_subrec {
    my($rec) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @subrecs = ();
    my $name_idx;
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$name_idx = scalar(@subrecs) if ((not defined $name_idx) and ($subrec_type eq $REN_SUBTYPE));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@subrecs, [$subrec_type, $val]) if (defined $val);
	$p += $subrec_len;
    }
    return(\@subrecs, $name_idx);
}

sub new_rec {
    my($sub_recs) = @_;
    my @rec;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	my $len = length($val);
	push(@rec, pack("a4La*", $type, $len, $val));
    }
    return(join("", @rec));
}

sub allowed_cell_type {
    my($sub_recs) = @_;
    return 1 unless ($::opt_i or $::opt_e);
    my $data;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	if ($type eq "DATA") {
	    $data = $val;
	    last;
	}
    }
    my($flags) = unpack("L", $data);
    if ($::opt_i) {
	return($flags & 1);	# is interior
    } else {			# opt_e
	return(not($flags & 1)); # is exterior
    }
}

sub pprec {
    my($rec, $subtype) = @_;
    print "DBG: pprec($rec)\n" if (DBG);
    my $recstr = join(":", grep(!/[^[:print:]]/, map { s/\000+$//; $_; } split(/\000?([A-Z][A-Z_][A-Z_][A-Z_\d])...\000/, $rec)));
    $recstr =~ s/^:$subtype:.*?:// if ($subtype);
    $recstr =~ s/:([A-Z][A-Z_][A-Z_][A-Z_\d])/|$1/g;
    return(substr($recstr, 0, $::opt_w));
}

sub cmd_rename {
    my($plugin) = @_;
    my $newplugin = $plugin;
    $newplugin =~ s/(\.es[mp])$/_new$1/i;
    if ($newplugin eq $plugin) {
	warn "Error, $plugin name does not end in .esm or .esp?\n";
	return;
    }
    print "\n$plugin: RENAMING CELLS:\n" unless ($::opt_l);
    unless(open(INP, "<$plugin")) {
	warn "Error opening $plugin for input ($!)\n";
	return;
    }
    unless($::opt_l) {
	unless(open(OUT, ">$newplugin")) {
	    warn "Error opening $newplugin for output ($!)\n";
	    return;
	}
	unless(binmode(OUT, ':raw')) {
	    warn "Error setting binmode on $newplugin ($!)\n";
	    close(OUT);
	    return;
	}
    }
    my $expected = "TES3";
    while (my($rec_type, $rec, $unk, $flags) = read_rec($expected)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	if ($rec_type eq $REN_TYPE) {
	    my $renamed = 0;
	    my($subrecs, $name_idx) = parse_subrec($rec);
	    if (defined($name_idx) and
		my $name = $subrecs->[$name_idx]->[1]) {
		$name = chop_nulls($name);
		if ($::opt_l) {	# only list records
		    my $recstr = pprec($rec, $REN_SUBTYPE);
		    printf qq{  $rec_type  %-30s [%s]\n}, $name, $recstr;
		} else {	# rename records
		    my $do_rename = 1;
		    $do_rename = 0 if ($rec_type eq "CELL" and not allowed_cell_type($subrecs));
		    if ($do_rename) {
			my $newname;
			eval qq{(\$newname = \$name) =~ s!$REN_FROM!$REN_TO!g};
			if ($name ne $newname) {
			    $subrecs->[$name_idx]->[1] = "$newname\000";
			    $renamed = 1;
			    printf qq{    Renaming: $REN_TYPE %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			}
		    }
		}
	    } else {
		print "Error, Record has no $REN_SUBTYPE subrecord: $rec\n";
	    }
	    $rec = new_rec($subrecs) if $renamed;
	}
	write_rec($rec_type, $rec, $unk, $flags) unless($::opt_l);
    }
    close(INP);
    unless ($::opt_l) {
	close(OUT);
	print "Output saved in: $newplugin\n";
    }
}

sub cmd_header {
    my($plugin) = @_;
    unless(open(PLUG, "+<$plugin")) {
	warn "Error opening $plugin for read/write ($!)\n";
	return;
    }
    unless(binmode(PLUG)) {
	warn "Error setting binmode on $plugin ($!)\n";
	close(PLUG);
	return;
    }
    my $block;
    my $nread = read(PLUG, $block, 4096);
    if ($nread == 0) {
	warn "$plugin: Error on intial read ($!)\n";
	close(PLUG);
	return;
    }
    my $magic = substr($block, 0, 4);
    if ($magic eq "TES3") {
	if ($nread >= 362) { 	# minimum TES3 plugin size
	    my $auth = chop_nulls(substr($block, $HDR_AUTH_OFFSET, $HDR_AUTH_LENGTH));
	    my $desc = chop_nulls(substr($block, $HDR_DESC_OFFSET, $HDR_DESC_LENGTH));
	    if ($::opt_a or $::opt_d) {
		if ($::opt_a) {
		    if (not defined write_header_field($plugin, $auth, $::opt_a, "AUTHOR", $HDR_AUTH_OFFSET, $HDR_AUTH_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
		if ($::opt_d) {
		    if (not defined write_header_field($plugin, $desc, $::opt_d, "DESCRIPTION", $HDR_DESC_OFFSET, $HDR_DESC_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
	    } else {
		if ($::opt_m) {
		    print "$plugin:\n  AUTH=$auth\n  DESC=$desc\n";
		} else {
		    print "$plugin: AUTH=$auth DESC=$desc\n";
		}
	    }
	}
    } elsif ($magic eq "TES4") {
	warn "This function is not yet implemented for TES4 files\n";
    } else {
	warn "$plugin: Error, this does not appear to be an elder scrolls plugin\n";
    }
    close(PLUG);
}

sub main {
    if (scalar(@ARGV) == 0) {
	print $USAGE_ALL;
	exit(0);
    }
    my $cmd_ref;
    my $cmd_name = shift(@ARGV);
    die $USAGE_ALL unless ($cmd_ref = $CMDS{$cmd_name});
    my($cmd_getopts, $cmd) = @{$cmd_ref};
    $cmd_getopts->();
    for my $plugin (@ARGV) {
	$cmd->($plugin);
    }
}

main();
