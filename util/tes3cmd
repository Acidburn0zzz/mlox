#!/usr/bin/perl
#Version: 0.37
# tes3cmd: command line tool to do various hackage on a TES3 plugin
# Copyright 2010 by John Moonsugar
# Distributed as part of the mlox project:
#   http://code.google.com/p/mlox/
# under the MIT License:
#   http://code.google.com/p/mlox/source/browse/trunk/License.txt
# Documentation:
#   http://code.google.com/p/mlox/wiki/Tes3cmd

# TBD:
# canonize common switches (-i is always "ID")
# combine "delete" and "objdelete", fixup subrecord deletion
# rewrite commands to use the "process" subroutines
# and add more examples, esp. "modify"
# write some tests
# GUI
# clean up the TOSTR stuff (for pretty print command) so it uses the codec defs
# reformat overdial output, just list each topic once, with list of plugins that have it
# implement script compiler
# annotate cell objects with their rectypes!
# update NAM0 after cell object deletion
# add new commands:
# * "undump" (text to record, can't undump from wrong version)
# * "combine" (merge listed plugins into one plugin)
# * "conflict" (detailed report, toggle mergeable records from report)
# * "lint" (splice in tes3lint functionality)
# * "multipatch", to include:
# ** cellnamepatch + undo spurious AMBI/WHGT reversion
# ** fogpatch
# ** generate book rotate scripts.
# ** generate multimark scripts.
# ** gmst/global tweaks: (timescale, fCombatAngleXY)
# ** import faces/hairs (avoid conflicts by dropping rest of object definition)
# ** merged leveled lists
# ** merged objects (add mergeable flag to record defs)
# ** summoned creatures persists patch
# ** turn-off auto-calced spells.

use Carp;
use Cwd;
use IO::Handle;
use File::Basename;
use File::Spec;
use File::Copy;
use Getopt::Std;
use Data::Dumper;
use Storable;
use strict;

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant DBG => grep(/^(?:-D)$/, @ARGV);
}

###GLOBALS (Miscellaneous)

my $DUMP_VERSION = "0.1";	# so undump won't use wrong format version
my $DATADIR;			# where "Data Files" lives.
my $TES3CMD_DIR;		# tes3cmd directory under "Data Files" (for cache, ...)
my $MASTER_ID;			# data loaded from masters
my $GLOBCHARS = '*?';		# for filename matching
my $REC_TYPE_LEN = 4;

# for fast HEDR updating header command
my $HDR_AUTH_OFFSET = 32;
my $HDR_AUTH_LENGTH = 32;
my $HDR_DESC_OFFSET = $HDR_AUTH_OFFSET + $HDR_AUTH_LENGTH;
my $HDR_DESC_LENGTH = 256;
my $HDR_NREC_OFFSET = $HDR_DESC_OFFSET + $HDR_DESC_LENGTH;

my $hedr = pack("a4L/a*", 'HEDR', pack("fLZ32Z256L", (my $ver = 1.3), (my $is_master = 0), (my $auth = "tes3cmd"), (my $desc = "(generated)"), (my $nrec = 0)));
my $blank_header = pack("a4LLLa*", 'TES3', length($hedr), (my $unk = 0), (my $flags = 0), $hedr);

###USAGES

my $RECOVER_USAGE = q{Usage: tes3cmd recover OPTIONS plugin...

OPTIONS
 -D  print debug output.

Attempts to recover readable records from a damaged plugin. You should only
use this when Morrowind gives the following type of error on your plugin:

"Trying to load a bad form in TES3File::NextForm"

The main reason you would get this error is if the file has been physically
corrupted, where records have been overwritten with random binary junk, or
if the file has been truncated, or otherwise damaged.

This is not for fixing what is commonly referred to as "savegame corruption",
which in fact, is not corruption, but bad data.

In any case, you will get detailed output on what tes3cmd finds damaged.

Example(s):

# fix my damaged plugin:
tes3cmd recover "my plugin.esp"
};

sub opts_recover {
    $_[0] && do { die $RECOVER_USAGE; };
    getopts('D') or die $RECOVER_USAGE;
}

my $CLEAN_USAGE = q{Usage: tes3cmd clean OPTIONS plugin...

OPTIONS
 -a      clean all
 -c      clean cell sub-records AMBI,WHGT when same as masters
 -d      clean other complete records duped from masters
 -g      clean evil gmsts
 -j      clean junk cells (no new info from definition in masters)
 -o      clean objects from cells unchanged from masters
 -O dir  output directory (default is same as plugin being cleaned)
 -R      Replace original with cleaned version (original is backed up)

Cleans plugins of various junk. If no cleaning options are selected, the
default is to assume the options: -c, -d, -g, -j, -o. It should always be safe
to use the "clean" command with no options to get the default cleaning
behavior.

An Evil GMST is defined as a GMST from the list of 11 Tribunal GMSTs or 61
Bloodmoon GMSTs that are inadvertently introduced to a plugin by the
Construction Set with specific values. Other GMSTs or GMSTs from those lists
that do not have the specific Evil Values are NOT cleaned. For details on Evil
GMSTs, see:

  http://www.wikihost.org/w/mlox/evil_gmsts/

Junk cells are bogus external CELL records that crop up in many plugins due
to a Construction Set bug. They contain only NAME, DATA and sometimes RGNN
sub-records with data identical to the master.

Example(s):

# clean my plugin of only Evil GMSTs:
tes3cmd clean -g "my plugin.esp"

# clean 2 plugins and put the cleaned versions in a subdirectory "Clean":
tes3cmd clean -O Clean plugin1.esp plugin2.esp

# clean all plugins in the current directory, replacing the originals with
# the cleaned versions and save the diagnostic output to a file (clean.txt):
tes3cmd clean -R *.esm *.esp > clean.txt

};

sub opts_clean {
    $_[0] && do { die $CLEAN_USAGE; };
    getopts('DacdgjoO:R') or die $CLEAN_USAGE;
    unless ($::opt_c or $::opt_d or $::opt_g or $::opt_j or $::opt_o) {
	# turn on all safe cleaning options if none are selected.
	$::opt_c = $::opt_d = $::opt_g = $::opt_j = $::opt_o = 1;
    }
    if ($::opt_a) {
	# turn on all cleaning options
	$::opt_c = $::opt_d = $::opt_g = $::opt_j = $::opt_o = 1;
    }
}

my $ESP_USAGE = q{Usage: tes3cmd esp OPTIONS master...

OPTIONS
 -D    turn on debug output
 -o    overwrite output if it exists

Converts input master (.esm) into a plugin (.esp).

Example(s):

# output is: "my plugin.esp"
tes3cmd esp "my plugin.esm"

};

sub opts_esp {
    $_[0] && do { die $ESP_USAGE; };
    getopts('Do') or die $ESP_USAGE;
}

my $ESM_USAGE = q{Usage: tes3cmd esm OPTIONS plugin...

OPTIONS
 -D        turn on debug output
 -o    overwrite output if it exists

Converts input plugin (.esp) into a master (.esm).

Example(s):

# output is: "my plugin.esm"
tes3cmd esm "my plugin.esp"
};

sub opts_esm {
    $_[0] && do { die $ESM_USAGE; };
    getopts('Do') or die $ESM_USAGE;
}

my $MODIFY_USAGE = q{Usage: tes3cmd modify OPTIONS plugin...

OPTIONS
 -D        turn on debug output
 -i ids    only modify the records with ids matching the given /-delimited
           list of regular expression patterns.
 -f file   file containing list of regexes to match, one per line.
 -F file   file containing list of regexes to not match, one per line.
 -m regex  only modify records that match given regular expression.
 -M regex  only modify records that do not match given regular expression.
 -s        only modify the sub-records that matched.
 -t types  only modify the records matching the given /-delimited
           list of record types.
 -r /a/b/  replace regex a with b. you can use any character instead of the slash.
 -e 'code' specify a string of Perl code to run on each matched record.
 -p file   specify a file containing Perl code to load.

Modifies records/sub-records from the plugin. You can really damage things with
this command, so be careful!

Helper Functions: dumprec() and setrec()

tes3cmd includes 2 builtin helper functions to help you make your
modifications: dumprec() and setrec(). Use dumprec() to print out a view of
the records. If you just use: "-e 'dumprec()'", you will get an idea of the
record structure. Both functions take the same 2 arguments. The first is a
reference to a Perl hash containing any or all of these keys: "i" (sub-record
Index), "t" (sub-record Type), "f" (sub-record Field). "i" will constrain
matching of sub-records to subrecords by index. "t" specifies a sub-record
type match, and "f" specifies a field name to match. The final argument to
setrec() is the value to assign to matching fields.

Note: tes3cmd uses Perl regular expressions for matching, the full documentation
can be found here:   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^$()[]{}" have special
meaning in a regular expression and that they are unlike characters used for
matching on a Windows command line.

Example(s):

# print the first 4 subrecords of the cell "Ashmelech" from Morrowind.esm
tes3cmd modify -t cell -i ashmelech -e 'dumprec({i=>[0..3]})' Morrowind.esm

# Problem: Aleanne's clothing mods do not have restocking inventory
# Solution: create a small patch to change the counts for inventory containers
#   to negative numbers so they will be restocking.
# Step 0: confirm the problem, showing the non-negative counts:
tes3cmd print -t cont ale_clothing_v?.esp
# Step 1: Create the patch file containing just the container records:
tes3cmd print -R -t cont ale_clothing_v?.esp > ale_patch.esp
# Step 2: Change all the count fields for the containers in Aleanne's Clothing to -3 (for restocking wares)
tes3cmd modify -t cont -e "setrec({f=>'Count'}, -3)" ale_patch.esp
# Note: on Linux, the quoting would be a little different:
tes3cmd modify -t cont -e 'setrec({f=>"Count"}, -3)' ale_patch.esp

};

sub opts_modify {
    $_[0] && do { die $MODIFY_USAGE; };
    getopts('Df:F:e:i:m:M:p:r:st:') or die $MODIFY_USAGE;
}

my $CELLNAMEPATCH_USAGE = q{Usage: tes3cmd cellnamepatch

OPTIONS
 -D        turn on debug output

Creates a patch plugin to ensure renamed cells are not accidentally reverted
to their original name.

This command solves the following plugin conflict that causes bugs:
* Master A names external CELL (1, 1) as: "".
* Plugin B renames CELL (1, 1) to: "My City".
* Plugin C modifies CELL (1, 1), using the original name "", reverting
  plugin B's renaming.
* References in plugin B (such as in scripts) that refer to "My City" break.

This command scans your currently active plugin load order for cell name
reversions, and ensures whenever possible that cell renaming is properly
maintained. You should regenerate your cellnamepatch whenever you change your
load order.

Example(s):

# Create the patch plugin "cellnamepatch.esp"
tes3cmd cellnamepatch

};

sub opts_cellnamepatch {
    $_[0] && do { die $CELLNAMEPATCH_USAGE; };
    getopts('D') or die $CELLNAMEPATCH_USAGE;
}


my $FOGPATCH_USAGE = q{Usage: tes3cmd fogpatch

OPTIONS
 -D        turn on debug output

Some video cards are affected by how Morrowind handles a fog density setting
of zero in interior cells with the result that the interior is pitch black,
except for some light sources, and no amount of light, night-eye, or gamma
setting will make the interior visible. This is known as the "fog bug". 

This command creates a patch plugin that fixes all fogbugged cells in your
active plugins by setting the fog density of those cells to a non-zero value.
You should regenerate your fogpatch whenever you change your load order.

Example(s):

# Create the patch plugin fogpatch.esp
tes3cmd fogpatch

};

sub opts_fogpatch {
    $_[0] && do { die $FOGPATCH_USAGE; };
    getopts('D') or die $FOGPATCH_USAGE;
}


my $DELETE_USAGE = q{Usage: tes3cmd delete OPTIONS plugin...

OPTIONS
 -D        turn on debug output
 -i ids    only delete the records with ids matching the given /-delimited
           list of regular expression patterns.
 -f file   file containing list of regexes to match, one per line.
 -F file   file containing list of regexes to not match, one per line.
 -m regex  only delete records that match given regular expression.
 -M regex  only delete records that do not match given regular expression.
 -s        apply matching/deleting only to sub-records, not whole records.
 -t types  only delete the records matching the given /-delimited
           list of record types.

Deletes records/sub-records from the plugin. You can really damage things with
this command, so be careful!

Note: you must specify at least one of: -i, -m or -M to ensure deletions are
intentional.

Note: tes3cmd uses Perl regular expressions for matching, the full documentation
can be found here:   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^$()[]{}" have special
meaning in a regular expression and that they are unlike characters used for
matching on a Windows command line.

Example(s):

# Delete all records with IDs matching "foo":
# Note that this doesn't also delete records that may depend on "foo".
tes3cmd delete -i foo "my plugin.esp"

# Delete all sub-records of type NPC_.NPCO that match "Ring des Skeletts" from
# savegame: quicksave.ess
tes3cmd delete -s -t npc_.npco -m "Ring des Skeletts" "quicksave.ess"
};

sub opts_delete {
    $_[0] && do { die $DELETE_USAGE; };
    getopts('Df:i:m:M:st:') or die $DELETE_USAGE;
}


my $OBJDELETE_USAGE = q{Usage: tes3cmd objdelete OPTIONS plugin...

OPTIONS
 -D        turn on debug output
 -i ids    only delete the objects from cells matching the given /-delimited
           list of regular expression patterns.
 -m regex  only delete objects that match given regular expression.
 -M regex  only delete objects that do not match given regular expression.
 -l        just list cell objects to be deleted, do not actually delete.

Deletes objects from cells in the given plugin. You can really damage things with
this command, so be careful!

Note: you must specify at least one of: -i, -m or -M to ensure deletions are
intentional.

Note: tes3cmd uses Perl regular expressions for matching, the full documentation
can be found here:   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^$()[]{}" have special
meaning in a regular expression and that they are unlike characters used for
matching on a Windows command line.

Example(s):

# Delete some daedric bats from Creatures mod:
tes3cmd objdelete -m plx_ex_daed_bat "Creatures.esp"
};

sub opts_objdelete {
    $_[0] && do { die $OBJDELETE_USAGE; };
    getopts('Di:lm:M:') or die $OBJDELETE_USAGE;
}


my $OVERDIAL_USAGE = q{Usage: tes3cmd overdial OPTIONS plugin...

OPTIONS
 -D   turn on debug output
 -1   only test to see if dialog in the first plugin is overlapped. (by default
      all plugins are checked against all other plugins, which is an n-squared
      operation, meaning "possibly very slow").

Prints the IDs of dialog records that overlap from the set of given plugins.

An overlap is defined as a dialog (DIAL) Topic from one plugin that entirely
contains a dialog Topic from another plugin as a substring. For example, the
mod "White Wolf of Lokken" has a dialog topic "to rescue me" which overlaps
with the dialog topic "rescue me" from "Suran Underworld", which causes the
"Special Guest" quest from SU to get stuck because Ylarra won't offer the
topic "rescue me" when you find her in her cell.

Note that overlap is only a potential problem if the plugins are loaded in the
order they are listed in the output.

Example(s):

# Show dialog overlaps between Lokken and SU:
tes3cmd overdial "BT_Whitewolf_2_0.esm" "Suran_Underworld_2.5.esp"
};

sub opts_overdial {
    $_[0] && do { die $OVERDIAL_USAGE; };
    getopts('1D') or die $OVERDIAL_USAGE;
}

my $COMMON_USAGE = q{Usage: tes3cmd common OPTIONS plugin1 plugin2

OPTIONS
 -D   turn on debug output

Prints the IDs of records that the 2 given plugins have in common.

Example(s):

# Show the records in common between my plugin and Morrowind.esm:
tes3cmd common "my plugin.esp" "Morrowind.esm"
};

sub opts_common {
    $_[0] && do { die $COMMON_USAGE; };
    getopts('D') or die $COMMON_USAGE;
}


my $DIFF_USAGE = q{Usage: tes3cmd diff OPTIONS plugin1 plugin2

OPTIONS
 -D          turn on debug output.
 -i          /-delimited list of field names to ignore.
 -o OPTLIST  /-delimited list of reports to give

Prints a report on the differences between the two TES3 files.
A summary report with up to four sections is printed to standard output
that gives an overview of differences, as lists of record IDs:
 - (e1) objects in plugin1 that do not exist in plugin2
 - (e2) objects in plugin2 that do not exist in plugin1
 - (eq) objects in plugin1 that are equal in plugin2
 - (ne) objects in plugin1 that are different in plugin2
(The token in parentheses denotes the name of the report, which is
selectable via the -o option. Sections that would have no items are
not printed).

When objects in plugin1 are different in plugin2, each of these objects
is printed in detail to a file "plugin1.diff" and "plugin2.diff", which
can then be compared textually using a tool such as WinMerge or Emacs'
ediff function.

To reduce a great deal of "uninteresting" differences when diffing savegames,
CELL.FRMR records are automatically ignored when the ModIndex is zero. (Note
that in this case, the ObjIndex appears to only be incremented by one).


Example(s):

# Print report on differences between 2 savegames (output to diff.out):
tes3cmd diff "save1000.ess" "save2000.ess" > diff.out

# You can also use the -i switch to ignore further subfields in order to help
# reduce the amount of differences as in the following example.
# Report on differences, but ignore the subfields CREA.AIDT and CELL.ND3D:
tes3cmd diff -i crea.aidt,cell.nd3d testa0000.ess testb0000.ess > diff.out

# Just print the records that differ
tes3cmd diff -o ne "my plugin1.esp" plugin2.esp
};

sub opts_diff {
    $_[0] && do { die $DIFF_USAGE; };
    getopts('Di:o:') or die $DIFF_USAGE;
}


my $PRINT_USAGE = q{Usage: tes3cmd print OPTIONS plugin...

OPTIONS
 -D        turn on debug output.
 -C regex  when printing cells, only print the matching objects in the cell.
 -i ids    only print out the records with ids matching the given /-delimited
           list of regular expression patterns.
 -l        only list the ids of the records to be printed, instead of the entire record.
 -f file   file containing list of regexes to match, one per line.
 -F file   file containing list of regexes to not match, one per line.
 -m regex  only print records that match given regular expression.
 -M regex  only print records that do not match given regular expression.
 -n        do not print banner identifying the current plugin.
 -R        print raw records, instead of as text, as an .esp including a TES3 header.
 -r        print raw records, instead of as text.
 -s string specify field separator string for single-line output.
 -t types  only print out the records matching the given /-delimited
           list of record types.

Prints the plugin to stdout in text form for easy perusal. For large plugins,
the output can be voluminous.

Note: tes3cmd uses Perl regular expressions for matching, the full documentation
can be found here:   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^$()[]{}" have special
meaning in a regular expression and that they are unlike characters used for
matching on a Windows command line.

Example(s):

# Print all records from a plugin (this could generate a lot of output):
tes3cmd print "my plugin.esp"

# Print all records with IDs matching "foo":
tes3cmd print -i foo "plugin.esp"

# Print all the CELL records from a plugin:
tes3cmd print -t cell "plugin.esp"

# Print all cells from bradhia_v1_4.esp containing NPC named: "Maeve Jaste"
tes3cmd print -t cell -m "NAME:.*maeve.jaste" "bradhia_v1_4.esp"
};

sub opts_print {
    $_[0] && do { die $PRINT_USAGE; };
    getopts('c:Df:F:i:lm:M:nNRrs:t:') or die $PRINT_USAGE;
}

my $DUMP_USAGE = q{Usage: tes3cmd dump OPTIONS plugin...

OPTIONS
 -D        turn on debug output.
 -C regex  when dumping cells, only dump the matching objects in the cell.
 -i ids    only dump out the records with ids matching the given /-delimited
           list of regular expression patterns.
 -l        only list the ids of the records to be dumped, instead of the entire record.
 -f file   file containing list of regexes to match, one per line.
 -F file   file containing list of regexes to not match, one per line.
 -m regex  only dump records that match given regular expression.
 -M regex  only dump records that do not match given regular expression.
 -n        do not dump banner identifying the current plugin.
 -N        dump record numbers (starting from first dumped == 1).
 -R        dump raw records, instead of as text, as an .esp including a TES3 header.
 -r        dump raw records, instead of as text.
 -s string specify field separator string for single-line output.
 -t types  only dump out the records matching the given /-delimited
           list of record types.

Dumps the plugin to stdout in text form for easy perusal. For large plugins,
the output can be voluminous.

Note: tes3cmd uses Perl regular expressions for matching, the full documentation
can be found here:   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^$()[]{}" have special
meaning in a regular expression and that they are unlike characters used for
matching on a Windows command line.

Example(s):

# Dump all records from a plugin (this could generate a lot of output):
tes3cmd dump "my plugin.esp"

# Dump all records with IDs matching "foo":
tes3cmd dump -i foo "plugin.esp"

# Dump all the CELL records from a plugin:
tes3cmd dump -t cell "plugin.esp"

# Dump all cells from bradhia_v1_4.esp containing NPC named: "Maeve Jaste"
tes3cmd dump -t cell -m "NAME:.*maeve.jaste" "bradhia_v1_4.esp"
};

sub opts_dump {
    $_[0] && do { die $DUMP_USAGE; };
    getopts('c:Df:F:i:lm:M:nNRrs:t:') or die $DUMP_USAGE;
}

my $HEADER_USAGE = q{Usage: tes3cmd header OPTIONS plugin...

OPTIONS
 -D      turn on debug output
 -a XXX  set the Author field to the value XXX
 -d YYY  set the Description field to value YYY
 -m      multi-line output for listing field contents
 -n      update record count in header

When -a and -d are not given, the current Author/Description field contents
are printed.

Field values are normally replaced by the given string. But if the string
begins with a "+", the existing value is appended with the new given value.

If a given value contains the string "\\n", it will be replaced by a CRLF.

Note:
 - the Author value should fit in 31 bytes.
 - the Description value should fit in 255 bytes.

If the value supplied won't fit into the plugin header field, you will be
warned.

Example(s):

# Show the Author/Description fields for a plugin:
tes3cmd header "my plugin.esp"

# Set the Author field to "john.moonsugar":
tes3cmd header -a john.moonsugar "plugin.esp"

# Append " and friends" to the Author field:
tes3cmd header -a "+ and friends" "plugin.esp"

# Add a Version number to a plugin Description field:
tes3cmd header -d "+\nVersion: 1.0" "plugin.esp"
};

sub opts_header {
    $_[0] && do { die $HEADER_USAGE; };
    $::opt_v = 0;
    $::opt_a = "";
    $::opt_d = "";
    $::opt_m = undef;
    $::opt_v = 0.0;
    getopts('Da:d:mnv:') or die $HEADER_USAGE;
}

my $RENAME_USAGE = q{Usage: tes3cmd rename OPTIONS RECTYPE.SUBTYPE FROM TO plugin...

This first form of the command renames all records of type RECTYPE, replacing
the Perl regular expression FROM with the value of TO (which may contain
backreferences). The rename only happens if the CELL.NAME sub-record matches
the given FROM regular expression.

Note: tes3cmd uses Perl regular expressions for matching, the full documentation
can be found here:   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^$()[]{}" have special
meaning in a regular expression and that they are unlike characters used for
matching on a Windows command line.

tes3cmd rename -l RECTYPE.SUBTYPE plugin...

When the -l switch is given, records of the given type are only listed. (You
do not give a FROM or TO when using the -l option).

OPTIONS
 -D   turn on debug output
 -i   only rename if the record is an interior CELL.
 -e   only rename if the record is an exterior CELL.
 -l   just list the records, do not rename them.
 -w   size of printable window for record contents printed with -l switch.

The original input file is renamed to a backup, and changes are output to the
original filename.

Note that when renaming scripts, you can use either SCPT.SCTX or SCPT.SCHD as
the RECTYPE.SUBTYPE parameter, and the script name is changed in both
sub-records.

Example(s):

# rename all exterior cells to the null string:
tes3cmd rename -e CELL.NAME ".*" "" "my plugin.esp"

# do a caseless comparison with the FROM pattern:
tes3cmd rename cell.name "(?i)pelagaid" "Pelagiad" "plugin.esp"
(This would rename any name that has the string "pelagaid" in it with any form
of capitalization, to "Pelagiad").

# The following command will swap the first and last name of all NPCs using
# substitution backreferences (a very powerful feature of regular expressions):
tes3cmd rename npc_.fnam "^(\S+)\s(\S+)$" "$2 $1" "plugin.esp"
(Note that on Linux you may need to use single-quotes instead of double-quotes).
};

my($REN_FROM, $REN_TO, $REN_TYPE, $REN_SUBTYPE);
my @ren_valid_types =
    qw(GMST.NAME CLAS.NAME CLAS.FNAM FACT.NAME FACT.FNAM RACE.NAME RACE.FNAM
       SOUN.NAME SOUN.FNAM REGN.NAME REGN.FNAM BSGN.NAME BSGN.FNAM STAT.NAME
       DOOR.NAME DOOR.FNAM MISC.NAME MISC.FNAM WEAP.NAME WEAP.FNAM CONT.NAME
       CONT.FNAM SPEL.NAME SPEL.FNAM CREA.NAME CREA.FNAM LIGH.NAME LIGH.FNAM
       ENCH.NAME NPC_.NAME NPC_.FNAM ARMO.NAME ARMO.FNAM CLOT.NAME CLOT.FNAM
       REPA.NAME REPA.FNAM ACTI.NAME ACTI.FNAM APPA.NAME APPA.FNAM LOCK.NAME
       LOCK.FNAM PROB.NAME PROB.FNAM INGR.NAME INGR.FNAM BOOK.NAME BOOK.FNAM
       ALCH.NAME ALCH.FNAM LEVI.NAME CELL.NAME DIAL.NAME SCPT.SCHD SCPT.SCTX);
my %VALID_TYPE;
$VALID_TYPE{$_}++ foreach (@ren_valid_types);

sub opts_rename {
    $_[0] && do { die $RENAME_USAGE; };
    $::opt_v = 0;
    $::opt_l = 0;
    $::opt_i = 0;
    $::opt_e = 0;
    $::opt_w = 38;
    getopts('Deilvw:') or die $RENAME_USAGE;

    my $type = uc(shift(@ARGV)) or die "Missing required RECTYPE.SUBTYPE\n$RENAME_USAGE";
    die "Error: Invalid record type.subtype requested: $type\n\nI only know these:\n@ren_valid_types\n" unless ($VALID_TYPE{$type});
    ($REN_TYPE, $REN_SUBTYPE) = split(/\./, $type);

    unless ($::opt_l) {
	defined($REN_FROM = shift(@ARGV)) or die "Missing required FROM\n$RENAME_USAGE";
	defined($REN_TO = shift(@ARGV)) or die "Missing required TO\n$RENAME_USAGE";
    }
}

sub opts_wikiout {
    getopts('D') or die "Usage: tes3cmd -wikiout\n";
}

sub opts_codectest {
    getopts('Dx:') or die "Usage: tes3cmd -codectest [-x excluded_types]\n";
}

###UTILITIES

sub celldata {
    my($srh) = @_;
    my $data = $srh->{DATA}[0];
    my($flags, $fog_data) = unpack("Lx[L]f", $data);
    return(($flags & 1), $flags, $fog_data);
}

# is_interior($srh);
sub is_interior { unpack("L", $_[0]->{DATA}[0]) & 1 }

sub chop_nulls { unpack("Z*", $_[0]); }

sub fatal_error {
    my($msg) = @_;
    my $err = $!;
    my $diagnosis;
    if ($^O =~ /^MSWin/) {
	if ($err =~ /permission denied/i) {
	    $diagnosis =<<END
Permission errors may occur in recent versions of Windows (since Vista) due to
the UAC feature and new protected nature of "Program Files". The ideal
solution is to install Morrowind some place other than "Program Files", such
as "C:\Games\Morrowind". You can also try disabling UAC, although may make your
system less secure.
END
	}
    }
    die qq{FATAL ERROR: $msg ($err)$diagnosis\n"};
}

# return a dictionary of all the files found in the given directory.
# keys are lowercased for caseless file finding.
sub list_files {
    my($dir) = @_;
    my %files = ();
    if (opendir(DH, $dir)) {
	while (my $file = readdir(DH)) {
	    next if (($file eq '.') or ($file eq '..'));
	    $files{lc($file)} = $file;
	}
	closedir(DH);
    } else {
	fatal_error(qq{Opening "$dir"});
    }
    return(\%files);
}

# sort list of files by their modification date
sub sort_by_date {
    my($dir, @files) = @_;
    my $dirlist = list_files($dir);
    my @sorted = sort { (-M "$dir/$dirlist->{lc $b}") <=> (-M "$dir/$dirlist->{lc $a}") } @files;
    warn qq{DBG: sorted files:\n}, join("\n", @sorted), "\n" if (DBG);
    return(@sorted);
}

sub load_order {
    die "DATADIR not defined\n" unless (defined($DATADIR));
    my $datafiles = list_files($DATADIR);
    my $mwfiles = list_files("$DATADIR/..");
    my $ini = "$DATADIR/../$mwfiles->{'morrowind.ini'}";
    my @active;
    my $fh = IO::Handle->new();
    if (open($fh, "<$ini")) {
	warn qq{INI is: "$ini"\n} if (DBG);
	while (<$fh>) {
	    if (my($plugin) = (/GameFile\d+=([^\r\n]*)/)) {
		if ($datafiles->{lc $plugin}) {
		    warn qq{Found Gamefile: "$plugin"\n} if (DBG);
		    push(@active, $plugin);
		} else {
		    warn qq{MISSING Gamefile: "$1"\n} if (DBG);
		}
	    }
	}
    } else {
	warn qq{Error opening "$ini" for input ($!)\n};
    }
    my @sorted = sort_by_date($DATADIR, @active);
    return((grep(/\.esm$/i, @sorted), grep(/\.esp$/i, @sorted)));
}

# assuming the program is run somewhere under the Morrowind game directory, find the
# location of the "Data Files" directory by walking up the hierarchy.
sub find_datadir {
    return($DATADIR) if (defined($DATADIR));
    my $dir = Cwd::getcwd();
    warn "DBG: checking for data dir in: $dir\n" if (DBG);
    while (($dir =~ m!\bmorrowind\b!i) and (-d $dir)) {
	my $datadir = list_files($dir)->{"data files"};
	if ($datadir) {
	    $DATADIR = "$dir/$datadir";
	    print "DATADIR = $DATADIR\n";
	    $TES3CMD_DIR = "$DATADIR/tes3cmd";
	    return($DATADIR);
	}
	my @parts = split(m![\\/]!, $dir);
	pop(@parts);
	$dir = join("/", @parts);
	warn "DBG: checking for data dir in: $dir\n" if (DBG);
    }
    warn qq{Can't find "Data Files" directory. Won't be able to find masters\n};
    return(undef);		# not running under morrowind directory
}

sub allowed_cell_type {
    my($srl) = @_;
    return 1 unless ($::opt_i or $::opt_e);
    my $data;
    foreach my $pair (@$srl) {
	my($type, $val) = @$pair;
	if ($type eq "DATA") {
	    $data = $val;
	    last;
	}
    }
    my($flags) = unpack("L", $data);
    if ($::opt_i) {
	return($flags & 1);	# is interior
    } else {			# opt_e
	return(not($flags & 1)); # is exterior
    }
}

###DATA DEFINITIONS

# these types are for records to be cleaned from plugins when duped from a master:
my @CLEAN_DUP_TYPES =
    qw(ACTI ALCH APPA ARMO BODY BOOK BSGN CELL CLAS CLOT CONT CREA DOOR ENCH
       FACT GLOB GMST INFO INGR LAND LEVC LEVI LIGH LOCK MGEF MISC NPC_
       PGRD PROB RACE REGN REPA SCPT SKIL SNDG SOUN SPEL SSCR STAT WEAP);

# Evil GMSTs for Tribunal (values are hexencoded)
my %EVIL_TB =
    (scompanionshare => '5354525620436f6d70616e696f6e205368617265',
     scompanionwarningbuttonone => '53545256204c657420746865206d657263656e61727920717569742e',
     scompanionwarningbuttontwo => '535452562052657475726e20746f20436f6d70616e696f6e20536861726520646973706c61792e',
     scompanionwarningmessage => '5354525620596f7572206d657263656e61727920697320706f6f726572206e6f77207468616e207768656e20686520636f6e74726163746564207769746820796f752e2020596f7572206d657263656e6172792077696c6c207175697420696620796f7520646f206e6f7420676976652068696d20676f6c64206f7220676f6f647320746f206272696e67206869732050726f6669742056616c756520746f206120706f7369746976652076616c75652e',
     sdeletenote => '535452562044656c657465204e6f74653f',
     seffectsummonfabricant => '53545256207345666665637453756d6d6f6e466162726963616e74',
     slevitatedisabled => '53545256204c657669746174696f6e206d6167696320646f6573206e6f7420776f726b20686572652e',
     smagicfabricantid => '5354525620466162726963616e74',
     smaxsale => '53545256204d61782053616c65',
     sprofitvalue => '535452562050726f6669742056616c7565',
     steleportdisabled => '535452562054656c65706f72746174696f6e206d6167696320646f6573206e6f7420776f726b20686572652e',
     );

# Evil GMSTs for Bloodmoon (values are hexencoded)
my %EVIL_BM =
    (fcombatdistancewerewolfmod => '464c5456209a99993e',
     ffleedistance => '464c54562000803b45',
     fwerewolfacrobatics => '464c54562000001643',
     fwerewolfagility => '464c54562000001643',
     fwerewolfalchemy => '464c5456200000803f',
     fwerewolfalteration => '464c5456200000803f',
     fwerewolfarmorer => '464c5456200000803f',
     fwerewolfathletics => '464c54562000001643',
     fwerewolfaxe => '464c5456200000803f',
     fwerewolfblock => '464c5456200000803f',
     fwerewolfbluntweapon => '464c5456200000803f',
     fwerewolfconjuration => '464c5456200000803f',
     fwerewolfdestruction => '464c5456200000803f',
     fwerewolfenchant => '464c5456200000803f',
     fwerewolfendurance => '464c54562000001643',
     fwerewolffatigue => '464c5456200000c843',
     fwerewolfhandtohand => '464c5456200000c842',
     fwerewolfhealth => '464c54562000000040',
     fwerewolfheavyarmor => '464c5456200000803f',
     fwerewolfillusion => '464c5456200000803f',
     fwerewolfintellegence => '464c5456200000803f',
     fwerewolflightarmor => '464c5456200000803f',
     fwerewolflongblade => '464c5456200000803f',
     fwerewolfluck => '464c5456200000803f',
     fwerewolfmagicka => '464c5456200000c842',
     fwerewolfmarksman => '464c5456200000803f',
     fwerewolfmediumarmor => '464c5456200000803f',
     fwerewolfmerchantile => '464c5456200000803f',
     fwerewolfmysticism => '464c5456200000803f',
     fwerewolfpersonality => '464c5456200000803f',
     fwerewolfrestoration => '464c5456200000803f',
     fwerewolfrunmult => '464c5456200000c03f',
     fwerewolfsecurity => '464c5456200000803f',
     fwerewolfshortblade => '464c5456200000803f',
     fwerewolfsilverweapondamagemult => '464c5456200000c03f',
     fwerewolfsneak => '464c5456200000803f',
     fwerewolfspear => '464c5456200000803f',
     fwerewolfspeechcraft => '464c5456200000803f',
     fwerewolfspeed => '464c54562000001643',
     fwerewolfstrength => '464c54562000001643',
     fwerewolfunarmored => '464c5456200000c842',
     fwerewolfwillpower => '464c5456200000803f',
     iwerewolfbounty => '494e54562010270000',
     iwerewolffightmod => '494e54562064000000',
     iwerewolffleemod => '494e54562064000000',
     iwerewolfleveltoattack => '494e54562014000000',
     seditnote => '535452562045646974204e6f7465',
     seffectsummoncreature01 => '53545256207345666665637453756d6d6f6e43726561747572653031',
     seffectsummoncreature02 => '53545256207345666665637453756d6d6f6e43726561747572653032',
     seffectsummoncreature03 => '53545256207345666665637453756d6d6f6e43726561747572653033',
     seffectsummoncreature04 => '53545256207345666665637453756d6d6f6e43726561747572653034',
     seffectsummoncreature05 => '53545256207345666665637453756d6d6f6e43726561747572653035',
     smagiccreature01id => '5354525620734d61676963437265617475726530314944',
     smagiccreature02id => '5354525620734d61676963437265617475726530324944',
     smagiccreature03id => '5354525620734d61676963437265617475726530334944',
     smagiccreature04id => '5354525620734d61676963437265617475726530344944',
     smagiccreature05id => '5354525620734d61676963437265617475726530354944',
     swerewolfalarmmessage => '5354525620596f752068617665206265656e206465746563746564206368616e67696e672066726f6d20612077657265776f6c662073746174652e',
     swerewolfpopup => '535452562057657265776f6c66',
     swerewolfrefusal => '5354525620596f752063616e6e6f7420646f207468697320617320612077657265776f6c662e',
     swerewolfrestmessage => '5354525620596f752063616e6e6f74207265737420696e2077657265776f6c6620666f726d2e',
    );

my @beth_levc =
    ('bm_ex_berserkers',
     'bm_ex_felcoast',
     'bm_ex_felcoast_40',
     'bm_ex_felcoast_60',
     'bm_ex_felcoast_sleep',
     'bm_ex_hirforest',
     'bm_ex_hirforest_40',
     'bm_ex_hirforest_60',
     'bm_ex_hirforest_sleep',
     'bm_ex_horker_h20',
     'bm_ex_horker_lake',
     'bm_ex_isinplains',
     'bm_ex_isinplains_40',
     'bm_ex_isinplains_60',
     'bm_ex_isinplains_sleep',
     'bm_ex_moemountains',
     'bm_ex_moemountains_40',
     'bm_ex_moemountains_60',
     'bm_ex_moemountains_sleep',
     'bm_ex_reaver_archers',
     'bm_ex_reavers',
     'bm_ex_rieklingpatrols',
     'bm_ex_rieklingpatrols_20',
     'bm_ex_rieklingpatrols_40',
     'bm_ex_rieklingpatrols_60',
     'bm_ex_smugglers',
     'bm_ex_wolfpack',
     'bm_ex_wolfpack_20',
     'bm_ex_wolfpack_40',
     'bm_ex_wolfpack_60',
     'bm_frysehag_all',
     'bm_in_berserker_20',
     'bm_in_berserker_40',
     'bm_in_berserker_60',
     'bm_in_frysehag_20',
     'bm_in_frysehag_40',
     'bm_in_frysehag_8',
     'bm_in_icecaves',
     'bm_in_icecaves_40',
     'bm_in_icecaves_60',
     'bm_in_nordburial',
     'bm_in_nordburial_40',
     'bm_in_nordburial_60',
     'bm_werewolf_connor',
     'bm_werewolf_wilderness01',
     'bm_werewolf_wilderness02',
     'bm_werewolf_wilderness03',
     'bm_werewolf_wilderness04',
     'bm_werewolf_wilderness05',
     'bm_werewolf_wilderness06',
     'bm_werewolf_wilderness07',
     'bm_werewolf_wilderness08',
     'bm_werewolf_wilderness09',
     'db_assassins',
     'ex_ascadianisles_lev+0',
     'ex_ascadianisles_lev+2',
     'ex_ascadianisles_lev-1',
     'ex_ascadianisles_sleep',
     'ex_azurascoast_lev+0',
     'ex_azurascoast_lev+2',
     'ex_azurascoast_lev-1',
     'ex_azurascoast_sleep',
     'ex_bittercoast_lev+0',
     'ex_bittercoast_lev+2',
     'ex_bittercoast_lev-1',
     'ex_bittercoast_sleep',
     'ex_grazelands_lev+0',
     'ex_grazelands_lev+2',
     'ex_grazelands_lev-1',
     'ex_grazelands_sleep',
     'ex_molagmar_lev+0',
     'ex_molagmar_lev+2',
     'ex_molagmar_lev-1',
     'ex_molagmar_sleep',
     'ex_redmtn_all_lev+0',
     'ex_redmtn_all_lev+2',
     'ex_redmtn_all_lev-2',
     'ex_redmtn_all_sleep',
     'ex_sheogorad_lev+0',
     'ex_sheogorad_lev+2',
     'ex_sheogorad_lev-1',
     'ex_sheogorad_sleep',
     'ex_shore_all_lev+0',
     'ex_shore_all_lev+2',
     'ex_shore_all_lev-2',
     'ex_shore_cliffracer_lev+0',
     'ex_shore_cliffracer_lev+2',
     'ex_shore_cliffracer_lev-2',
     'ex_shore_mudcrab',
     'ex_westgash_lev+0',
     'ex_westgash_lev+2',
     'ex_westgash_lev-1',
     'ex_westgash_sleep',
     'ex_wild_all_lev+0',
     'ex_wild_all_lev+2',
     'ex_wild_all_lev-1',
     'ex_wild_all_sleep',
     'ex_wild_netch_lev+0',
     'ex_wild_netch_lev+2',
     'ex_wild_netch_lev-1',
     'ex_wild_rat_lev+0',
     'ex_wild_rat_lev+2',
     'ex_wild_rat_lev-2',
     'h2o_all_lev+0',
     'h2o_all_lev+2',
     'h2o_all_lev-2',
     'h2o_slaughterfish',
     'in_6th_all_lev+0',
     'in_6th_all_lev+2',
     'in_6th_all_lev-2',
     'in_6th_ash_lev+0',
     'in_6th_ash_lev+2',
     'in_6th_ash_lev-2',
     'in_cave_alit_lev+0',
     'in_cave_alit_lev+2',
     'in_cave_alit_lev-1',
     'in_cave_all_lev+0',
     'in_cave_all_lev+2',
     'in_cave_all_lev-1',
     'in_cave_kagouti_lev+0',
     'in_cave_kagouti_lev+2',
     'in_cave_kagouti_lev-1',
     'in_cave_nix_lev+0',
     'in_cave_nix_lev+2',
     'in_cave_nix_lev-1',
     'in_dae_all_lev+0',
     'in_dae_all_lev+2',
     'in_dae_all_lev-2',
     'in_dae_atronach_lev+0',
     'in_dae_atronach_lev+2',
     'in_dae_atronach_lev-2',
     'in_dae_clanfear_lev+0',
     'in_dae_clanfear_lev+2',
     'in_dae_clanfear_lev-2',
     'in_dae_dremora_lev+0',
     'in_dae_dremora_lev+2',
     'in_dae_dremora_lev-2',
     'in_durzogs',
     'in_dwe_all_lev+0',
     'in_dwe_all_lev+2',
     'in_dwe_all_lev-2',
     'in_dwe_all_tribunal',
     'in_dwe_cent_lev+0',
     'in_dwe_cent_lev+2',
     'in_dwe_cent_lev-2',
     'in_egg_all_lev+0',
     'in_egg_all_lev+2',
     'in_egg_all_lev-1',
     'in_egg_kwama_blight_lev+0',
     'in_egg_kwama_blight_lev+2',
     'in_egg_kwama_blight_lev-1',
     'in_egg_kwama_lev+0',
     'in_egg_kwama_lev+2',
     'in_egg_kwama_lev-1',
     'in_egg_kwama_mined',
     'in_egg_scrib_lev+0',
     'in_egg_scrib_lev+2',
     'in_egg_scrib_lev-1',
     'in_goblins',
     'in_tomb_all_lev+0',
     'in_tomb_all_lev+2',
     'in_tomb_all_lev-2',
     'in_tomb_all_lev_trib',
     'in_tomb_bone_lev+0',
     'in_tomb_bone_lev+2',
     'in_tomb_bone_lev-2',
     'in_tomb_skele_lev+0',
     'in_tomb_skele_lev+2',
     'in_tomb_skele_lev-2',
     'in_vamp_cattle',
     'in_vamp_cattle_aun',
     'in_vamp_cattle_ber',
     'in_vamp_cattle_qua',
     'l_vamp_cattle',
    );
my %BETH_LEVC;
foreach my $l (@beth_levc) { $BETH_LEVC{$l}++; }

my @beth_levi =
    ('bm_chest_loot_01',
     'bm_corpse_loot_01',
     'bm_imperial guard random weapon',
     'bm_karstaag_barrels',
     'bm_karstaag_crates',
     'bm_random_enchanted',
     'bm_random_healthpotions',
     'bm_random_lockpick',
     'bm_random_mead',
     'bm_random_nordhuntweap',
     'bm_random_nordictomb',
     'bm_random_nordsilver',
     'bm_random_reaver_helm',
     'bm_random_riekling_loot',
     'bm_random_skaal',
     'bm_randomboots_smugglers',
     'bm_randomcuirass_smugglers',
     'bm_randomgreaves_smugglers',
     'bm_randomhealth_smugglers',
     'bm_randomhelmet_smugglers',
     'bm_randomleft_smugglers',
     'bm_randomloot_smugglers',
     'bm_randomright_smugglers',
     'bm_randomshield_smugglers',
     'bm_randomweapon_berserker',
     'bm_randomwpn_smugglers',
     'bm_skaalhunthelm',
     'bm_skaalhuntlgaunt',
     'bm_skaalhuntlpauldron',
     'bm_skaalhuntrgaunt',
     'bm_skaalhuntrpauldron',
     'bm_skaalhuntshield',
     'goblin_health',
     'goblin_weapons_random',
     'imperial guard random helmet',
     'imperial guard random lpauldron',
     'imperial guard random rpauldron',
     'imperial guard random shield',
     'imperial guard random skirt',
     'imperial guard random weapon',
     'l_b_amulets',
     'l_b_bandit_goods',
     'l_b_loot_tomb',
     'l_b_loot_tomb01',
     'l_b_loot_tomb02',
     'l_b_loot_tomb03',
     'l_b_rings',
     'l_m_amulets',
     'l_m_armor',
     'l_m_armor_boots',
     'l_m_armor_bracers',
     'l_m_armor_cuirass',
     'l_m_armor_gauntlet',
     'l_m_armor_helmet',
     'l_m_armor_shields',
     'l_m_belts',
     'l_m_enchantitem_hlaalu_rank0',
     'l_m_enchantitem_hlaalu_rank4',
     'l_m_enchantitem_hlaalu_rank6',
     'l_m_enchantitem_imperial_rank0',
     'l_m_enchantitem_redoran_rank2',
     'l_m_enchantitem_redoran_rank4',
     'l_m_enchantitem_redoran_rank6',
     'l_m_enchantitem_redoran_rank8',
     'l_m_enchantitem_telvanni_rank01',
     'l_m_enchantitem_telvanni_rank6',
     'l_m_enchantitem_telvanni_rank8',
     'l_m_enchantitem_temple_rank0_1',
     'l_m_enchantitem_temple_rank0_2',
     'l_m_enchantitem_temple_rank4',
     'l_m_enchantitem_temple_rank6',
     'l_m_enchantitem_temple_rank8_1',
     'l_m_enchantitem_temple_rank8_2',
     'l_m_potion',
     'l_m_potion_h',
     'l_m_rings',
     'l_m_wpn_melee',
     'l_m_wpn_melee_axe',
     'l_m_wpn_melee_blunt',
     'l_m_wpn_melee_long blade',
     'l_m_wpn_melee_short blade',
     'l_m_wpn_melee_spear',
     'l_m_wpn_missle',
     'l_m_wpn_missle_arrow',
     'l_m_wpn_missle_bolt',
     'l_n_amulet',
     'l_n_apparatus',
     'l_n_armor',
     'l_n_armor_boots',
     'l_n_armor_bracers',
     'l_n_armor_cuirass',
     'l_n_armor_gauntlet',
     'l_n_armor_greaves',
     'l_n_armor_helmet',
     'l_n_armor_pauldron',
     'l_n_armor_shields',
     'l_n_lockpicks',
     'l_n_probe',
     'l_n_repair item',
     'l_n_rings',
     'l_n_smuggled_goods',
     'l_n_soul gem',
     'l_n_wpn_melee',
     'l_n_wpn_melee_axe',
     'l_n_wpn_melee_blunt',
     'l_n_wpn_melee_blunt_berzerker',
     'l_n_wpn_melee_long blade',
     'l_n_wpn_melee_short blade',
     'l_n_wpn_melee_spear',
     'l_n_wpn_melee_tomb',
     'l_n_wpn_missle',
     'l_n_wpn_missle_arrow',
     'l_n_wpn_missle_bolt',
     'l_n_wpn_missle_bow',
     'l_n_wpn_missle_thrown',
     'l_n_wpn_missle_xbow',
     'random ashlander weapon',
     'random ebony weapon',
     'random excellent melee weapon',
     'random gold',
     'random gold_lev_05',
     'random gold_lev_10',
     'random gold_lev_15',
     'random gold_lev_20',
     'random orcish armor',
     'random_adamantium',
     'random_alchemy_diff',
     'random_alit_hide',
     'random_ampoule_pod',
     'random_armor_bonemold',
     'random_armor_chitin',
     'random_armor_fur',
     'random_armor_glass',
     'random_armor_iron',
     'random_armor_netch_leather',
     'random_armor_steel',
     'random_ash_salts',
     'random_ash_yam',
     'random_bandit_1-5',
     'random_bandit_11+',
     'random_bandit_6-10',
     'random_bear_pelt',
     'random_belladonna_plant',
     'random_belladonna_spriggan',
     'random_bittergreen_petals',
     'random_black_anther',
     'random_black_lichen',
     'random_boar_leather',
     'random_bonemeal',
     'random_book_dunmer',
     'random_book_imperial_dunmer',
     'random_book_imperial_hlaalu',
     'random_book_skill',
     'random_book_wizard_all',
     'random_book_wizard_evil',
     'random_bulbs',
     'random_bunglers_bane',
     'random_cabbage',
     'random_chokeweed',
     'random_coda_flower',
     'random_com_kitchenware',
     'random_comberry',
     'random_common_de_fclothes_01',
     'random_common_de_mclothes_01',
     'random_coprinus',
     'random_corkbulb_root',
     'random_cornberry',
     'random_corprus_weepings',
     'random_crab_meat',
     'random_daedra_heart',
     'random_daedra_skin',
     'random_daedric_weapon',
     'random_de_blueware_01',
     'random_de_cheapfood_01_nc',
     'random_de_cheapfood_01_ne',
     'random_de_pants',
     'random_de_pos_01',
     'random_de_pos_01_nc',
     'random_de_robe',
     'random_de_shirt',
     'random_de_shoes_common',
     'random_de_weapon',
     'random_diamond',
     'random_dreugh_wax',
     'random_drinks_01',
     'random_drinks_nord',
     'random_drinksndrugs_imp',
     'random_dwarven_all',
     'random_dwarven_ingredients',
     'random_dwarven_misc',
     'random_dwemer_armor',
     'random_dwemer_coins',
     'random_dwemer_weapon',
     'random_ebony',
     'random_ectoplasm',
     'random_expensive_de_fclothes_02',
     'random_expensive_de_mclothes_02',
     'random_exquisite_de_fclothes1',
     'random_exquisite_de_mclothes1',
     'random_extravagant_de_fclothes1',
     'random_extravagant_de_mclothes1',
     'random_fire_petal',
     'random_fire_salts',
     'random_food',
     'random_frost_salts',
     'random_gem',
     'random_ghoul_heart',
     'random_glass_weapon',
     'random_gold_kanet',
     'random_golden_saint_shield',
     'random_golden_saint_weapon',
     'random_golden_sedge',
     'random_gravetar',
     'random_green_lichen',
     'random_guar_hide',
     'random_hackle-lo_leaf',
     'random_heartwood',
     'random_heather',
     'random_holly',
     'random_horker_tusk',
     'random_hound_meat',
     'random_hypha_facia',
     'random_imp_armor',
     'random_imp_silverware',
     'random_imp_weapon',
     'random_ingredient',
     'random_ingredient_diff',
     'random_iron_fur_armor',
     'random_iron_weapon',
     'random_kagouti_hide',
     'random_kresh_fiber',
     'random_kwama egg',
     'random_kwama_cuttle',
     'random_loot_bonewalker',
     'random_loot_bonewalker_greater',
     'random_loot_special',
     'random_loot_special_marksman',
     'random_marshmerrow',
     'random_moon_sugar',
     'random_muck',
     'random_netch_leather',
     'random_noble_sedge',
     'random_nordic_weapons',
     'random_nordictomb_rare',
     'random_orcish_weapons',
     'random_pearl',
     'random_pos',
     'random_potion_attribute_restore',
     'random_potion_bad',
     'random_racer_plumes',
     'random_rat_meat',
     'random_rawglass',
     'random_red_guard_cloth_01',
     'random_red_lichen',
     'random_riekling_loot',
     'random_ripened_belladonna',
     'random_roobrush',
     'random_russula',
     'random_rye',
     'random_saltrice',
     'random_scales',
     'random_scamp_skin',
     'random_scathecraw',
     'random_scrap_metal',
     'random_scrib_jelly',
     'random_scroll_all',
     'random_shalk_resin',
     'random_silver_weapon',
     'random_skooma',
     'random_smuggler_1-5',
     'random_smuggler_11+',
     'random_smuggler_6-10',
     'random_snowbear_pelt',
     'random_snowwolf_pelt',
     'random_spines',
     'random_stalks',
     'random_steel_weapon',
     'random_stoneflower_petals',
     'random_sweetpulp',
     'random_timsa',
     'random_trama_root',
     'random_unripened_belladonna',
     'random_vampire_dust',
     'random_void_salts',
     'random_weapon_melee_basic',
     'random_wickwheat',
     'random_willow_anther',
     'random_wolf_pelt',
    );
my %BETH_LEVI;
foreach my $l (@beth_levi) { $BETH_LEVI{$l}++; }

my @CELL_FLAGS = ([0x02, "Has_Water"],
		  [0x041, "Illegal_to_Sleep_Here"],
		  [0x80, "Behave_like_Exterior"]);

my %INFO_FUN = ('00' => "Reaction_Low",
		'01' => "Reaction_High",
		'02' => "Rank_Requirement",
		'03' => "Reputation",
		'04' => "Health_Percent",
		'05' => "PC_Reputation",
		'06' => "PC_Level",
		'07' => "PC_Health_Percent",
		'08' => "PC_Magicka",
		'09' => "PC_Fatigue",

		'10' => "PC_Strength",
		'11' => "PC_Block",
		'12' => "PC_Armorer",
		'13' => "PC_Medium_Armor",
		'14' => "PC_Heavy_Armor",
		'15' => "PC_Blunt_Weapon",
		'16' => "PC_Long_Blade",
		'17' => "PC_Axe",
		'18' => "PC_Spear",
		'19' => "PC_Athletics",

		'20' => "PC_Enchant",
		'21' => "PC_Destruction",
		'22' => "PC_Alteration",
		'23' => "PC_Illusion",
		'24' => "PC_Conjuration",
		'25' => "PC_Mysticism",
		'26' => "PC_Restoration",
		'27' => "PC_Alchemy",
		'28' => "PC_Unarmored",
		'29' => "PC_Security",

		'30' => "PC_Sneak",
		'31' => "PC_Acrobatics",
		'32' => "PC_Light_Armor",
		'33' => "PC_Short_Blade",
		'34' => "PC_Marksman",
		'35' => "PC_Mercantile",
		'36' => "PC_Speechcraft",
		'37' => "PC_Hand_To_Hand",
		'38' => "PC_Sex",
		'39' => "PC_Expelled",

		'40' => "PC_Common_Disease",
		'41' => "PC_Blight_Disease",
		'42' => "PC_Clothing_Modifier",
		'43' => "PC_Crime_Level",
		'44' => "Same_Sex",
		'45' => "Same_Race",
		'46' => "Same_Faction",
		'47' => "Faction_Rank_Difference",
		'48' => "Detected",
		'49' => "Alarmed",

		'50' => "Choice",
		'51' => "PC_Intelligence",
		'52' => "PC_Willpower",
		'53' => "PC_Agility",
		'54' => "PC_Speed",
		'55' => "PC_Endurance",
		'56' => "PC_Personality",
		'57' => "PC_Luck",
		'58' => "PC_Corprus",
		'59' => "Weather",

		'60' => "PC_Vampire",
		'61' => "Level",
		'62' => "Attacked",
		'63' => "Talked_To_PC",
		'64' => "PC_Health",
		'65' => "Creature_Target",
		'66' => "Friend_Hit",
		'67' => "Fight",
		'68' => "Hello",
		'69' => "Alarm",

		'70' => "Flee",
		'71' => "Should_Attack",
		'72' => "Werewolf",
		'73' => "Werewolf_Kills",

		'CX' => "Not_Class",
		'DX' => "Dead_Type",
		'FX' => "Not_Faction",
		'IX' => "Item_Type",
		'JX' => "Journal_Type",
		'LX' => "Not_Cell",
		'RX' => "Not_Race",
		'XX' => "Not_ID_Type",
		'fX' => "Global",
		'lX' => "PCGold",
		'sX' => "Variable_Compare",
	       );

my %INFO_SCVR_type =
    ('0' => "Nothing",
     '1' => "Function",
     '2' => "Global",
     '3' => "Local",
     '4' => "Journal",
     '5' => "Item",
     '6' => "Dead",
     '7' => "Not_ID",
     '8' => "Not_Faction",
     '9' => "Not_Class",
     'A' => "Not_Race",
     'B' => "Not_Cell",
     'C' => "Not_Local");

my %INFO_SCVR_cmp =
    ('0' => '=',
     '1' => '!=',
     '2' => '>',
     '3' => '>=',
     '4' => '<',
     '5' => '<=');

my %SEX = (0 => "Male", 1 => "Female", 0xFF => "None");
my %SPECIALIZATION = (0 => "Combat", 1 => "Magic", 2 => "Stealth");

my %SKILL = ( 0 => "Block",
	      1 => "Armorer",
	      2 => "MediumArmor",
	      3 => "HeavyArmor",
	      4 => "BluntWeapon",
	      5 => "LongBlade",
	      6 => "Axe",
	      7 => "Spear",
	      8 => "Athletics",
	      9 => "Enchant",
	     10 => "Destruction",
	     11 => "Alteration",
	     12 => "Illusion",
	     13 => "Conjuration",
	     14 => "Mysticism",
	     15 => "Restoration",
	     16 => "Alchemy",
	     17 => "Unarmored",
	     18 => "Security",
	     19 => "Sneak",
	     20 => "Acrobatics",
	     21 => "LightArmor",
	     22 => "ShortBlade",
	     23 => "Marksman",
	     24 => "Mercantile",
	     25 => "SpeechCraft",
	     26 => "HandToHand",
	    255 => "None");

my %ATTRIBUTE = (0 => "Strength",
		 1 => "Intelligence",
		 2 => "Willpower",
		 3 => "Agility",
		 4 => "Speed",
		 5 => "Endurance",
		 6 => "Personality",
		 7 => "Luck");

my @AUTOCALC_FLAGS = ([0x00001, "Weapon"],
		      [0x00002, "Armor"],
		      [0x00004, "Clothing"],
		      [0x00008, "Books"],
		      [0x00010, "Ingredient"],
		      [0x00020, "Picks"],
		      [0x00040, "Probes"],
		      [0x00080, "Lights"],
		      [0x00100, "Apparatus"],
		      [0x00200, "Repair"],
		      [0x00400, "Misc"],
		      [0x00800, "Spells"],
		      [0x01000, "Magic_Items"],
		      [0x02000, "Potions"],
		      [0x04000, "Training"],
		      [0x08000, "Spellmaking"],
		      [0x10000, "Enchanting"],
		      [0x20000, "Repair_Item"]);

my %DIAL_TYPE = (0 => "Topic",
		 1 => "Voice",
		 2 => "Greeting",
		 3 => "Persuasion",
		 4 => "Journal");

my %SPLM_TYPE = (1 => "Spell", 2 => "Enchantment");

my %ENCHANT_TYPE = (0 => "Cast_Once",
		    1 => "Cast_on_Strike",
		    2 => "Cast_when_Used",
		    3 => "Constant_Effect");

my %RANGE_TYPE = (0 => "Self", 1 => "Touch", 2 => "Target");

my @MGEF_FLAGS = ([0x0200, "Spellmaking"],
		  [0x0400, "Enchanting"],
		  [0x0800, "Negative"]);

my %MAGIC_SCHOOL = (0 => "Alteration",
		    1 => "Conjuration",
		    2 => "Destruction",
		    3 => "Illusion",
		    4 => "Mysticism",
		    5 => "Restoration");

my %SPEL_TYPE = (0 => "Spell",
		 1 => "Ability",
		 2 => "Blight",
		 3 => "Disease",
		 4 => "Curse",
		 5 => "Power");

my @SPEL_FLAGS = ([0x0001, "AutoCalc"],
		  [0x0002, "PC_Start"],
		  [0x0004, "Always_Succeeds"]);

my %WEAPON_TYPE = (0 => "ShortBladeOneHand",
		   1 => "LongBladeOneHand",
		   2 => "LongBladeTwoClose",
		   3 => "BluntOneHand",
		   4 => "BluntTwoClose",
		   5 => "BluntTwoWide",
		   6 => "SpearTwoWide",
		   7 => "AxeOneHand",
		   8 => "AxeTwoHand",
		   9 => "MarksmanBow",
		   10 => "MarksmanCrossbow",
		   11 => "MarksmanThrown",
		   12 => "Arrow",
		   13 => "Bolt");

my %WEAPON_FLAGS = (1 => "[Ignores_Normal_Weapon_Resistance]");

my @CONTAINER_FLAGS = ([0x0001, "Organic"],
		       [0x0002, "Respawns,_Organic_only"],
		       [0x0008, "Default"]);

my @CREATURE_FLAGS = ([0x0001, "Biped"],
		      [0x0002, "Respawn"],
		      [0x0004, "Weapon_and_shield"],
		      [0x0008, "Movement:None"],
		      [0x0010, "Swims"],
		      [0x0020, "Flies"],
		      [0x0040, "Walks"],
		      [0x0080, "Essential"],
		      [0x0400, "Skeleton_Blood"],
		      [0x0800, "Metal_Blood"]);

my %ARMOR_TYPE = (0 => "Helmet",
		  1 => "Cuirass",
		  2 => "Left_Pauldron",
		  3 => "Right_Pauldron",
		  4 => "Greaves",
		  5 => "Boots",
		  6 => "Left_Gauntlet",
		  7 => "Right_Gauntlet",
		  8 => "Shield",
		  9 => "Left_Bracer",
		  10 => "Right_Bracer");

my %APPARATUS_TYPE = (0 => "Mortar_and_Pestle",
		      1 => "Alembic",
		      2 => "Calcinator",
		      3 => "Retort");

my %ARMOR_INDEX = (0 => "Head",
		   1 => "Hair",
		   2 => "Neck",
		   3 => "Cuirass",
		   4 => "Groin",
		   5 => "Skirt",
		   6 => "Right_Hand",
		   7 => "Left_Hand",
		   8 => "Right_Wrist",
		   9 => "Left_Wrist",
		   10 => "Shield",
		   11 => "Right_Forearm",
		   12 => "Left_Forearm",
		   13 => "Right_Upper_Arm",
		   14 => "Left_Upper_Arm",
		   15 => "Right_Foot",
		   16 => "Left_Foot",
		   17 => "Right_Ankle",
		   18 => "Left_Ankle",
		   19 => "Right_Knee",
		   20 => "Left_Knee",
		   21 => "Right_Upper_Leg",
		   22 => "Left_Upper_Leg",
		   23 => "Right_Pauldron",
		   24 => "Left_Pauldron",
		   25 => "Weapon",
		   26 => "Tail");

my %CTDT_TYPE = (0 => "Pants",
		 1 => "Shoes",
		 2 => "Shirt",
		 3 => "Belt",
		 4 => "Robe",
		 5 => "Right_Glove",
		 6 => "Left_Glove",
		 7 => "Skirt",
		 8 => "Ring",
		 9 => "Amulet");

my @NPC_FLAGS = ([0x0001, "Female"],
		 [0x0002, "Essential"],
		 [0x0004, "Respawn"],
		 [0x0010, "Autocalc"],
		 [0x0400, "Blood_Skel"],
		 [0x0800, "Blood_Metal"]);

my %LEVI_DATA = (1 => "Calc from all levels <= PC level",
		 2 => "Calc for each item");

my @AIDT_FLAGS = ([0x00001, "Weapon"],
		  [0x00002, "Armor"],
		  [0x00004, "Clothing"],
		  [0x00008, "Books"],
		  [0x00010, "Ingredient"],
		  [0x00020, "Picks"],
		  [0x00040, "Probes"],
		  [0x00080, "Lights"],
		  [0x00100, "Apparatus"],
		  [0x00200, "Repair"],
		  [0x00400, "Misc"],
		  [0x00800, "Spells"],
		  [0x01000, "Magic_Items"],
		  [0x02000, "Potions"],
		  [0x04000, "Training"],
		  [0x08000, "Spellmaking"],
		  [0x10000, "Enchanting"],
		  [0x20000, "Repair_Item"]);

my @LHDT_FLAGS = ([0x0001, "Dynamic"],
		  [0x0002, "Can_Carry"],
		  [0x0004, "Negative"],
		  [0x0008, "Flicker"],
		  [0x0010, "Fire"],
		  [0x0020, "Off_Default"],
		  [0x0040, "Flicker_Slow"],
		  [0x0080, "Pulse"],
		  [0x0100, "Pulse_Slow"]);

my @RADT_FLAGS = ([0x01, "Playable"], [0x02, "Beast_Race"]);

my %SPELL_EFFECT = ('0' => "Water_Breathing",
		    '1' => "Swift_Swim",
		    '2' => "Water_Walking",
		    '3' => "Shield",
		    '4' => "Fire_Shield",
		    '5' => "Lightning_Shield",
		    '6' => "Frost_Shield",
		    '7' => "Burden",
		    '8' => "Feather",
		    '9' => "Jump",
		    '10' => "Levitate",
		    '11' => "Slowfall",
		    '12' => "Lock",
		    '13' => "Open",
		    '14' => "Fire_Damage",
		    '15' => "Shock_Damage",
		    '16' => "Frost_Damage",
		    '17' => "Drain_Attribute",
		    '18' => "Drain_Health",
		    '19' => "Drain_Magicka",
		    '20' => "Drain_Fatigue",
		    '21' => "Drain_Skill",
		    '22' => "Damage_Attribute",
		    '23' => "Damage_Health",
		    '24' => "Damage_Magicka",
		    '25' => "Damage_Fatigue",
		    '26' => "Damage_Skill",
		    '27' => "Poison",
		    '28' => "Weakness_to_Fire",
		    '29' => "Weakness_to_Frost",
		    '30' => "Weakness_to_Shock",
		    '31' => "Weakness_to_Magicka",
		    '32' => "Weakness_to_Common_Disease",
		    '33' => "Weakness_to_Blight_Disease",
		    '34' => "Weakness_to_Corprus_Disease",
		    '35' => "Weakness_to_Poison",
		    '36' => "Weakness_to_Normal_Weapons",
		    '37' => "Disintegrate_Weapon",
		    '38' => "Disintegrate_Armor",
		    '39' => "Invisibility",
		    '40' => "Chameleon",
		    '41' => "Light",
		    '42' => "Sanctuary",
		    '43' => "Night_Eye",
		    '44' => "Charm",
		    '45' => "Paralyze",
		    '46' => "Silence",
		    '47' => "Blind",
		    '48' => "Sound",
		    '49' => "Calm_Humanoid",
		    '50' => "Calm_Creature",
		    '51' => "Frenzy_Humanoid",
		    '52' => "Frenzy_Creature",
		    '53' => "Demoralize_Humanoid",
		    '54' => "Demoralize_Creature",
		    '55' => "Rally_Humanoid",
		    '56' => "Rally_Creature",
		    '57' => "Dispel",
		    '58' => "Soultrap",
		    '59' => "Telekinesis",
		    '60' => "Mark",
		    '61' => "Recall",
		    '62' => "Divine_Intervention",
		    '63' => "Almsivi_Intervention",
		    '64' => "Detect_Animal",
		    '65' => "Detect_Enchantment",
		    '66' => "Detect_Key",
		    '67' => "Spell_Absorption",
		    '68' => "Reflect",
		    '69' => "Cure_Common_Disease",
		    '70' => "Cure_Blight_Disease",
		    '71' => "Cure_Corprus_Disease",
		    '72' => "Cure_Poison",
		    '73' => "Cure_Paralyzation",
		    '74' => "Restore_Attribute",
		    '75' => "Restore_Health",
		    '76' => "Restore_Magicka",
		    '77' => "Restore_Fatigue",
		    '78' => "Restore_Skill",
		    '79' => "Fortify_Attribute",
		    '80' => "Fortify_Health",
		    '81' => "Fortify_Magicka",
		    '82' => "Fortify_Fatigue",
		    '83' => "Fortify_Skill",
		    '84' => "Fortify_Maximum_Magicka",
		    '85' => "Absorb_Attribute",
		    '86' => "Absorb_Health",
		    '87' => "Absorb_Magicka",
		    '88' => "Absorb_Fatigue",
		    '89' => "Absorb_Skill",
		    '90' => "Resist_Fire",
		    '91' => "Resist_Frost",
		    '92' => "Resist_Shock",
		    '93' => "Resist_Magicka",
		    '94' => "Resist_Common_Disease",
		    '95' => "Resist_Blight_Disease",
		    '96' => "Resist_Corprus_Disease",
		    '97' => "Resist_Poison",
		    '98' => "Resist_Normal_Weapons",
		    '99' => "Resist_Paralysis",
		    '100' => "Remove_Curse",
		    '101' => "Turn_Undead",
		    '102' => "Summon_Scamp",
		    '103' => "Summon_Clannfear",
		    '104' => "Summon_Daedroth",
		    '105' => "Summon_Dremora",
		    '106' => "Summon_Ancestral_Ghost",
		    '107' => "Summon_Skeltal_Minion",
		    '108' => "Summon_Bonewalker",
		    '109' => "Summon_Greater_Bonewalker",
		    '110' => "Summon_Bonelord",
		    '111' => "Summon_Winged_Twilight",
		    '112' => "Summon_Hunger",
		    '113' => "Summon_Golden_Saint",
		    '114' => "Summon_Flame_Atronach",
		    '115' => "Summon_Frost_Atronach",
		    '116' => "Summon_Storm_Atronach",
		    '117' => "Fortify_Attack",
		    '118' => "Command_Creature",
		    '119' => "Command_Humanoid",
		    '120' => "Bound_Dagger",
		    '121' => "Bound_Longsword",
		    '122' => "Bound_Mace",
		    '123' => "Bound_Battle_Axe",
		    '124' => "Bound_Spear",
		    '125' => "Bound_Longbow",
		    '126' => "EXTRA_SPELL",
		    '127' => "Bound_Cuirass",
		    '128' => "Bound_Helm",
		    '129' => "Bound_Boots",
		    '130' => "Bound_Shield",
		    '131' => "Bound_Gloves",
		    '132' => "Corprus",
		    '133' => "Vampirism",
		    '134' => "Summon_Centurion_Spider",
		    '135' => "Sun_Damage",
		    '136' => "Stunted_Magicka",
		    '137' => "Summon_Fabricant",
		    '138' => "Call_Wolf",
		    '139' => "Call_Bear",
		    '140' => "Summon_Bonewolf",
		    '141' => "sEffectSummonCreature04",
		    '142' => "sEffectSummonCreature05",
		   );

my %BYDT_PART = ('0' => "Head",
		 '1' => "Hair",
		 '2' => "Neck",
		 '3' => "Chest",
		 '4' => "Groin",
		 '5' => "Hand",
		 '6' => "Wrist",
		 '7' => "Forearm",
		 '8' => "Upperarm",
		 '9' => "Foot",
		 '10' => "Ankle",
		 '11' => "Knee",
		 '12' => "Upperleg",
		 '13' => "Clavicle",
		 '14' => "Tail");

my %BYDT_FLAGS = ('0' => "None", '1' => "Female", '2' => "Playable");

my %BYDT_PTYP = ('0' => "Skin", "1" => "Clothing", "2" => "Armor");

my @FACT_FLAGS = ([0x0001, "Hidden_From_Player"]);

my @CREA_TYPE = qw(Creature Daedra Undead Humanoid);

my @SNDG_DATA = ("Left_Foot", "Right_Foot", "Swim_Left", "Swim_Right", "Moan", "Roar", "Scream", "Land");


sub unpack_short_array {
    my $i = 1;
    my %hr;
    $hr{$i++} = $_ foreach (unpack("s*", $_[0]));
    \%hr;
};
sub pack_short_array {
    my($hr) = @_;
    my @vals;
    unshift(@vals, $hr->{$_}) foreach (sort { $a <=> $b } keys %{$hr});
    pack("s*", @vals);
}
sub unpack_long_array {
    my $i = 1;
    my %hr;
    $hr{$i++} = $_ foreach (unpack("l*", $_[0]));
    \%hr;
};
sub pack_long_array {
    my($hr) = @_;
    my @vals;
    unshift(@vals, $hr->{$_}) foreach (sort { $a <=> $b } keys %{$hr});
    pack("l*", @vals);
}
sub unpack_float_array {
    my $i = 1;
    my %hr;
    $hr{$i++} = $_ foreach (unpack("f*", $_[0]));
    \%hr;
};
sub pack_float_array {
    my($hr) = @_;
    my @vals;
    unshift(@vals, $hr->{$_}) foreach (sort { $a <=> $b } keys %{$hr});
    pack("f*", @vals);
}

my %RECDEF =
    {
     ACTI => {
	      FNAM => [["Name", "a*"]],
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	      SCRI => [["Script", "a*"]],
	     },
     ALCH => {
	      ALDT => [["Weight", "f"], ["Value", "L"], ["Autocalc", "L"]],
	      ENAM => [["String", "a*"]],
	      FNAM => [["Name", "a*"]],
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	      SCRI => [["Script", "a*"]],
	      TEXT => [["Icon", "a*"]],
	     },
     APPA => {
	      AADT => [["Type", "L"], ["Quality", "f"], ["Weight", "f"], ["Value", "L"]],
	      FNAM => [["Name", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	      SCRI => [["Script", "a*"]],
	     },
     ARMO => {
	      AODT => [["Type", "L"], ["Weight", "f"], ["Value", "L"], ["Health", "L"], ["Enchant_Points", "L"], ["Armor_Rating", "L"]],
	      BNAM => [["Body_ID_Male", "a*"]],
	      CNAM => [["Body_ID_Female", "a*"]],
	      ENAM => [["Enchantment", "a*"]],
	      FNAM => [["Name", "a*"]],
	      INDX => [["Part_Index", "C"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	      SCRI => [["Script", "a*"]],
	     },
     BODY => {
	      BYDT => [["Body_Part", "C"], ["Vampire", "C"], ["Flags", "C"], ["Part_Type", "C"]],
	      FNAM => [["Name", "a*"]],
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	     },
     BOOK => {
	      BKDT => [["Weight", "f"], ["Value", "L"], ["Scroll", "L"], ["Skill", "L"], ["Enchant_Points", "L"]],
	      ENAM => [["Enchantment", "a*"]],
	      FNAM => [["Name", "a*"]],
	      ITEX => [["Icon", "a*"]],
	      MODL => [["Model", "a*"]],
	      NAME => [["ID", "a*"]],
	      SCRI => [["Script", "a*"]],
	      TEXT => [["Text", "a*"]],
	     },
     BSGN => {
	      DESC => [["Description", "a*"]],
	      FNAM => [["Name", "a*"]],
	      NAME => [["ID", "a*"]],
	      NPCS => [["Spell", "a*"]],
	      TNAM => [["Image", "a*"]]
	     },
     CELL => {
	      ACDT => [],
	      ACSC => [],
	      ACSL => [],
	      ACTN => [],
	      AMBI => [["Ambient_Color", "L"], ["Sunlight_Color", "L"], ["Fog_Color", "L"], ["Fog_Density", "f"]],
	      ANAM => [],
	      ANIS => [],
	      APUD => [],
	      BNAM => [],
	      CHRD => [],
	      CNAM => [],
	      CNDT => [],
	      CRED => [],
	      CSHN => [],
	      CSTN => [["Target", "Z*"]], # guessing this is: "Cast/Current Spell Target Name"
	      DATA => [sub {
			   my($buff) = @_;
			   my $dlen = length($buff);
			   if ($dlen == 24) {
			       my($x, $y, $z, $xrot, $yrot, $zrot) = unpack("f6", $buff);
			       return({ X => $x, Y => $y, Z => $z,
					X_angle => $xrot, Y_angle => $yrot, Z_angle => $zrot });
			   } elsif ($dlen == 12) {
			       my($flags, $unk, $fog) = unpack("LLf", $buff);
			       if ($flags & 0x01) { # Interior
				   return({ Flags => $flags, Unknown => $unk, Fog_Density => $fog });
			       } else {	# Exterior
				   my($x, $y) = unpack("x[L]ll", $buff);
				   return({ Flags => $flags, X => $x, Y => $y });
			       }
			   } else {
			       die "DECODER ERROR on CELL.DATA, Invalid length: $dlen\n";
			   }
		       },
		       sub {
			   my($hr) = @_;
			   if (exists $hr->{Flags}) {
			       if ($hr->{Flags} & 0x01) { # Interior
				   return(pack("LLf", $hr->{Flags}, $hr->{Unknown}, $hr->{Fog_Density}));
			       } else {	# Exterior
				   return(pack("Lll", $hr->{Flags}, $hr->{X}, $hr->{Y}));
			       }
			   } else {
			       return(pack("f6", $hr->{X}, $hr->{Y}, $hr->{Z},
					   $hr->{X_angle}, $hr->{Y_angle}, $hr->{Z_angle}));
			   }
		       }],
	      DNAM => [],
	      DODT => [["X", "f"], ["Y", "f"], ["Z", "f"], ["Angle_X", "f"], ["Angle_Y", "f"], ["Angle_Z", "f"]],
	      FGTN => [],
	      FLTV => [],
	      FRMR => [["ObjIdx", "S"], ["Unknown", "C"], ["ModIdx", "C"]],
	      INDX => [],
	      INTV => [],
	      KNAM => [],
	      LSHN => [],
	      LSTN => [],
	      LVCR => [],
	      MNAM => [],
	      MVRF => [],
	      NAM0 => [],
	      NAM5 => [["Red", "C"], ["Green", "C"], ["Blue", "C"], ["Unused", "C"]], # Map Color
	      NAM8 => [],
	      NAM9 => [["Owner", "L"]],
	      NAME => [],
	      ND3D => [],
	      PRDT => [],
	      PWPC => [],
	      PWPS => [],
	      RGNN => [],
	      SCRI => [["Script", "a*"]],
	      SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]],
	      SLFD => [\&unpack_float_array, \&pack_float_array],
	      SLLD => [\&unpack_long_array,  \&pack_long_array],
	      SLSD => [\&unpack_short_array, \&pack_short_array],
	      STPR => [],
	      TGTN => [],
	      TNAM => [],
	      UNAM => [],
	      WHGT => [],
	      WNAM => [],
	      XCHG => [["Enchant_Charge", "L"]],
	      XNAM => [],
	      XSCL => [["Scale", "f"]],
	      XSOL => [["Soul", "Z*"]],
	      YNAM => [],
	      ZNAM => [],
	     },
     CLAS => {
	      CLDT => [["Primary_Attribute", "L"], ["Secondary_Attribute", "L"], ["Specialization", "L"],
		       [[("Minor_Skill_1", "Major_Skill_1") x 5], "(L2)5"], ["Flags", "L"], ["AutoCalc", "L"]],
	      DESC => [],
	      FNAM => [],
	      NAME => [],
	     },
     CLOT => {
	      BNAM => [],
	      CNAM => [],
	      CTDT => [["Type", "L"], ["Weight", "f"], ["Value", "S"], ["Enchant_Points", "S"]],
	      ENAM => [],
	      FNAM => [],
	      INDX => [["Index", "C"]],
	      ITEX => [],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      SCRI => [["Script", "a*"]],
	     },
     CNTC => {
	      INDX => [],
	      NAME => [],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      SCRI => [["Script", "a*"]],
	      SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]],
	      SLFD => [\&unpack_float_array, \&pack_float_array],
	      SLLD => [\&unpack_long_array,  \&pack_long_array],
	      SLSD => [\&unpack_short_array, \&pack_short_array],
	      XCHG => [["Enchant_Charge", "L"]],
	      XHLT => [["Health", "L"]],
	      XIDX => [],
	      XSOL => [["Soul", "Z*"]],
	     },
     CONT => {
	      CNDT => [["Weight", "f"]],
	      FLAG => [["Container_Flags", "L"]],
	      FNAM => [],
	      INDX => [],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      SCRI => [["Script", "a*"]],
	     },
     CREA => {
	      AIDT => [["Hello", "C"], ["Unknown_1", "C"], ["Fight", "C"], ["Flee", "C"], ["Alarm", "C"], ["Unknown_1", "a3"], ["Flags", "L"]],
	      AI_E => [],
	      AI_F => [],
	      AI_T => [],
	      AI_W => [["Distance", "S"], ["Duration", "C"], ["Time_of_day", "C"], [[("Idle_1") x 10], "C10"]],
	      CNAM => [],
	      DNAM => [],
	      DODT => [["X", "f"], ["Y", "f"], ["Z", "f"], ["Angle_X", "f"], ["Angle_Y", "f"], ["Angle_Z", "f"]],
	      FLAG => [["Flags", "L"]],
	      FNAM => [],
	      INDX => [],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      NPCS => [],
	      NPDT => [["Type", "L"], ["Lev", "L"], ["Str", "L"], ["Int", "L"], ["Wil", "L"], ["Agi", "L"], ["Spd", "L"], ["End", "L"], ["Per", "L"], ["Lck", "L"], ["Health", "L"], ["Spell_Points", "L"], ["Fatigue", "L"], ["Soul", "L"], ["Combat", "L"], ["Magic", "L"], ["Stealth", "L"], ["Attack_1_Min", "L"], ["Attack_1_Max", "L"], ["Attack_2_Min", "L"], ["Attack_2_Max", "L"], ["Attack_3_Min", "L"], ["Attack_3_Max", "L"], ["Gold", "L"]],
	      SCRI => [["Script", "a*"]],
	      XSCL => [["Scale", "f"]],
	     },
     CREC => {
	      AI_F => [],
	      AI_T => [],
	      AI_W => [],
	      INDX => [],
	      NAME => [],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      SCRI => [["Script", "a*"]],
	      SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]],
	      SLFD => [\&unpack_float_array, \&pack_float_array],
	      SLSD => [\&unpack_short_array, \&pack_short_array],
	      WIDX => [["Equipped_Index", "l"], ["Ammo_Flag", "l"]],
	      XCHG => [["Enchant_Charge", "L"]],
	      XHLT => [["Health", "L"]],
	      XIDX => [],
	      XSCL => [["Scale", "f"]],
	     },
     DIAL => {
	      DATA => [["Type", "C"]],
	      NAME => [],
	      XIDX => [],
	     },
     DOOR => {
	      ANAM => [],
	      FNAM => [],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      SCRI => [["Script", "a*"]],
	      SNAM => [],
	     },
     ENCH => {
	      ENAM => [["Spell_Effect", "S"], ["Skill", "C"], ["Attribute", "C"], ["Range", "L"],
		       ["Area", "L"], ["Duration", "L"], ["MagMin", "L"], ["MagMax", "L"]],
	      ENDT => [["Type", "L"], ["Cost", "L"], ["Charge", "L"], ["Autocalc", "L"]],
	      NAME => [],
	     },
     FACT => {
	      ANAM => [],
	      FADT => [["Primary_Attribute", "L"], ["Secondary_Attribute", "L"],
		       [[("At1_1", "At2_1", "Sk1_1", "Sk2_1", "Fact_1") x 10], "(L5)10"],
		       [[("Sk_1") x 6], "L6"], ["Unknown_1", "L"], ["Flags", "L"]],
	      FNAM => [],
	      INTV => [],
	      NAME => [],
	      RNAM => [],
	     },
     FMAP => {
	      MAPD => [],
	      MAPH => [],
	     },
     GAME => {
	      GMDT => [],
	     },
     GLOB => {
	      FLTV => [],
	      FNAM => [["Type", "a"]],
	      NAME => [],
	     },
     GMST => {
	      FLTV => [],
	      INTV => [],
	      NAME => [["Name", "a*"]],
	      STRV => [],
	     },
     INFO => {
	      ACDT => [["Actor_Data", "Z*"]], # .ess
	      ANAM => [["Cell", "Z*"]],
	      BNAM => [["Result", "a*"]],
	      CNAM => [["Class", "Z*"]],
	      DATA => [["Unknown_1", "L"],
		       ["Disposition", "L"],
		       ["Rank", "C"],
		       ["Sex", "C"],
		       ["PCRank", "C"],
		       ["Unknown_1", "C"]],
	      DNAM => [["PC_Faction", "Z*"]],
	      FLTV => [["Result_Value", "f"]],
	      FNAM => [["Faction", "Z*"]],
	      INAM => [["ID", "a*"]],
	      INTV => [["Compare_Value", "L"]],
	      NAME => [["Response", "a*"]],
	      NNAM => [["Next_ID", "Z*"]],
	      ONAM => [["Actor", "Z*"]],
	      PNAM => [["Prev_ID", "Z*"]],
	      QSTF => [["Quest_Finished", "C"]],
	      QSTN => [["Quest_Name", "C"]],
	      QSTR => [["Quest_Restart", "C"]],
	      RNAM => [["Race", "a*"]],
	      SCVR => [["Index", "a"], ["Type", "a"], ["Function", "a2"], ["Comparison", "a"], ["Name", "a*"]],
	      SNAM => [["Sound_File", "a"]],
	     },
     INGR => {
	      FNAM => [],
	      IRDT => [["Weight", "f"], ["Value", "L"], [[("Effect_1") x 4], "l4"], [[("Skill_1") x 4], "l4"], [[("Attribute_1") x 4], "l4"]],
	      ITEX => [],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      SCRI => [["Script", "a*"]],
	     },
     JOUR => {
	      NAME => [],
	     },
     KLST => {
	      CNAM => [],
	      INTV => [],
	      KNAM => [],
	     },
     LAND => {
	      DATA => [],
	      INTV => [["X", "l"], ["Y", "l"]],
	      VCLR => [],
	      VHGT => [],
	      VNML => [],
	      VTEX => [],
	      WNAM => [],
	     },
     LEVC => {
	      CNAM => [],
	      DATA => [["List_Data", "L"]],
	      INDX => [],
	      INTV => [["Level", "S"]],
	      NAME => [],
	      NNAM => [["Chance_None", "C"]]
	     },
     LEVI => {
	      DATA => [["List_Data", "L"]],
	      INAM => [["Name", "Z*"]],
	      INDX => [],
	      INTV => [["Level", "S"]],
	      NAME => [["ID", "a*"]],
	      NNAM => [["Chance_None", "C"]]
	     },
     LIGH => {
	      FNAM => [],
	      ITEX => [],
	      LHDT => [["Weight", "f"], ["Value", "L"], ["Time", "L"], ["Radius", "L"],
		       ["Red", "C"], ["Green", "C"], ["Blue", "C"],
		       ["Unknown_1", "C"], ["Flags", "L"]],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      SCRI => [["Script", "a*"]],
	      SNAM => [],
	     },
     LOCK => {
	      FNAM => [],
	      ITEX => [],
	      LKDT => [["Weight", "f"], ["Value", "L"], ["Quality", "f"], ["Uses", "L"]],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      SCRI => [["Script", "a*"]],
	     },
     LTEX => {
	      DATA => [["Data", "Z*"]],
	      INTV => [],
	      NAME => [],
	     },
     MGEF => {
	      ASND => [],
	      AVFX => [],
	      BSND => [],
	      BVFX => [],
	      CSND => [],
	      CVFX => [],
	      DESC => [],
	      HSND => [],
	      HVFX => [],
	      INDX => [],
	      ITEX => [],
	      MEDT => [["School", "L"], ["Base_Cost", "f"],["Flags", "L"],
		       ["Red", "L"], ["Green", "L"], ["Blue", "L"],
		       ["Speed", "f"], ["Size", "f"], ["SizeCap", "f"]],
	      PTEX => [],
	     },
     MISC => {
	      FNAM => [],
	      ITEX => [],
	      MCDT => [["Weight", "f"], ["Value", "L"], ["Unknown_1", "L"]],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      SCRI => [["Script", "a*"]],
	     },
     NPCC => {
	      AI_E => [],
	      AI_F => [],
	      AI_T => [],
	      AI_W => [],
	      NAME => [],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      NPDT => [],
	      SCRI => [["Script", "a*"]],
	      SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]],
	      SLFD => [\&unpack_float_array, \&pack_float_array],
	      SLLD => [\&unpack_long_array,  \&pack_long_array],
	      SLSD => [\&unpack_short_array, \&pack_short_array],
	      WIDX => [["Equipped_Index", "l"], ["Ammo_Flag", "l"]],
	      XCHG => [["Enchant_Charge", "L"]],
	      XHLT => [["Health", "L"]],
	      XIDX => [],
	      XSOL => [["Soul", "Z*"]],
	     },
     NPC_ => {
	      AIDT => [["Hello", "C"], ["Unknown_1", "C"], ["Fight", "C"], ["Flee", "C"], ["Alarm", "C"], ["Unknown_1", "a3"], ["Flags", "L"]],
	      AI_E => [],
	      AI_F => [],
	      AI_T => [],
	      AI_W => [["Distance", "S"], ["Duration", "S"], ["Time_of_day", "C"], [[("Idle_1") x 8], "C8"], ["Unknown_1", "C"]],
	      ANAM => [],
	      BNAM => [],
	      CNAM => [],
	      CNDT => [["Data", "Z*"]],
	      DNAM => [],
	      DODT => [["X", "f"], ["Y", "f"], ["Z", "f"], ["Angle_X", "f"], ["Angle_Y", "f"], ["Angle_Z", "f"]],
	      FLAG => [["Flags", "L"]],
	      FNAM => [],
	      KNAM => [],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      NPCO => [["Count", "l"], ["Name", "a32"]],
	      NPCS => [],
	      NPDT => [sub {
			   my($buff) = @_;
			   my %hr;
			   my $len = length($buff);
			   if ($len == 12) {
			       my($lev, $disp, $fact, $rank, $unk1, $unk2, $unk3, $gold) = unpack("SC6L", $_[0]);
			       return({ Level => $lev, Disposition => $disp, Faction => $fact, Rank => $rank,
					Unk1 => $unk1, Unk2 => $unk2, Unk3 => $unk3, Gold => $gold });
			   } elsif ($len == 52) {
			       my $i = 0;
			       my %hr;
			       foreach my $skill_level (unpack("x[SC8]C27", $buff)) {
				   $hr{$SKILL{$i++}} = $skill_level;
			       }
			       ($hr{Level}, $hr{Str}, $hr{Int}, $hr{Wil}, $hr{Agi}, $hr{Spd}, $hr{End},
				$hr{Per}, $hr{Lck}, $hr{Rep}, $hr{Health}, $hr{Magicka}, $hr{Fatigue},
				$hr{Disposition}, $hr{Faction}, $hr{Rank}, $hr{Gold}) = unpack("SC8x[C27]CSSSCCCxL", $buff);
			       return(\%hr);
			   } else {
			       warn "BAD NPC_.NPDT length ($len) is not 12 or 52!\n";
			   }
		       },
		       sub {
			   my($hr) = @_;
			   if (exists $hr->{Magicka}) {
			       return(pack("SC8C27CSSSCCCxL",
					   $hr->{Level}, $hr->{Str}, $hr->{Int}, $hr->{Wil}, $hr->{Agi},
					   $hr->{Spd}, $hr->{End}, $hr->{Per}, $hr->{Lck},
					   $hr->{"Block"}, $hr->{"Armorer"}, $hr->{"MediumArmor"}, $hr->{"HeavyArmor"},
					   $hr->{"BluntWeapon"}, $hr->{"LongBlade"}, $hr->{"Axe"}, $hr->{"Spear"},
					   $hr->{"Athletics"}, $hr->{"Enchant"}, $hr->{"Destruction"}, $hr->{"Alteration"},
					   $hr->{"Illusion"}, $hr->{"Conjuration"}, $hr->{"Mysticism"}, $hr->{"Restoration"},
					   $hr->{"Alchemy"}, $hr->{"Unarmored"}, $hr->{"Security"}, $hr->{"Sneak"},
					   $hr->{"Acrobatics"}, $hr->{"LightArmor"}, $hr->{"ShortBlade"}, $hr->{"Marksman"},
					   $hr->{"Mercantile"}, $hr->{"SpeechCraft"}, $hr->{"HandToHand"},
					   $hr->{Rep}, $hr->{Health}, $hr->{Magicka}, $hr->{Fatigue},
					   $hr->{Disposition}, $hr->{Faction}, $hr->{Rank}, $hr->{Gold}));
			   } else {
			       return(pack("SC6L", $hr->{Level}, $hr->{Disposition}, $hr->{Faction}, $hr->{Rank},
					   $hr->{Unk1}, $hr->{Unk2}, $hr->{Unk3},  $hr->{Gold}));
			   }
		       }],
	      RNAM => [],
	      SCRI => [["Script", "a*"]],
	     },
     PCDT => {
	      AADT => [],
	      ANIS => [],
	      BNAM => [],
	      CNAM => [],
	      DNAM => [],
	      ENAM => [],
	      FNAM => [],
	      KNAM => [],
	      LNAM => [],
	      MNAM => [],
	      NAM0 => [],
	      NAM1 => [],
	      NAM2 => [],
	      NAM3 => [],
	      NAM9 => [],
	      PNAM => [],
	      SNAM => [],
	     },
     PGRD => {
	      DATA => [],
	      NAME => [],
	      PGRC => [],
	      PGRP => [],
	     },
     PROB => {
	      FNAM => [],
	      ITEX => [],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      PBDT => [["Weight", "f"], ["Value", "L"], ["Quality", "f"], ["Uses", "L"]],
	     },
     QUES => {
	      DATA => [["Info_ID", "Z*"]], # {ess => 1}
	      NAME => [],
	     },
     RACE => {
	      DESC => [],
	      FNAM => [],
	      NAME => [],
	      NPCS => [],
	      RADT => [[[("Skill_1", "Bonus_1") x 7], "(L2)7"], [[("Attr_Male_1", "Attr_Female_1") x 8], "(L2)8"],
		       ["Male_Height", "f"], ["Female_Height", "f"], ["Male_Weight", "f"], ["Female_Weight", "f"], ["Flags", "L"]],
	     },
     REFR => {
	      AADT => [],
	      ACDT => [([[("Unknown_1") x 10], "L10"],   #   0
			["Health", "f"],		 #  40
			["Max_Health", "f"],		 #  44
			["Fatigue", "f"],		 #  48
			["Max_Fatigue", "f"],		 #  52
			["Unknown_1", "f"],		 #  56
			["Unknown_1", "f"],		 #  60
			["Unknown_1", "f"],		 #  64
			["Unknown_1", "f"],		 #  68
			["Unknown_1", "f"],		 #  72
			["Encumbrance", "f"],		 #  76
			["STR", "f"],			 #  80
			["STR_Base", "f"],		 #  84
			["INT", "f"],			 #  88
			["INT_Base", "f"],		 #  92
			["WIL", "f"],			 #  96
			["WIL_Base", "f"],		 # 100
			["AGI", "f"],			 # 104
			["AGI_Base", "f"],		 # 108
			["SPD", "f"],			 # 112
			["SPD_Base", "f"],		 # 116
			["END", "f"],			 # 120
			["END_Base", "f"],		 # 124
			["PER", "f"],			 # 128
			["PER_Base", "f"],		 # 132
			["LUC", "f"],			 # 136
			["LUC_Base", "f"],		 # 140
			["Fortify_Attack", "L"],	 # 144
			["Sanctuary", "L"],		 # 148
			["Resist_Magicka", "C"],	 # 152
			["Unknown_1", "a3"],
			["Resist_Fire", "C"], # 156 (+ Fire Shield)
			["Unknown_1", "a3"],
			["Resist_Frost", "C"], # 160 (+ Frost Shield)
			["Unknown_1", "a3"],
			["Resist_Shock", "C"], # 164 (+ Lightning Shield)
			["Unknown_1", "a3"],
			["Resist_Common_Disease", "L"],	    # 168
			["Unknown_1", "L"],		    # 172
			["Unknown_1", "L"],		    # 176
			["Resist_Poison", "L"],		    # 180
			["Resist_Paralysis", "L"],	    # 184
			["Chameleon", "L"],		    # 188
			["Resist_Normal_Weapons", "L"],	    # 192
			["Water_Breathing", "L"],	    # 196
			["Water_Walking", "L"],		    # 200
			["Swift_Swim", "L"],		    # 204
			["Unknown_1", "L"],		    # 208
			["Levitate", "L"],		    # 212
			["Shield", "L"],		    # 216
			["Unknown_1", "L"],		    # 220
			["Unknown_1", "L"],		    # 224
			["Blind", "L"],			    # 228
			["Unknown_1", "L"],		    # 232
			["Invisibility", "L"],		    # 236
			["unknown", "L"],		    # 240
			["Unknown_1", "L"],		    # 244
			["Unknown_1", "L"],		    # 248
			["Unknown_1", "L"],		    # 252
			["Unknown_1", "L"],		    # 256
			["Unknown_1", "L"])],
	      ACSC => [],
	      ACSL => [],
	      ACTN => [],
	      CHRD => [],
	      CSHN => [],
	      CSTN => [],
	      DATA => [],
	      FGTN => [],
	      FRMR => [],
	      NAME => [],
	      ND3D => [],
	      STPR => [],
	      TGTN => [],
	      WNAM => [["Readied_Spell", "Z*"]],
	      XSCL => [["Scale", "f"]],
	     },
     REGN => {
	      BNAM => [],
	      CNAM => [["Red", "C"], ["Green", "C"], ["Blue", "C"], ["Unused", "C"]],
	      FNAM => [],
	      NAME => [],
	      SNAM => [["Sound_Name", ["Z32", "a32"]], ["Chance", "C"]],
	      WEAT => [["Clear", "C"], ["Cloudy", "C"], ["Foggy", "C"], ["Overcast", "C"],
		       ["Rain", "C"], ["Thunder", "C"], ["Ash", "C"], ["Blight", "C"],
		       ["Snow", "C"], ["Blizzard", "C"]],	 # Bloodmoon
	      WNAM => [["Name", "L"]],
	     },
     REPA => {
	      FNAM => [],
	      ITEX => [],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      RIDT => [["Weight", "f"], ["Value", "L"], ["Uses", "L"], ["Quality", "f"]],
	      SCRI => [["Script", "a*"]],
	     },
     SCPT => {
	      RNAM => [["Unknown_1", "L"]],
	      SCDT => [["Bytecode", "H*"]],
	      SCHD => [["Script_Name", ["Z32", "a32"]], ["Num_Shorts", "L"], ["Num_Longs", "L"], ["Num_Floats", "L"],
		       ["Data_Size", "L"], ["Local_Var_Size", "L"]],
	      SCTX => [["Script_Text", "a*"]],
	      SCVR => [["Variables", "a*"]],
	      SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]],
	      SLFD => [\&unpack_float_array, \&pack_float_array],
	      SLLD => [\&unpack_long_array,  \&pack_long_array],
	      SLSD => [\&unpack_short_array, \&pack_short_array],
	     },
     SKIL => {
	      DESC => [],
	      INDX => [],
	      SKDT => [["Attribute", "L"], ["Specialization", "L"], [[("Use_Values_1") x 4], "f4"]],
	     },
     SNDG => {
	      CNAM => [],
	      DATA => [["Data", "L"]],
	      NAME => [],
	      SNAM => [],
	     },
     SOUN => {
	      DATA => [["Volume", "C"], ["MinRange", "C"], ["MaxRange", "C"]],
	      FNAM => [],
	      NAME => [],
	     },
     SPEL => {
	      ENAM => [["Spell_Effect", "S"], ["Skill", "C"], ["Attribute", "C"], ["Range", "L"],
		       ["Area", "L"], ["Duration", "L"], ["MagMin", "L"], ["MagMax", "L"]],
	      FNAM => [],
	      NAME => [],
	      SPDT => [["Type", "L"], ["Cost", "L"], ["Flags", "L"]],
	     },
     SPLM => {
	      CNAM => [],
	      NAM0 => [],
	      NAME => [["Name", "L"]],
	      NPDT => [["Name", ["Z40", "a40"]], ["Magnitude", "l"], ["Seconds_Active", "f"], [[("Long_1") x 2], "l2"]],
	      SPDT => [["Type", "L"], ["Name", ["Z40", "a40"]], [[("Long_1") x 2], "L2"],
		       ["Caster", ["Z32", "a32"]], ["Item", "Z*"]],
	      TNAM => [["Target", "Z*"]],
	      VNAM => [],
	      XNAM => [["Name", "L"]],
	     },
     SSCR => {
	      DATA => [["Name", "a*"]],
	      NAME => [],
	     },
     STAT => {
	      MODL => [["Model", "a*"]],
	      NAME => [],
	     },
     STLN => {
	      FNAM => [],
	      NAME => [],
	      ONAM => [["Name", "Z*"]],
	     },
     TES3 => {
	      DATA => [sub { my($l1, $l2) = unpack("L2", $_[0]); { Length => $l1 + ($l2 << 32) }; },
		       sub { my $len = $_[0]->{Length}; my $l1 = $len & 0xffffffff; my $l2 = $len >> 32; pack("L2", $l1, $l2); }],
	      GMDT => [],
	      HEDR => [["Version", "f"], ["Is_Master", "L"], ["Author", ["Z32", "a32"]], ["Description", ["Z256", "a256"]], ["NRecords", "L"]],
	      MAST => [["Master", "Z*"]],
	      SCRD => [],
	      SCRS => [["Screenshot", "a*"]],
	     },
     VFXM => {
	      VNAM => [],
	     },
     WEAP => {
	      ENAM => [],
	      FNAM => [],
	      ITEX => [],
	      MODL => [["Model", "a*"]],
	      NAME => [],
	      SCRI => [["Script", "a*"]],
	      WPDT => [["Weight", "f"], ["Value", "L"], ["Type", "S"], ["Health", "S"], ["Speed", "f"],
		       ["Reach", "f"], ["Enchant_Points", "S"], ["Chop_Min", "C"], ["Chop_Max", "C"],
		       ["Slash_Min", "C"], ["Slash_Max", "C"], ["Thrust_Min", "C"], ["Thrust_Max", "C"],
		       ["Flags", "L"]],
	     },
     };

# All record types found in .esm/.esp/.ess
my @RECTYPES = keys %RECDEF;

# All record sub-types found in .esm/.esp/.ess
my @SUBRECTYPES =
    qw(AADT ACDT ACSC ACSL ACTN AIDT AI_E AI_F AI_T AI_W ALDT AMBI ANAM ANIS
       AODT APUD ASND AVFX BKDT BNAM BSND BVFX BYDT CHRD CLDT CNAM CNDT CRED
       CSHN CSND CSTN CTDT CVFX DATA DELE DESC DNAM DODT ENAM ENDT FADT FGTN
       FLAG FLTV FNAM FRMR GMDT HEDR HSND HVFX INAM INDX INTV IRDT ITEX KNAM
       LHDT LKDT LNAM LSHN LSTN LVCR MAPD MAPH MAST MCDT MEDT MNAM MODL MVRF
       NAM0 NAM1 NAM2 NAM3 NAM5 NAM8 NAM9 NAME ND3D NNAM NPCO NPCS NPDT ONAM
       PBDT PGRC PGRP PNAM PTEX QSTF QSTN QSTR RADT RGNN RIDT RNAM SCDT SCHD
       SCRD SCRI SCRS SCTX SCVR SKDT SLCS SLFD SLLD SLSD SNAM SPDT STPR STRV
       TEXT TGTN TNAM UNAM VCLR VHGT VNAM VNML VTEX WEAT WHGT WIDX WNAM WPDT
       XCHG XHLT XIDX XNAM XSCL XSOL YNAM ZNAM);

my %JUNKCELL_SUBTYPE = (NAME => 1, DATA => 1, RGNN => 1);

sub indent_result {
    my($str) = @_;
    $str =~ tr/\r//d;
    $str =~ s/\n/\n\t\t/g;
    return("\t\t$str");
}

sub dbg_word {
    my($longstr) = @_;
    my $len = length($longstr);
    if ($len != 4) {
	warn "dbg_word: expected length of 4, got $len\n";
	return;
    }
    sprintf(qq{[UNKNOWN_WORD: 0x%s (f:%0.2f) (L:%d) (S:%d S:%d) (C:%d C:%d C:%d C:%d)]},
	unpack("H*", $longstr), unpack("f", $longstr), unpack("L", $longstr), unpack("S2", $longstr), unpack("C4", $longstr));
}

sub decode_flags {
    my($flags, $flagdefs) = @_;
    my @list = ();
    foreach my $ref (@{$flagdefs}) {
	my($val, $name) = @$ref;
	push(@list, $name) if ($flags & $val);
    }
    my $flagstr = sprintf "0x%04x", $flags;
    return("$flagstr (" . join(", ", @list) . ")");
}

sub print_lookup {
    my($key, $hashref) = @_;
    return($hashref->{$key} || $key . "???");
}

###CODECS

my $DECODER_UNKNOWN = sub { return({ Unknown => unpack("H*", $_[0])}, {}); };
my $ENCODER_UNKNOWN = sub { return(pack("H*", $_[0]->{Unknown})); };
my %DECODE = ();
my %ENCODE = ();
my %RD = ();			# TBD switch to using the info from DECODE and get rid of RD

sub flatten {
    my @newlist;
    push(@newlist, (ref eq 'ARRAY') ? flatten(@$_) : $_) foreach (@_);
    return(@newlist);
}

sub compile_def {
    my($purpose, @def) = @_;
    my $format = "";
    my @keys;
    my %key_n;
    my %idx;
    my $index = 0;
    foreach my $ref (@def) {
	my($key, $fmt) = @$ref;
	if (ref($fmt) eq 'ARRAY') {
	    $format .= ($purpose eq 'decode') ? $fmt->[0] : $fmt->[1];
	} else {
	    $format .= $fmt;
	}
	foreach my $key (map { lc } flatten($key)) {
	    while (exists $idx{$key}) {
		$key =~ s/_\d+$//;
		$key .= '_' . $key_n{$key}++;
	    }
	    push(@keys, $key);
	    $idx{$key} = $index++;
	}
    }
    return($format, scalar(@keys), \@keys, \%idx);
}
sub default_decoder {
    my($type, @def) = @_;
    my($cdef, $nkeys, $keys) = compile_def('decode', @def);
    $RD{$type} = $cdef; # for transitional code
    my $decoder = sub {
	my($buff) = @_;
	my %hr;
	my @vals = unpack($cdef, $buff);
	my $nvals = scalar(@vals);
	die "Error in codec: nvals($nvals) != nkeys($nkeys)\n"
	    if ($nvals > $nkeys);
	foreach my $key (@$keys) {
	    my $val = shift(@vals);
	    $hr{$key} = $val;
	    last unless (@vals);
	}
	return(\%hr);
    };
    return($decoder);
};
sub default_encoder {
    my(@def) = @_;
    my($cdef, $nkeys, $keys, $idx) = compile_def('encode', @def);
    my $encoder = sub {
	my($hr) = @_;
	my @rec = ();
	while (my($key, $val) = each %$hr) {
	    $rec[$idx->{lc($key)}] = $val;
	}
	return(pack($cdef, @rec));
    };
    return($encoder);
};
sub default_codec {
    my($type, @def) = @_;
    $DECODE{$type} = default_decoder($type, @def);
    $ENCODE{$type} = default_encoder(@def);
}
default_codec('TES3.HEDR', (["Version", "f"],
			    ["Is_Master", "L"],
			    ["Author", ["Z32", "a32"]],
			    ["Description", ["Z256", "a256"]],
			    ["NRecords", "L"]));
default_codec('TES3.MAST', (["Master", "Z*"]));

# custom codec for TES3.DATA
$RD{'TES3.DATA'} = "L2";
$DECODE{'TES3.DATA'} = sub {
    my($buff) = @_;
    my($l1, $l2) = unpack("L2", $buff);
    return({ Length => $l1 + ($l2 << 32) });
};
$ENCODE{'TES3.DATA'} = sub {
    my($hr) = @_;
    my $len = $hr->{Length};
    my $l1 = $len & 0xffffffff;
    my $l2 = $len >> 32;
    return(pack("L2", $l1, $l2));
};

default_codec('ALCH.ALDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Autocalc", "L"]));
default_codec('APPA.AADT', (["Type", "L"],
			    ["Quality", "f"],
			    ["Weight", "f"],
			    ["Value", "L"]));
default_codec('ARMO.AODT', (["Type", "L"],
			    ["Weight", "f"],
			    ["Value", "L"],
			    ["Health", "L"],
			    ["Enchant_Points", "L"],
			    ["Armor_Rating", "L"]));
default_codec('ARMO.INDX', (["Index", "C"]));
default_codec('BODY.BYDT', (["Body_Part", "C"],
			    ["Vampire", "C"],
			    ["Flags", "C"],
			    ["Part_Type", "C"]));
default_codec('BOOK.BKDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Scroll", "L"],
			    ["Skill", "L"],
			    ["Enchant_Points", "L"]));
default_codec('CELL.AMBI', (["Ambient_Color", "L"],
			    ["Sunlight_Color", "L"],
			    ["Fog_Color", "L"],
			    ["Fog_Density", "f"]));
default_codec('CELL.CSTN', (["Target", "Z*"])); # guessing this is: "Cast/Current Spell Target Name"

# custom codec for CELL_DATA
$DECODE{'CELL.DATA'} = sub {
    my($buff) = @_;
    my $dlen = length($buff);
    if ($dlen == 24) {
	my($x, $y, $z, $xrot, $yrot, $zrot) = unpack("f6", $buff);
	return({ X => $x, Y => $y, Z => $z,
		 X_angle => $xrot, Y_angle => $yrot, Z_angle => $zrot });
    } elsif ($dlen == 12) {
	my($flags, $unk, $fog) = unpack("LLf", $buff);
	if ($flags & 0x01) { 	# Interior
	    return({ Flags => $flags, Unknown => $unk, Fog_Density => $fog });
	} else {		# Exterior
	    my($x, $y) = unpack("x[L]ll", $buff);
	    return({ Flags => $flags, X => $x, Y => $y });
	}
    } else {
	die "DECODER ERROR on CELL.DATA, Invalid length: $dlen\n";
    }
};
$ENCODE{'CELL.DATA'} = sub {
    my($hr) = @_;
    if (exists $hr->{Flags}) {
	if ($hr->{Flags} & 0x01) { # Interior
	    return(pack("LLf", $hr->{Flags}, $hr->{Unknown}, $hr->{Fog_Density}));
	} else {		     # Exterior
	    return(pack("Lll", $hr->{Flags}, $hr->{X}, $hr->{Y}));
	}
    } else {
	return(pack("f6", $hr->{X}, $hr->{Y}, $hr->{Z},
		    $hr->{X_angle}, $hr->{Y_angle}, $hr->{Z_angle}));
    }
};

default_codec('CELL.FRMR', (["ObjIdx", "S"],
			    ["Unknown_1", "C"],
			    ["ModIdx", "C"]));
default_codec('CELL.NAM5', (["R", "C"], # Map Color
			    ["G", "C"],
			    ["B", "C"],
			    ["Unused", "C"]));
default_codec('CELL.NAM9', (["Owner", "L"]));
default_codec('CLAS.CLDT', (["Primary_Attribute", "L"],
			    ["Secondary_Attribute", "L"],
			    ["Specialization", "L"],
			    [[("Minor_Skill_1", "Major_Skill_1") x 5], "(L2)5"],
			    ["Flags", "L"],
			    ["AutoCalc", "L"]));
default_codec('CLOT.CTDT', (["Type", "L"],
			    ["Weight", "f"],
			    ["Value", "S"],
			    ["Enchant_Points", "S"]));
default_codec('CLOT.INDX', (["Index", "C"]));
default_codec('CONT.CNDT', (["Weight", "f"]));
default_codec('CONT.FLAG', (["Container_Flags", "L"]));
default_codec('CREA.AI_W', (["Distance", "S"],
			    ["Duration", "C"],
			    ["Time_of_day", "C"],
			    [[("Idle_1") x 10], "C10"]));
#default_codec('CREA.AIDT', ([[("AI_1") x 12], "C12"]));
default_codec('CREA.AIDT', (["Hello", "C"],
			    ["Unknown_1", "C"],
			    ["Fight", "C"],
			    ["Flee", "C"],
			    ["Alarm", "C"],
			    ["Unknown_1", "a3"],
			    ["Flags", "L"]));
default_codec('CREA.FLAG', (["Flags", "L"]));
default_codec('CREA.NPDT', (["Type", "L"],
			    ["Lev", "L"],
			    ["Str", "L"],
			    ["Int", "L"],
			    ["Wil", "L"],
			    ["Agi", "L"],
			    ["Spd", "L"],
			    ["End", "L"],
			    ["Per", "L"],
			    ["Lck", "L"],
			    ["Health", "L"],
			    ["Spell_Points", "L"],
			    ["Fatigue", "L"],
			    ["Soul", "L"],
			    ["Combat", "L"],
			    ["Magic", "L"],
			    ["Stealth", "L"],
			    ["Attack_1_Min", "L"],
			    ["Attack_1_Max", "L"],
			    ["Attack_2_Min", "L"],
			    ["Attack_2_Max", "L"],
			    ["Attack_3_Min", "L"],
			    ["Attack_3_Max", "L"],
			    ["Gold", "L"]));
default_codec('DIAL.DATA', (["Type", "C"],
			   # ["Unused", "a3"]
			   ));
default_codec('ENCH.ENDT', (["Type", "L"],
			    ["Cost", "L"],
			    ["Charge", "L"],
			    ["Autocalc", "L"]));
default_codec('ENCH.ENAM', (["Spell_Effect", "S"],
			    ["Skill", "C"],
			    ["Attribute", "C"],
			    ["Range", "L"],
			    ["Area", "L"],
			    ["Duration", "L"],
			    ["MagMin", "L"],
			    ["MagMax", "L"]));
default_codec('FACT.FADT', (["Primary_Attribute", "L"],
			    ["Secondary_Attribute", "L"],
			    [[("At1_1", "At2_1", "Sk1_1", "Sk2_1", "Fact_1") x 10], "(L5)10"],
			    [[("Sk_1") x 6], "L6"],
			    ["Unknown_1", "L"],
			    ["Flags", "L"]));
default_codec('GLOB.FNAM', (["VarType", "a"]));
default_codec('GMST.NAME', (["Name", "a*"]));
default_codec('INFO.ACDT', (["Actor_Data", "Z*"])); # (only in .ess)
default_codec('INFO.INAM', (["Name", "Z*"]));
default_codec('INFO.DATA', (["Unknown_1", "L"],
			    ["Disposition", "L"],
			    ["Rank", "C"],
			    ["Sex", "C"],
			    ["PCRank", "C"],
			    ["Unknown_1", "C"]));
default_codec('INFO.ANAM', (["Cell", "Z*"]));
default_codec('INFO.BNAM', (["Result", "a*"]));
default_codec('INFO.CNAM', (["Class", "Z*"]));
default_codec('INFO.DNAM', (["PC_Faction", "Z*"]));
default_codec('INFO.FNAM', (["Faction", "Z*"]));
default_codec('INFO.NAME', (["Response", "a*"]));
default_codec('INFO.NNAM', (["Next_ID", "Z*"]));
default_codec('INFO.ONAM', (["Actor", "Z*"]));
default_codec('INFO.PNAM', (["Prev_ID", "Z*"]));
default_codec('INFO.RNAM', (["Race", "Z*"]));
default_codec('INFO.QSTN', (["Quest_Name", "C"]));
default_codec('INFO.QSTF', (["Quest_Finished", "C"]));
default_codec('INFO.QSTR', (["Quest_Restart", "C"]));
default_codec('INFO.SCVR', (["Index", "a"],
			    ["Type", "a"],
			    ["Function", "a2"],
			    ["Comparison", "a"],
			    ["Name", "a*"]));
default_codec('INGR.IRDT', (["Weight", "f"],
			    ["Value", "L"],
			    [[("Effect_1") x 4], "l4"],
			    [[("Skill_1") x 4], "l4"],
			    [[("Attribute_1") x 4], "l4"]));
default_codec('LAND.INTV', (["X", "l"],
			    ["Y", "l"]));
default_codec('LEVC.DATA', (["List_Data", "L"]));
default_codec('LEVC.INTV', (["Level", "S"]));
default_codec('LEVC.NNAM', (["Chance_None", "C"]));
default_codec('LEVI.DATA', (["List_Data", "L"]));
default_codec('LEVI.INTV', (["Level", "S"]));
default_codec('LEVI.INAM', (["Name", "Z*"]));
default_codec('LEVI.NNAM', (["Chance_None", "C"]));
default_codec('LIGH.LHDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Time", "L"],
			    ["Radius", "L"],
			    ["Red", "C"],
			    ["Green", "C"],
			    ["Blue", "C"],
			    ["Unknown_1", "C"],
			    ["Flags", "L"]));
default_codec('LOCK.LKDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Quality", "f"],
			    ["Uses", "L"]));
default_codec('LTEX.DATA', (["Data", "Z*"]));
default_codec('MGEF.MEDT', (["School", "L"],
			    ["Base_Cost", "f"],
			    ["Flags", "L"],
			    ["Red", "L"],
			    ["Green", "L"],
			    ["Blue", "L"],
			    ["Speed", "f"],
			    ["Size", "f"],
			    ["SizeCap", "f"]));
default_codec('MISC.MCDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Unknown_1", "L"]));
default_codec('NPC_.CNDT', (["Data", "Z*"]));
default_codec('NPC_.FLAG', (["Flags", "L"]));
default_codec('NPC_.AIDT', (["Hello", "C"],
			    ["Unknown_1", "C"],
			    ["Fight", "C"],
			    ["Flee", "C"],
			    ["Alarm", "C"],
			    ["Unknown_1", "a3"],
			    ["Flags", "L"]));
default_codec('NPC_.AI_W', (["Distance", "S"],
			    ["Duration", "S"],
			    ["Time_of_day", "C"],
			    [[("Idle_1") x 8], "C8"],
			    ["Unknown_1", "C"]));

$DECODE{'NPC_.NPDT'} = sub {
    my($buff) = @_;
    my %hr;
    my $len = length($buff);
    if ($len == 12) {
	my($lev, $disp, $fact, $rank, $unk1, $unk2, $unk3, $gold) = unpack("SC6L", $_[0]);
	return({ Level => $lev, Disposition => $disp, Faction => $fact, Rank => $rank, Unk1 => $unk1, Unk2 => $unk2, Unk3 => $unk3, Gold => $gold });
    } elsif ($len == 52) {
	my $i = 0;
	my %hr;
	foreach my $skill_level (unpack("x[SC8]C27", $buff)) {
	    $hr{$SKILL{$i++}} = $skill_level;
	}
	($hr{Level}, $hr{Str}, $hr{Int}, $hr{Wil}, $hr{Agi}, $hr{Spd}, $hr{End},
	 $hr{Per}, $hr{Lck}, $hr{Rep}, $hr{Health}, $hr{Magicka}, $hr{Fatigue},
	 $hr{Disposition}, $hr{Faction}, $hr{Rank}, $hr{Gold}) = unpack("SC8x[C27]CSSSCCCxL", $buff);
	return(\%hr);
    } else {
	warn "BAD NPC_.NPDT length ($len) is not 12 or 52!\n";
    }
};
$ENCODE{'NPC_.NPDT'} = sub {
    my($hr) = @_;
    if (exists $hr->{Magicka}) {
	return(pack("SC8C27CSSSCCCxL",
		    $hr->{Level}, $hr->{Str}, $hr->{Int}, $hr->{Wil}, $hr->{Agi},
		    $hr->{Spd}, $hr->{End}, $hr->{Per}, $hr->{Lck},
		    $hr->{"Block"}, $hr->{"Armorer"}, $hr->{"MediumArmor"}, $hr->{"HeavyArmor"},
		    $hr->{"BluntWeapon"}, $hr->{"LongBlade"}, $hr->{"Axe"}, $hr->{"Spear"},
		    $hr->{"Athletics"}, $hr->{"Enchant"}, $hr->{"Destruction"}, $hr->{"Alteration"},
		    $hr->{"Illusion"}, $hr->{"Conjuration"}, $hr->{"Mysticism"}, $hr->{"Restoration"},
		    $hr->{"Alchemy"}, $hr->{"Unarmored"}, $hr->{"Security"}, $hr->{"Sneak"},
		    $hr->{"Acrobatics"}, $hr->{"LightArmor"}, $hr->{"ShortBlade"}, $hr->{"Marksman"},
		    $hr->{"Mercantile"}, $hr->{"SpeechCraft"}, $hr->{"HandToHand"},
		    $hr->{Rep}, $hr->{Health}, $hr->{Magicka}, $hr->{Fatigue},
		    $hr->{Disposition}, $hr->{Faction}, $hr->{Rank}, $hr->{Gold}));
    } else {
	return(pack("SC6L", $hr->{Level}, $hr->{Disposition}, $hr->{Faction}, $hr->{Rank}, $hr->{Unk1}, $hr->{Unk2}, $hr->{Unk3},  $hr->{Gold}));
    }
};

#     "PCDT.SNAM" => $TOSTR_UNKNOWN, # .ess
#     "PCDT.ENAM" => $TOSTR_UNKNOWN, # .ess
#     "PCDT.FNAM" => $TOSTR_UNKNOWN, # .ess

default_codec('PROB.PBDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Quality", "f"],
			    ["Uses", "L"]));
default_codec('QUES.DATA', (["Info_ID", "Z*"])); # only in .ess (relates back to Actor in INFO)
default_codec('RACE.RADT', ([[("Skill_1", "Bonus_1") x 7], "(L2)7"],
			    [[("Attr_Male_1", "Attr_Female_1") x 8], "(L2)8"],
			    ["Male_Height", "f"],
			    ["Female_Height", "f"],
			    ["Male_Weight", "f"],
			    ["Female_Weight", "f"],
			    ["Flags", "L"]));
# REFR.ACDT (player Actor Data)
##(Not present???: Burden, Detect Animal, Detect Ench., Light, Night Eye, Slowfall, Telekinesis)
############################################################## Offset
default_codec('REFR.ACDT', ([[("Unknown_1") x 10], "L10"],   #   0
			    ["Health", "f"],		     #  40
			    ["Max_Health", "f"],	     #  44
			    ["Fatigue", "f"],		     #  48
			    ["Max_Fatigue", "f"],	     #  52
			    ["Unknown_1", "f"],		     #  56
			    ["Unknown_1", "f"],		     #  60
			    ["Unknown_1", "f"],		     #  64
			    ["Unknown_1", "f"],		     #  68
			    ["Unknown_1", "f"],		     #  72
			    ["Encumbrance", "f"],	     #  76
			    ["STR", "f"],		     #  80
			    ["STR_Base", "f"],		     #  84
			    ["INT", "f"],		     #  88
			    ["INT_Base", "f"],		     #  92
			    ["WIL", "f"],		     #  96
			    ["WIL_Base", "f"],		     # 100
			    ["AGI", "f"],		     # 104
			    ["AGI_Base", "f"],		     # 108
			    ["SPD", "f"],		     # 112
			    ["SPD_Base", "f"],		     # 116
			    ["END", "f"],		     # 120
			    ["END_Base", "f"],		     # 124
			    ["PER", "f"],		     # 128
			    ["PER_Base", "f"],		     # 132
			    ["LUC", "f"],		     # 136
			    ["LUC_Base", "f"],		     # 140
			    ["Fortify_Attack", "L"],	     # 144
			    ["Sanctuary", "L"],		     # 148
			    ["Resist_Magicka", "C"],	     # 152
			    ["Unknown_1", "a3"],
			    ["Resist_Fire", "C"],            # 156 (+ Fire Shield)
			    ["Unknown_1", "a3"],
			    ["Resist_Frost", "C"],           # 160 (+ Frost Shield)
			    ["Unknown_1", "a3"],
			    ["Resist_Shock", "C"],	     # 164 (+ Lightning Shield)
			    ["Unknown_1", "a3"],
			    ["Resist_Common_Disease", "L"],  # 168
			    ["Unknown_1", "L"],		     # 172
			    ["Unknown_1", "L"],		     # 176
			    ["Resist_Poison", "L"],	     # 180
			    ["Resist_Paralysis", "L"],	     # 184
			    ["Chameleon", "L"],		     # 188
			    ["Resist_Normal_Weapons", "L"],  # 192
			    ["Water_Breathing", "L"],	     # 196
			    ["Water_Walking", "L"],	     # 200
			    ["Swift_Swim", "L"],	     # 204
			    ["Unknown_1", "L"],		     # 208
			    ["Levitate", "L"],		     # 212
			    ["Shield", "L"],		     # 216
			    ["Unknown_1", "L"],		     # 220
			    ["Unknown_1", "L"],		     # 224
			    ["Blind", "L"],		     # 228
			    ["Unknown_1", "L"],		     # 232
			    ["Invisibility", "L"],	     # 236
			    ["unknown", "L"],		     # 240
			    ["Unknown_1", "L"],		     # 244
			    ["Unknown_1", "L"],		     # 248
			    ["Unknown_1", "L"],		     # 252
			    ["Unknown_1", "L"],		     # 256
			    ["Unknown_1", "L"]));	     # 260
default_codec("REFR.WNAM", (["Readied_Spell", "Z*"]));
default_codec('REGN.WEAT', (["Clear", "C"],
			    ["Cloudy", "C"],
			    ["Foggy", "C"],
			    ["Overcast", "C"],
			    ["Rain", "C"],
			    ["Thunder", "C"],
			    ["Ash", "C"],
			    ["Blight", "C"],
			    ["Snow", "C"], # Bloodmoon
			    ["blizzard", "C"])); # Bloodmoon
default_codec('REGN.CNAM', (["Red", "C"],
			    ["Green", "C"],
			    ["Blue", "C"],
			    ["Unused", "C"]));
default_codec('REGN.SNAM', (["Sound_Name", ["Z32", "a32"]],
			    ["Chance", "C"]));
default_codec('REGN.WNAM', (["Name", "L"]));
default_codec('REPA.RIDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Uses", "L"],
			    ["Quality", "f"]));
default_codec('SCPT.RNAM', (["Unknown_1", "L"]));
default_codec('SCPT.SCDT', (["Bytecode", "H*"]));
default_codec('SCPT.SCHD', (["Name", ["Z32", "a32"]],
			    ["Num_Shorts", "L"],
			    ["Num_Longs", "L"],
			    ["Num_Floats", "L"],
			    ["Data_Size", "L"],
			    ["Local_Var_Size", "L"]));
default_codec('SCPT.SCVR', (["Variables", "a*"]));
default_codec('SCPT.SCTX', (["Script", "a*"]));
default_codec('SKIL.SKDT', (["Attribute", "L"],
			    ["Specialization", "L"],
			    [[("Use_Values_1") x 4], "f4"]));
default_codec('SNDG.DATA', (["Data", "L"]));
default_codec('SPEL.SPDT', (["Type", "L"],
			    ["Cost", "L"],
			    ["Flags", "L"]));
default_codec('SPLM.NAME', (["Name", "L"]));
default_codec('SPLM.SPDT', (["Type", "L"],
			    ["Name", ["Z40", "a40"]],
			    [[("Long_1") x 2], "L2"],
			    ["Caster", ["Z32", "a32"]],
			    ["Item", "Z*"]));
default_codec('SPLM.NPDT', (["Name", ["Z40", "a40"]],
			    ["Magnitude", "l"],
			    ["Seconds_Active", "f"],
			    [[("Long_1") x 2], "l2"]));
default_codec('SPLM.XNAM', (["Name", "L"]));
default_codec('SPLM.TNAM', (["Target", "Z*"]));
default_codec('SOUN.DATA', (["Volume", "C"],
			    ["MinRange", "C"],
			    ["MaxRange", "C"]));
default_codec('SSCR.DATA', (["Name", "a*"]));
default_codec('STLN.ONAM', (["Name", "Z*"]));
default_codec('WEAP.WPDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Type", "S"],
			    ["Health", "S"],
			    ["Speed", "f"],
			    ["Reach", "f"],
			    ["Enchant_Points", "S"],
			    ["Chop_Min", "C"],
			    ["Chop_Max", "C"],
			    ["Slash_Min", "C"],
			    ["Slash_Max", "C"],
			    ["Thrust_Min", "C"],
			    ["Thrust_Max", "C"],
			    ["Flags", "L"]));
default_codec('VFXM.VNAM', ([[("Long_1") x 6], "(a4)6"],
			    ["Short", "S"],
			    ["Unknown_1", "a22"],
			    ["Name_2", ["Z36", "a36"]],
			    ["Name_3", ["Z68", "a68"]]));
default_codec('DELE', (["Unknown_1", "L"]));
default_codec('DODT', (["X", "f"],
		       ["Y", "f"],
		       ["Z", "f"],
		       ["Angle_X", "f"],
		       ["Angle_Y", "f"],
		       ["Angle_Z", "f"]));
default_codec('FLAG', (["Flags", "L"]));
default_codec('NPCO', (["Count", "l"],
		       ["Name", "a32"]));
default_codec('NPCS', (["String", "a32"]));
default_codec('XCHG', (["Enchant_Charge", "L"]));
default_codec('XHLT', (["Health", "L"]));
default_codec('XSCL', (["Scale", "f"]));
default_codec('XSOL', (["Soul", "Z*"]));
default_codec('WIDX', (["Equipped_Index", "l"],
		       ["Ammo_Flag", "l"]));
default_codec('SLCS', (["Shorts", "L"],
		       ["Longs", "L"],
		       ["Floats", "L"]));

$DECODE{'SLSD'} = \&unpack_short_array;
$ENCODE{'SLSD'} = \&pack_short_array;
$DECODE{'SLLD'} = \&unpack_long_array;
$ENCODE{'SLLD'} = \&pack_long_array;
$DECODE{'SLFD'} = \&unpack_float_array;
$ENCODE{'SLFD'} = \&pack_float_array;

$DECODE{"SPEL.ENAM"} = $DECODE{"ENCH.ENAM"};
$ENCODE{"SPEL.ENAM"} = $ENCODE{"ENCH.ENAM"};

# sub-records that decode as signed 32-bit longs:
foreach (qw(INTV)) {
    $DECODE{$_} = sub{ { Long => unpack("l", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("l", $_[0]->{Long} );
    };
}

# sub-records that decode as unsigned 32-bit longs:
foreach (qw(INDX NAM0 XIDX)) {
    $DECODE{$_} = sub{ { Long => unpack("L", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("L", $_[0]->{Long} ); };
}

# sub-records that decode as 32-bit floats:
foreach (qw(FLTV WHGT)) {
    $DECODE{$_} = sub{ { Float => unpack("f", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("f", $_[0]->{Float} ); };
}

# sub-records that decode as variable length strings:
foreach (qw(ANAM ASND AVFX BNAM BSND BVFX CNAM CSND CVFX DESC DNAM ENAM FGTN FNAM
HSND HVFX ITEX KNAM LSHN LSTN MNAM MODL NAME PTEX RGNN RNAM SCIP SCPT SCRI SNAM STRV
TEXT TGTN TNAM WNAM)) {
    $DECODE{$_} = sub{ { String => unpack("a*", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("a*", $_[0]->{String} ); };
}

###PRETTY PRINTER

my $TOSTR_UNK =
    sub { my $buff = $_[0];
	  sprintf qq{len:%d  hex:%s  str:"%s"}, length($buff),
	      unpack("H*", $buff), substr((($_ = $buff) =~ tr/\000-\037\177-\377//d, $_), 0, 60) };
my $TOSTR_DEBUG = sub { sprintf qq{DEBUG %s}, $TOSTR_UNK->($_[0]); };

my $DIALTYPE = "None";
my $NREC;
my %TOSTR =
    ("TES3.HEDR" => sub { my($ver, $is_master, $auth, $desc, $nrec) = unpack($RD{'TES3.HEDR'}, $_[0]);
			  $NREC = $nrec; # save it for later.
			  ($ver = sprintf("%0.2f", $ver)) =~ s/0+$//;
			  sprintf qq{\tVersion:$ver  Is_Master:%s\tAuthor:"$auth"\n\tDescription:"$desc"\n\tNRecords:$NREC},
			      ($is_master) ? "True" : "False"; },
     "TES3.MAST" => sub { unpack($RD{'TES3.MAST'}, $_[0]) },
     "TES3.DATA" => sub { my($l1, $l2) = unpack($RD{'TES3.DATA'}, $_[0]);
			  my $size = $l1 + ($l2 << 32);
			  "Length:     $size"; },
     "ALCH.ALDT" => sub { sprintf "Weight: %0.2f  Value: %d  Autocalc: %d", unpack($RD{'ALCH.ALDT'}, $_[0]) },
     "APPA.AADT" => sub { my($type, $qual, $wght, $val) = unpack($RD{'APPA.AADT'}, $_[0]);
			  sprintf "Type: %s  Quality: %0.2f  Weight: %0.2f  Value: %d",
			      $APPARATUS_TYPE{$type}, $qual, $wght, $val },
     "ARMO.AODT" => sub { my($type, $wght, $value, $health, $epts, $armor) = unpack($RD{'ARMO.AODT'}, $_[0]);
			  sprintf "Type: %s  Weight: %0.2f  Value: %d  Health %d  Enchant_Points: %d  ArmorRating: %d",
			      $ARMOR_TYPE{$type}, $wght, $value, $health, $epts, $armor},
     "ARMO.INDX" => sub { $ARMOR_INDEX{unpack($RD{'ARMO.INDX'}, $_[0])} },
     "BODY.BYDT" => sub { my($part, $vamp, $flags, $ptype) = unpack($RD{'BODY.BYDT'}, $_[0]);
			  sprintf "Bodypart: %s  Vampire: %d  Flag: %s  PartType: %s",
			      $BYDT_PART{$part}, $vamp, print_lookup($flags, \%BYDT_FLAGS), $BYDT_PTYP{$ptype}
		      },
     "BOOK.BKDT" => sub { my($wght, $val, $scrl, $skil, $epts) = unpack($RD{'BOOK.BKDT'}, $_[0]);
			  sprintf "Weight: %0.2f  Value: %d  Scroll: %s  Skill: %d  Enchant_Points: %d",
			      $wght, $val, (1 == $scrl) ? "Yes" : "No", $skil, $epts },
     "CELL.AMBI" => sub { sprintf("Ambient Color: 0x%08x  Sunlight Color: 0x%08x  Fog Color: 0x%08x  Fog Density: %0.2f",
				unpack($RD{'CELL.AMBI'}, $_[0])); },
     "CELL.CSTN" => sub { sprintf "Target: %s", unpack($RD{'CELL.CSTN'}, $_[0]); },
     "CELL.DATA" => sub {
	 if (length($_[0]) == 24) {
	     sprintf("Position x: %0.2f y: %0.2f z: %0.2f   Angle x: %0.2f y: %0.2f z: %0.2f", unpack("f6", $_[0]));
	 } else {
	     my($flags, $unkbuf, $fog_den_data) = unpack("La4f", $_[0]);
	     my @flags = ();
	     my $coord = '';
	     my $data_fog_str = '';
	     my $unk_str = '';
	     if ($flags & 0x01) {
		 push(@flags, "Interior");
		 $data_fog_str = sprintf "FogDensity: %0.2f ", $fog_den_data;
		 $unk_str = sprintf "Unk:0x%s ", unpack("H*", $unkbuf);
	     } else {
		 push(@flags, "Exterior");
		 my($x, $y) = unpack("x[L]ll", $_[0]);
		 $coord = "Coordinates: ($x, $y) ";
	     }
	     my $flags_str = "Flags: " . decode_flags($flags, \@CELL_FLAGS);
	     $coord . $data_fog_str . $unk_str . $flags_str;
	 }
     },
     "CELL.FRMR" => sub { sprintf "ObjIdx: %d Unk: %d ModIdx: %d", unpack($RD{'CELL.FRMR'}, $_[0]); },
     "CELL.NAM5" => sub { sprintf "Map_Color_RGB: (%x, %x, %x)", unpack($RD{'CELL.NAM5'}, $_[0]) },
     "CELL.NAM9" => sub { my $val = unpack($RD{'CELL.NAM9'}, $_[0]); (1 == $val) ? "Owner" : "Unk:$val"; },
     "CLAS.CLDT" => sub { my($attr1, $attr2, $spec, $min1, $maj1, $min2, $maj2, $min3, $maj3, $min4, $maj4, $min5, $maj5, $flags, $autoflags) =
			      unpack($RD{'CLAS.CLDT'}, $_[0]);
			  "  " . join("\n\t\t",
				      "Primary Attribute:   $ATTRIBUTE{$attr1}",
				      "Secondary Attribute: $ATTRIBUTE{$attr2}",
				      "Specialization: $SPECIALIZATION{$spec}",
				      "Major-Skill-1: $SKILL{$maj1}",
				      "Major-Skill-2: $SKILL{$maj2}",
				      "Major-Skill-3: $SKILL{$maj3}",
				      "Major-Skill-4: $SKILL{$maj4}",
				      "Major-Skill-5: $SKILL{$maj5}",
				      "Minor-Skill-1: $SKILL{$min1}",
				      "Minor-Skill-2: $SKILL{$min2}",
				      "Minor-Skill-3: $SKILL{$min3}",
				      "Minor-Skill-4: $SKILL{$min4}",
				      "Minor-Skill-5: $SKILL{$min5}",
				      "Flags: " . (($flags) ? "Playable" : "Non-playable"),
				      "AutoCalc Flags: " . decode_flags($autoflags, \@AUTOCALC_FLAGS));
		      },
     "CLOT.CTDT" => sub { my($type, $wght, $value, $epts) = unpack($RD{'CLOT.CTDT'}, $_[0]);
			  sprintf "Type: %s  Weight: %0.2f  Value: %d  Enchant_Points: %d",
			      $CTDT_TYPE{$type}, $wght, $value, $epts },
     "CLOT.INDX" => sub { unpack($RD{'CLOT.INDX'}, $_[0]) },
     "CONT.CNDT" => sub { sprintf "Weight: %0.2f", unpack($RD{'CONT.CNDT'}, $_[0]) },
     "CONT.FLAG" => sub { decode_flags(unpack($RD{'CONT.FLAG'}, $_[0]), \@CONTAINER_FLAGS) },
     "CREA.AI_W" => sub { my($hr) = $DECODE{'CREA.AI_W'}->($_[0]);
			  my $idle = join(", ", map { $hr->{"Idle_$_"} } 1..10);
			  sprintf "Distance: %d  Duration: %d  Time_of_day: %d, Idles: $idle",
			      $hr->{Distance}, $hr->{Duration}, $hr->{Time_of_day} },
#     "CREA.AIDT" => sub { join(", ", unpack($RD{'CREA.AIDT'}, $_[0])) },
     "CREA.AIDT" => sub { my($hello, $unk1, $fight, $flee, $alarm, $unk2, $unk3, $unk4, $flags) = unpack($RD{'NPC_.AIDT'}, $_[0]);
			  sprintf "Hello: %d  Fight: %d  Flee: %d  Alarm: %d  Flags: %s",
			      $hello, $fight, $flee, $alarm, decode_flags($flags, \@AIDT_FLAGS); },
     "CREA.FLAG" => sub { decode_flags(unpack($RD{'CREA.FLAG'}, $_[0]), \@CREATURE_FLAGS) },
     "CREA.NPDT" => sub { my($typ_i, $lev, $str, $int, $wil, $agi, $spd, $end, $per, $lck,
			     $hlth, $spelpts, $fat, $soul, $comb, $mag, $stlth,
			     $atkmin1, $atkmax1, $atkmin2, $atkmax2, $atkmin3, $atkmax3, $gold) = unpack($RD{'CREA.NPDT'}, $_[0]);
			  sprintf "Type: %s  Lev: %d  Str: %d  Int: %d  Wil: %d  Agi: %d  Spd: %d  End: %d  Per: %d  Lck: %d\n\t\tHealth: %d  Magicka: %d  Fatigue: %d  Soul: %d  Combat: %d  Magic: %d  Stealth: %d\n\t\tAttack-1 (%d, %d)  Attack-2: (%d, %d)  Attack-3 (%d, %d)  Gold: %d",
			      $CREA_TYPE[$typ_i], $lev, $str, $int, $wil, $agi, $spd, $end, $per, $lck,
				  $hlth, $spelpts, $fat, $soul, $comb, $mag, $stlth,
				      $atkmin1, $atkmax1, $atkmin2, $atkmax2, $atkmin3, $atkmax3, $gold;
		      },
     "DIAL.DATA" => sub { $DIALTYPE = $DIAL_TYPE{unpack($RD{'DIAL.DATA'}, $_[0])}; },
     "ENCH.ENDT" => sub { my($type, $cost, $chrg, $auto) = unpack($RD{'ENCH.ENDT'}, $_[0]);
		      sprintf "Type: %s  Cost: %d  Charge: %d  Autocalc: %d", $ENCHANT_TYPE{$type}, $cost, $chrg, $auto },
     "ENCH.ENAM" => sub { my($effect, $skill, $attr, $range, $area, $dur, $mmin, $mmax) = unpack($RD{'ENCH.ENAM'}, $_[0]);
			  my $spell = $SPELL_EFFECT{$effect};
			  if ($spell =~ /_attribute$/i) {
			      $spell .= "/$ATTRIBUTE{$attr}";
			  } elsif ($spell =~ /_skill$/i) {
			      $spell .= "/$SKILL{$skill}";
			  }
			  sprintf "%-28s  Range: %s  Area: %3d  Duration: %3d  MagMin: %4d  MagMax: %4d",
			      $spell, $RANGE_TYPE{$range}, $area, $dur, $mmin, $mmax },
     "FACT.FADT" => sub { my($attr1, $attr2, $rankdata, $skills, $unk, $flags) = unpack("LLa200a24LL", $_[0]);
			  my(@results) = sprintf "Attribute_1: %s  Attribute_2: %s  Unk:0x%x  Flags: %s",
			      $ATTRIBUTE{$attr1}, $ATTRIBUTE{$attr2}, $unk, decode_flags($flags, \@FACT_FLAGS);
			  push(@results, "\t\tFavored_Skills: " . join(", ", map { $SKILL{$_} } unpack("L6", $skills)));
			  foreach my $rd (unpack("(a20)10", $rankdata)) {
			      my($at1, $at2, $sk1, $sk2, $fact) = unpack("L5", $rd);
			      push(@results, sprintf "\t\tAttr_1: %3d  Attr_2: %3d  Skill_1: %3d  Skill_2: %3d  Fact: %3d",
				  $at1, $at2, $sk1, $sk2, $fact);
			  }
			  join("\n", @results);
		      },
     "INFO.ACDT" => sub { unpack($RD{'INFO.ACDT'}, $_[0]) }, # Actor Data? (only in .ess)
     "INFO.INAM" => sub { unpack($RD{'INFO.INAM'}, $_[0]) },
     "INFO.DATA" => sub { my($disp, $rank, $sex, $pcrank) = unpack($RD{'INFO.DATA'}, $_[0]);
			  $rank = "None" if $rank == 255;
			  $pcrank = "None" if $pcrank == 255;
			  if ($DIALTYPE eq "Journal") {
			      "JournalIndex: $disp";
			  } else {
			      "Disp:$disp  Rank:$rank  Sex:$SEX{$sex}  PCRank:$pcrank";
			  }},
     "INFO.ANAM" => sub { sprintf qq{Cell:       "%s"}, unpack($RD{'INFO.ANAM'}, $_[0]) },
     "INFO.BNAM" => sub { sprintf qq{Result:\n%s}, indent_result(unpack($RD{'INFO.BNAM'}, $_[0])) },
     "INFO.CNAM" => sub { sprintf qq{Class:      "%s"}, unpack($RD{'INFO.CNAM'}, $_[0]) },
     "INFO.DNAM" => sub { sprintf qq{PC Faction: "%s"}, unpack($RD{'INFO.DNAM'}, $_[0]) },
     "INFO.FNAM" => sub { sprintf qq{Faction:    "%s"}, unpack($RD{'INFO.FNAM'}, $_[0]) },
     "INFO.NAME" => sub { my $str = unpack($RD{'INFO.NAME'}, $_[0]); $str =~ tr/\r//d; sprintf qq{Response:   "%s"}, $str },
     "INFO.NNAM" => sub { sprintf qq{Next ID:    "%s"}, unpack($RD{'INFO.NNAM'}, $_[0]) },
     "INFO.ONAM" => sub { sprintf qq{Actor:      "%s"}, unpack($RD{'INFO.ONAM'}, $_[0]) },
     "INFO.PNAM" => sub { sprintf qq{Prev ID:    "%s"}, unpack($RD{'INFO.PNAM'}, $_[0]) },
     "INFO.RNAM" => sub { sprintf qq{Race:       "%s"}, unpack($RD{'INFO.RNAM'}, $_[0]) },
     "INFO.QSTN" => sub { my $val = unpack($RD{'INFO.QSTN'}, $_[0]);
			  (1 == $val) ? "Quest_Name" : "Unknown($val)" },
     "INFO.QSTF" => sub { my $val = unpack($RD{'INFO.QSTF'}, $_[0]);
			  (1 == $val) ? "Quest_Finished" : "Unknown($val)" },
     "INFO.QSTR" => sub { my $val = unpack($RD{'INFO.QSTR'}, $_[0]);
			  (1 == $val) ? "Quest_Restart" : "Unknown($val)" },
     "INFO.SCVR" => sub { my($idx, $typ, $fun, $cmp, $nam) = unpack($RD{'INFO.SCVR'}, $_[0]);
			  my $name = ($typ == 1) ? "" : "  Name:$nam";
			  sprintf "Index:$idx  Type:%s  Fun:%s  Cmp:%s$name",
			      print_lookup($typ, \%INFO_SCVR_type), print_lookup($fun, \%INFO_FUN), print_lookup($cmp, \%INFO_SCVR_cmp); },
     "INGR.IRDT" => sub { my($hr) = $DECODE{'INGR.IRDT'}->($_[0]);
			  my $result = sprintf "Weight: %0.2f  Value: %d  Effects: ",
			      $hr->{Weight}, $hr->{Value};
			  my @results;
			  foreach my $i (1..4) {
			      if ($hr->{"Effect_$i"} != -1) {
				  my $eix = $hr->{"Effect_$i"};
				  my $effect = $SPELL_EFFECT{$eix} || "${eix}???";
				  if ($effect =~ /_attribute$/i) {
				      push(@results, qq{$effect/$ATTRIBUTE{$hr->{"Attribute_$i"}}}); # $attrs[$i]
				  } elsif ($effect =~ /_skill$/i) {
				      push(@results, qq{$effect/$SKILL{$hr->{"Skill_$i"}}}); # $skills[$i]
				  } else {
				      push(@results, "$effect");
				  }
			      }
			  }
			  $result . join(", ", @results);
		      },
     "LAND.INTV" => sub { sprintf qq{Coordinates: (%d, %d)}, unpack($RD{'LAND.INTV'}, $_[0]) },
     "LEVC.DATA" => sub { "List Data: %d (1 = Calc from all levels <= PC level)", unpack($RD{'LEVC.DATA'}, $_[0]) },
     "LEVC.INTV" => sub { sprintf "Level: %d", unpack($RD{'LEVC.INTV'}, $_[0]) },
     "LEVC.NNAM" => sub { sprintf "ChanceNone: %d", unpack($RD{'LEVC.NNAM'}, $_[0]) },
     "LEVI.DATA" => sub { "List Data: %s ", $LEVI_DATA{unpack($RD{'LEVI.DATA'}, $_[0])} },
     "LEVI.INTV" => sub { sprintf "Level: %d", unpack($RD{'LEVI.INTV'}, $_[0]) },
     "LEVI.INAM" => sub { unpack($RD{'LEVI.INAM'}, $_[0]) },
     "LEVI.NNAM" => sub { sprintf "ChanceNone: %d", unpack($RD{'LEVI.NNAM'}, $_[0]) },
     "LIGH.LHDT" => sub { my($wght, $value, $time, $radius, $red, $green, $blue, $null, $flags) = unpack($RD{'LIGH.LHDT'}, $_[0]);
			  sprintf "Weight: %0.2f  Value: %d  Time: %d  Radius: %d  RGB: (%x, %x, %x)  Flags: %s",
			      $wght, $value, $time, $radius, $red, $green, $blue, decode_flags($flags, \@LHDT_FLAGS) },
     "LOCK.LKDT" => sub { sprintf "Weight: %0.2f  Value: %d  Quality: %0.2f  Uses: %d", unpack($RD{'LOCK.LKDT'}, $_[0]) },
     "LTEX.DATA" => sub { unpack($RD{'LTEX.DATA'}, $_[0]) },
     "MGEF.MEDT" => sub { my($school, $base, $flags, $red, $blue, $green, $speed, $size, $sizecap) = unpack($RD{'MGEF.MEDT'}, $_[0]);
			  sprintf "School: %s  BaseCost: %0.2f  Flags: %s  RGB: (%x, %x, %x)  SizeX: %0.2f  SizeCap: %0.2f",
			      $MAGIC_SCHOOL{$school}, $base, decode_flags($flags, \@MGEF_FLAGS), $red, $blue, $green, $size, $sizecap },
     "MISC.MCDT" => sub { sprintf "Weight: %0.2f  Value: %d  Unk:%0x", unpack($RD{'MISC.MCDT'}, $_[0]) },
#     "NPC_.ANAM" => $TOSTR_UNK,
#     "NPC_.KNAM" => $TOSTR_UNK,
     "NPC_.CNDT" => sub { unpack($RD{'NPC_.CNDT'}, $_[0]) },
     "NPC_.FLAG" => sub { decode_flags(unpack($RD{'NPC_.FLAG'}, $_[0]), \@NPC_FLAGS) },
     "NPC_.AIDT" => sub { my($hello, $unk1, $fight, $flee, $alarm, $unk2, $unk3, $unk4, $flags) = unpack($RD{'NPC_.AIDT'}, $_[0]);
			  sprintf "Hello: %d  Fight: %d  Flee: %d  Alarm: %d  Flags: %s",
			      $hello, $fight, $flee, $alarm, decode_flags($flags, \@AIDT_FLAGS); },
     "NPC_.AI_W" => sub { my($hr) = $DECODE{'NPC_.AI_W'}->($_[0]);
			  my $idle = join(", ", map { $hr->{"Idle_$_"} } 1..8);
			  sprintf "Distance: %d  Duration: %d  Time_of_day: %d, Idles: $idle",
			      $hr->{Distance}, $hr->{Duration}, $hr->{Time_of_day} },
     "NPC_.NPDT" => sub { my($hr) = $DECODE{'NPC_.NPDT'}->($_[0]);
			  if (exists $hr->{Str}) { # long form
			      my $skills = "";
			      my $n = 0;
			      foreach my $skill (sort values %SKILL) {
				  next if ($skill eq 'None');
				  $skills .= "\n\t\t" if (($n++ % 7) == 0);
				  $skills .= " $skill: $hr->{$skill}";# if (defined $hr->{$skill});
			      }
			      sprintf "  Level: %d  Str: %d  Int: %d  Wil: %d  Agi: %d  Spd: %d  End: %d  Per: %d  Lck: %d\n\t\tRep: %d  Health: %d Magicka: %d  Fatigue: %d  Disp: %d  Faction: %d  Rank: %d  Gold: %d\n\t\tSkills:$skills",
				  $hr->{Level}, $hr->{Str}, $hr->{Int}, $hr->{Wil}, $hr->{Agi}, $hr->{Spd},
				      $hr->{End}, $hr->{Per}, $hr->{Lck}, $hr->{Rep}, $hr->{Health}, $hr->{Magicka},
					  $hr->{Fatigue}, $hr->{Disposition}, $hr->{Faction}, $hr->{Rank}, $hr->{Gold};
			  } else {		   # short form (autocalced)
			      sprintf "Level: %d  Disposition: %d  Faction: %d  Rank: %d  Gold: %d",
				  $hr->{Level}, $hr->{Disposition}, $hr->{Faction}, $hr->{Rank}, $hr->{Gold};
			  }
		      },
     "PCDT.SNAM" => $TOSTR_UNK, # .ess
     "PCDT.ENAM" => $TOSTR_UNK, # .ess
     "PCDT.FNAM" => $TOSTR_UNK, # .ess
     "PROB.PBDT" => sub { sprintf "Weight: %0.2f  Value: %d  Quality: %0.2f  Uses: %d", unpack($RD{'PROB.PBDT'}, $_[0]) },
     "QUES.DATA" => sub { sprintf "INFO_ID: %s", unpack($RD{'QUES.DATA'}, $_[0]) }, # only in .ess (relates back to Actor in INFO)
     "RACE.RADT" => sub { my($hr) = $DECODE{'RACE.RADT'}->($_[0]);
			  my $result = sprintf "Flags: %s  Male_Height: %0.2f  Male_Weight: %0.2f  Female_Height: %0.2f  Female_Weight: %0.2f",
			      decode_flags($hr->{Flags}, \@RADT_FLAGS), $hr->{Male_Height}, $hr->{Male_Weight},
				  $hr->{Female_Height}, $hr->{Female_Weight};
			  $result .= "\n\t\tSkill Bonuses:";
			  foreach my $i (1..7) {
			      my($skill_id, $bonus) = ($hr->{"Skill_$i"}, $hr->{"Bonus_$i"});
			      $result .= sprintf("\n\t\t%-12s %3d", $SKILL{$skill_id}, $bonus);
			  }
			  my @attr_names = qw(Strength Intelligence Willpower Agility Speed Endurance Personality Luck);
			  $result .= "\n\t\tBase Attributes: Male/Female";
			  foreach my $i (1..8) {
			      my($male, $female) = ($hr->{"Attr_Male_$i"}, $hr->{"Attr_Female_$i"});
			      $result .= sprintf("\n\t\t%-12s    %3d  %3d", shift(@attr_names), $male, $female);
			  }
			  $result;
		      },
     "REFR.ACDT" => sub { sprintf "%s", unpack("H*", $_[0]) },
     "REFR.WNAM" => sub { my $spell = unpack($RD{'REFR.WNAM'}, $_[0]);
		      sprintf "Readied_Spell: %s", $spell },
     "REGN.WEAT" => sub { sprintf "Clear: %d  Cloudy: %d  Foggy: %d  Overcast: %d  Rain: %d  Thunder: %d  Ash: %d  Blight: %d  Snow: %d  Blizzard: %d",
			      unpack($RD{'REGN.WEAT'}, $_[0]) },
     "REGN.CNAM" => sub { "Map_Color_RGB: (%x, %x, %x)", unpack($RD{'REGN.CNAM'}, $_[0]) },
     "REGN.SNAM" => sub { "Chance: %3d  SoundName: %s", unpack($RD{'REGN.SNAM'}, $_[0]) },
     "REGN.WNAM" => sub { unpack($RD{'REGN.WNAM'}, $_[0]); },
     "REPA.RIDT" => sub { sprintf "Weight: %0.2f  Value: %d  Uses: %d  Quality: %0.2f", unpack($RD{'REPA.RIDT'}, $_[0]); },
     "SCPT.RNAM" => sub { sprintf "Unk:%x", unpack($RD{'SCPT.RNAM'}, $_[0]) },
     "SCPT.SCDT" => sub { if (DBG) { unpack($RD{'SCPT.SCDT'}, $_[0]) } else { "(Compiled script data)" }; },
     "SCPT.SCHD" => sub { sprintf "Name: %s  NumShorts: %d  NumLongs: %d  NumFloats: %d  ScriptDataSize: %d  LongVarSize: %d",
			      unpack($RD{'SCPT.SCHD'}, $_[0]); },
     "SCPT.SCVR" => sub { "Script Variables: " . join(',', split(/\000/, unpack($RD{'SCPT.SCVR'}, $_[0]))) },
     "SCPT.SCTX" => sub { "Script:\n" . unpack($RD{'SCPT.SCTX'}, $_[0]) },
     "SKIL.INDX" => sub { my $skill = unpack("L", $_[0]) ;
			  sprintf("%d (%s)", $skill, $SKILL{$skill});  },
     "SKIL.SKDT" => sub { my($attr, $spec, @usevals) = unpack($RD{'SKIL.SKDT'}, $_[0]);
			  sprintf "Attribute: %s  Specialization: %s  UseValues: %0.2f %0.2f %0.2f %0.2f",
			      $ATTRIBUTE{$attr}, $SPECIALIZATION{$spec}, @usevals},
     "SNDG.DATA" => sub { qq{"$SNDG_DATA[unpack($RD{'SNDG.DATA'}, $_[0])]"}; },
     "SPEL.SPDT" => sub { my($type, $cost, $flags) = unpack($RD{'SPEL.SPDT'}, $_[0]);
		      sprintf "Type: %s  Cost: %d  Flags: %s", $SPEL_TYPE{$type}, $cost, decode_flags($flags, \@SPEL_FLAGS) },
     "SPLM.NAME" => sub { unpack($RD{'SPLM.NAME'}, $_[0]); },
     "SPLM.SPDT" => sub {
	 # SPDT is 160 bytes long
	 my($type, $name, $long1, $long2, $caster, $item) = unpack($RD{'SPLM.SPDT'}, $_[0]);
	 sprintf qq{Type: %s  Name: "%s"  long1:%s  long2: %d  caster: "%s"  Item: "%s"},
	     $SPLM_TYPE{$type}, $name, dbg_word(pack("L", $long1)), $long2, $caster, $item;
     },
     "SPLM.NPDT" => sub {
	 # NPDT is 56 bytes long
	 my($name, $mag, $active, $long3, $long4) = unpack($RD{'SPLM.NPDT'}, $_[0]);
	 sprintf qq{Name: "%s"  Magnitude: %d  Seconds_Active: %0.1f  Long3: %d  Long4: %d},
	     $name, $mag, $active, $long3, $long4;
     },
     "SPLM.XNAM" => sub { sprintf "%d", unpack($RD{'SPLM.XNAM'}, $_[0]); },
     "SPLM.TNAM" => sub { sprintf "Target: %s", unpack($RD{'SPLM.TNAM'}, $_[0]); },
     "SOUN.DATA" => sub { sprintf "Volume: %d  MinRange: %d  MaxRange: %d", unpack($RD{'SOUN.DATA'}, $_[0]) },
     "SSCR.DATA" => sub { unpack($RD{'SSCR.DATA'}, $_[0]) },
     "STLN.ONAM" => sub { unpack($RD{'STLN.ONAM'}, $_[0]) },
     "WEAP.WPDT" => sub { my($wght, $value, $type, $health, $speed, $reach, $epts, $chopmin, $chopmax, $slashmin, $slashmax, $pokemin, $pokemax, $flags) = unpack($RD{'WEAP.WPDT'}, $_[0]);
		      sprintf " Wght: %0.2f  Val: %d  Typ: %s  Hlth: %d  Spd: %0.2f  Rch: %0.2f\n\t\tEnchant_Points: %d  Chop: %d-%d  Slash: %d-%d Thrust: %d-%d  Flags: %s",
			  $wght, $value, $WEAPON_TYPE{$type}, $health, $speed, $reach, $epts, $chopmin, $chopmax, $slashmin, $slashmax, $pokemin, $pokemax, $WEAPON_FLAGS{$flags}},
     "VFXM.VNAM" => sub {
	 my($long1, $long2, $long3, $long4, $long5, $long6, $short1, $hex1, $name2, $name3) =
	     unpack($RD{'VFXM.VNAM'}, $_[0]);
	 sprintf "\n  long1:%s\n  long2:%s\n  long3:%s\n  long4:%s\n  long5:%s\n  long6:%s\n  short1:%d\n  unk1:[%s]\n  name2: %s\n  name3: %s\n",
	     dbg_word($long1), dbg_word($long2), dbg_word($long3), dbg_word($long4), dbg_word($long5), dbg_word($long6), $short1, $TOSTR_UNK->($hex1), $name2, $name3;
     },

     # The following are common sub-record formats
     DELE => sub { sprintf "DELETED: Unk:0x%s", unpack($RD{'DELE'}, $_[0]) },
     DODT => sub { sprintf "Position x: %0.2f y: %0.2f z: %0.2f   Angle x: %0.2f y: %0.2f z: %0.2f", unpack($RD{'DODT'}, $_[0]) },
     FLAG => sub { sprintf "hexflags:0x%04x", unpack($RD{'FLAG'}, $_[0]) },
     NPCO => sub { sprintf 'Count=%d  Name="%s"', unpack("lZ*", $_[0]) }, # codec must use a32 for NAME
     XCHG => sub { sprintf "Enchant_Charge: %0.2f", unpack($RD{'XCHG'}, $_[0]) },
     XHLT => sub { sprintf "Health: %d", unpack($RD{'XHLT'}, $_[0]) },
     XSCL => sub { sprintf "Scale: %0.2f", unpack($RD{'XSCL'}, $_[0]) },
     XSOL => sub { sprintf "Soul: %s", unpack($RD{'XSOL'}, $_[0]) },
     WIDX => sub { my($idx, $ammo) = unpack($RD{'WIDX'}, $_[0]);
		   $ammo = ($ammo == 0) ? "" : " (Ammo)";
		   sprintf "Equipped_Idx:%3d$ammo",  $idx }, # JMS index into NPCO inventory items of those that are equipped
     SLCS => sub { sprintf "Shorts: %d  Longs: %d  Floats: %d", unpack($RD{'SLCS'}, $_[0]) }, # .ess
     SLSD => sub { sprintf "Short_Vals: " . join(", ", unpack($RD{'SLSD'}, $_[0])) }, # .ess
     SLLD => sub { sprintf "Long_Vals: " . join(", ", unpack($RD{'SLLD'}, $_[0])) }, # .ess
     SLFD => sub { sprintf "Float_Vals: " . join(", ", map { sprintf "%0.2f", $_ } join(", ", unpack($RD{'SLFD'}, $_[0]))) }, # .ess
    );

$TOSTR{"SPEL.ENAM"} = $TOSTR{"ENCH.ENAM"};

# sub-records that decode as signed 32-bit longs:
foreach (qw(INTV)) {
    $TOSTR{$_} = sub { unpack("l", $_[0]) }; }

# sub-records that decode as unsigned 32-bit longs:
foreach (qw(INDX NAM0 XIDX))
    { $TOSTR{$_} = sub { unpack("L", $_[0]) }; }

# sub-records that decode as 32-bit floats:
foreach (qw(FLTV WHGT))
    { $TOSTR{$_} = sub { sprintf "%0.2f", unpack("f", $_[0]) }; }

# sub-records that decode as variable length Z-strings:
foreach (qw(ANAM ASND AVFX BNAM BSND BVFX CNAM CSND CVFX DESC DNAM ENAM FGTN FNAM
HSND HVFX ITEX KNAM LSHN LSTN MNAM MODL NAME NPCS PTEX RGNN RNAM SCIP SCPT SCRI SNAM STRV
TEXT TGTN TNAM WNAM))
    { $TOSTR{$_} = sub { unpack("Z*", $_[0]) }; }

###DISPATCHER

my %CMDS =
    (
     # Type is 's' for commands that operate on one plugin at a time,
     # 'm' for multiple plugins at a time.
     #                    Options_fn            Command_fn           Type Description
     "cellnamepatch" => [ \&opts_cellnamepatch, \&cmd_cellnamepatch, 'm', "Tries to resolve multiple plugins renaming external cells"],
     "clean"         => [ \&opts_clean,         \&cmd_clean,         's', "Clean plugins of Evil GMSTs, junk cells, and more"],
     "common"        => [ \&opts_common,        \&cmd_common,        'm', "Find record IDs common between two plugins"],
     "delete"        => [ \&opts_delete,        \&cmd_delete,        's', "Delete records from plugin"],
     "diff"          => [ \&opts_diff,          \&cmd_diff,          'm', "Report differences between two plugins"],
     "dump"          => [ \&opts_dump,          \&cmd_dump,          's', "Dump records as text"],
     "esm"           => [ \&opts_esm,           \&cmd_esm,           's', "Convert plugin (esp) to master (esm)"],
     "esp"           => [ \&opts_esp,           \&cmd_esp,           's', "Convert master (esm) to plugin (esp)"],
     "fogpatch"      => [ \&opts_fogpatch,      \&cmd_fogpatch,      'm', "Solves 'black screen' bug due to interior cells with zero fog density"],
     "header"        => [ \&opts_header,        \&cmd_header,        's', "Read/Write plugin header fields (author, description)"],
     "help"          => [ \&opts_help ],
     "modify"        => [ \&opts_modify,        \&cmd_modify,        's', "Powerful batch record modification via user code extensions"],
     "objdelete"     => [ \&opts_objdelete,     \&cmd_objdelete,     's', "Delete objects from cells"],
     "overdial"      => [ \&opts_overdial,      \&cmd_overdial,      'm', "Identify overlapping dialog (a source of missing topic bugs)"],
     "print"         => [ \&opts_print,         \&cmd_print,         's', "Print records as readable text"],
     "recover"       => [ \&opts_recover,       \&cmd_recover,       's', "Recover usable records from plugin with 'bad form' errors"],
     "rename"        => [ \&opts_rename,        \&cmd_rename,        's', "Rename objects"],
     "-codectest"    => [ \&opts_codectest,     \&cmd_codectest,     's', "Test TES3 codec"],
     "-wikiout"      => [ \&opts_wikiout,       \&cmd_wikiout,       'm', "Output wiki formatted help"],
    );

my $command_list;
foreach (sort keys %CMDS) {
    $command_list .= "  $_\n    $CMDS{$_}->[3].\n"
	unless (($_ eq 'help') or ($_ =~ /^-/));
}
my $USAGE_ALL = qq{Usage: tes3cmd COMMAND OPTIONS plugins...

tes3cmd is a low-level command line tool that can examine, edit, and delete
records from a TES3 plugin for Morrowind.

COMMANDS
$command_list

For help on individual commands: tes3cmd help command

};

sub opts_help {
    if (my $cmd_name = shift(@ARGV)) {
	if (my $cmd_ref = $CMDS{$cmd_name}) {
	    $cmd_ref->[0]->(1);	# exits
	} else {
	    die $USAGE_ALL;
	}
    }
    die $USAGE_ALL;
}

###IO

sub update_header {
    my($plugin, $newauth, $newdesc, $newnrec) = @_;
    unless(open(PLUG, "+<$plugin")) {
	warn qq{Error opening "$plugin" for read/write ($!)\n};
	return;
    }
    unless(binmode(PLUG)) {
	warn "Error setting binmode on $plugin ($!)\n";
	close(PLUG);
	return;
    }
    my $block;
    my $nread = read(PLUG, $block, 4096);
    if ($nread == 0) {
	warn "$plugin: Error on intial read ($!)\n";
	close(PLUG);
	return;
    }
    my $magic = substr($block, 0, 4);
    if ($magic eq "TES3") {
	if ($nread >= 324) { 	# minimum TES3 plugin size
	    my $auth = chop_nulls(substr($block, $HDR_AUTH_OFFSET, $HDR_AUTH_LENGTH));
	    my $desc = chop_nulls(substr($block, $HDR_DESC_OFFSET, $HDR_DESC_LENGTH));
	    my $nrec = unpack("L", substr($block, $HDR_NREC_OFFSET, 4));
	    if ($newauth or $newdesc or $newnrec) {
		if ($newauth) {
		    unless (defined write_header_field($plugin, $auth, $newauth, "AUTHOR", $HDR_AUTH_OFFSET, $HDR_AUTH_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
		if ($newdesc) {
		    unless (defined write_header_field($plugin, $desc, $newdesc, "DESCRIPTION", $HDR_DESC_OFFSET, $HDR_DESC_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
		if ($newnrec) {
		    my $nrecbuff = pack("L", $newnrec);
		    warn "$plugin: Updating record count field from $nrec to $newnrec\n";
		    unless (defined write_header_field($plugin, undef, $nrecbuff, "NREC", $HDR_NREC_OFFSET, 4)) {
			close(PLUG);
			return;
		    }
		}
	    } else {
		if ($::opt_m) {
		    warn "$plugin:\n  AUTH=$auth\n  DESC=$desc\n  NREC=$nrec";
		} else {
		    warn "$plugin: AUTH=$auth DESC=$desc NREC=$nrec\n";
		}
	    }
	}
    } elsif ($magic eq "TES4") {
	warn "This function is not yet implemented for TES4 files\n";
    } else {
	warn "$plugin: Error, this does not appear to be an elder scrolls plugin\n";
    }
    close(PLUG);
}

sub write_header_field {
    my($plugin, $origval, $val, $label, $offset, $fieldlen) = @_;
    my $valbuff;
    if (defined $origval) {
	# TBD - I think this section needs rewriting.
	# handle special processing for string fields here
	if ($val =~ /^\+(.*)$/) {
	    $val = $origval . $1;
	}
	$val =~ s/(\\r|\r)?(\\n|\n)/\r\n/g;
	# create an empty null padded field
	$valbuff = "\000" x $fieldlen;
	# truncate $val to fit in the field, if necessary
	my $origlen = length($val);
	$val = substr($val, 0, $fieldlen - 1);
	if (length($val) < $origlen) {
	    warn "Warning, input $label truncated because it exceeded field length of: $fieldlen\n";
	}
	# TBD - probably not necessary, just use pack("a")
	# and plop the given string value into it, with at least one ending null
	substr($valbuff, 0, length($val)) = $val;
    } else {
	# non string fields get no special processing
	$valbuff = $val;
    }
    unless(seek(PLUG, $offset, 0)) {
	warn "$plugin: Error seeking to start of $label field at offset: $offset ($!)\n";
	return(undef);
    }
    if ((my $nwritten = syswrite(PLUG, $valbuff)) != length($valbuff)) {
	warn "$plugin: Error incomplete write to $label field ($!)\n";
	return(undef);
    }
    warn qq{$plugin: $label set to: "$val"\n} unless ($::opt_q or not defined($origval));
    return(1);
}

my @REC_FLAGS = ([0x0020, "Deleted"],
		 [0x0400, "Persistent"],
		 [0x1000, "Ignored"],
		 [0x2000, "Blocked"]);

my $hdr_size = 16;
sub read_rec {
    my($fh, $expected_type, $plugin) = @_;
    my $rec_hdr = "";
    my $n_read = sysread($fh, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef);
    }
    if ($n_read != $hdr_size) {
	my $inp_offset = sysseek($fh, 0, 1) - $n_read - $hdr_size;
	die qq{read_rec(): Read Error ($plugin header at byte: $inp_offset): asked for $hdr_size bytes, got $n_read\n};
    }
    my($rec_type, $rec_len, $unk, $flags) = unpack("a4LLL", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rec_type) {
	my $inp_offset = sysseek($fh, 0, 1) - $n_read - $hdr_size;
	die qq{read_rec(): Error ($plugin at byte: $inp_offset): Expected: $expected_type, got: $rec_type\n};
    }
    my $rec = "";
    $n_read = sysread($fh, $rec, $rec_len);
    if ($n_read != $rec_len) {
	my $inp_offset = sysseek($fh, 0, 1) - $n_read - $hdr_size;
	die qq{read_rec(): Read Error ($plugin record at byte: $inp_offset, rec_type="$rec_type"): asked for $rec_len bytes, got $n_read\n};
    }
    return($rec_type, $rec, $flags, $unk, $rec_hdr);
}

sub write_rec {
    my($fh, $rec_type, $rec, $flags, $unk) = @_;
    print $fh pack("a4LLLa*", $rec_type, length($rec), $unk, $flags, $rec);
}

sub subrec {
    my($type, $val) = @_;
    return(pack("a4La*", $type, length($val), $val));
}

sub ext_cell_name {
    my($srh, $name) = @_;
    $name = $name || chop_nulls($srh->{RGNN}[0]) || "Wilderness";
    if (length($srh->{DATA}[0]) < 12) { # size of "x[L]ll"
	warn "Error, CELL: ($name) does not have a valid DATA subrecord\n";
	return($name);
    } else {
	return(sprintf("$name (%d, %d)", unpack("x[L]ll", $srh->{DATA}[0])));
    }
}

sub rec_id {
    my($srh, $rec_type) = @_;
    if ($rec_type eq "INFO") {
	return(chop_nulls($srh->{INAM}[0]));
    } elsif ($rec_type eq "CELL") {
	my $name = chop_nulls($srh->{NAME}[0]);
	my $data = $srh->{DATA}[0];
	my($flags) = unpack("L", $data);
	if ($flags & 1) {	# interior
	    return($name);
	} else {		# exterior
	    return(ext_cell_name($srh, $name));
	}
    } elsif ($rec_type eq "SCPT") {
	return(lc(unpack("Z32", $srh->{SCHD}->[0])));
    } elsif (defined $srh->{NAME}) {
	return(lc(chop_nulls($srh->{NAME}->[0])));
    } elsif (defined $srh->{INDX}) {
	return(unpack("L", $srh->{INDX}->[0]));
    } elsif ($rec_type eq "LAND") {
	my($x, $y) = unpack("ll", $srh->{INTV}->[0]);
	return("($x, $y)");
    } elsif ($rec_type eq "TES3") {
	return('');
    }
    return(undef);
}

# given a reference to object returned by a decoder, return printable name
sub get_id {
    my($rec_type, $r) = @_;
    if ($rec_type eq "INFO") {
	foreach my $subr (@$r) {
	    if ($subr->[0] eq 'INAM') {
		return($subr->[1]->{Name});
	    }
	}
    } elsif ($rec_type eq "CELL") {
	my($name, $rgnn, $coord);
	foreach my $subr (@$r) {
	    if ($subr->[0] eq 'NAME') {
		$name = $subr->[1]->{String} unless (defined $name);
	    } elsif ($subr->[0] eq 'RGNN') {
		$rgnn = $subr->[1]->{String} unless (defined $rgnn);
	    } elsif ($subr->[0] eq 'DATA') {
		if (defined $subr->[1]->{X}) {
		    $coord = "$subr->[1]->{X}, $subr->[1]->{Y}"; # External Cell
		}
	    }
	    last if ($subr->[0] eq 'FRMR');
	}
	if (defined $coord) {	# this is an external cell
	    my $where = $name || $rgnn || 'Wilderness';
	    return("$where ($coord)");
	} else {		# this is an internal cell
	    return($name);
	}
    } elsif ($rec_type eq "SCPT") {
	foreach my $subr (@$r) {
	    return(lc(chop_nulls($subr->[1]->{Name})))
		if ($subr->[0] eq 'SCHD');
	}
    } elsif ($rec_type eq "LAND") {
	foreach my $subr (@$r) {
	    if ($subr->[0] eq 'INTV') {
		my $x = $subr->[1]->{X};
		my $y = $subr->[1]->{Y};
		return("($x, $y)");
	    }
	}
    } elsif (($rec_type eq "MGEF") or ($rec_type eq "SKIL")) {
	foreach my $subr (@$r) {
	    if ($subr->[0] eq 'INDX') {
		return($subr->[1]->{Long});
	    }
	}
    } elsif ($rec_type eq "TES3") {
	return('');
    } else {
	foreach my $subr (@$r) {
	    if ($subr->[0] eq 'NAME') {
		return($subr->[1]->{String});
	    }
	}
    }
    warn "get_id(): don't know how to make ID for: $rec_type\n";
    return(undef);
}

sub parse_subrec_list {
    my($rec) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @subrecs = ();
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@subrecs, [$subrec_type, $val]) if (defined $val);
	$p += $subrec_len;
    }
    return(\@subrecs);
}

# this version takes a little longer to execute
sub parse_subrec_hash_long {
    my($rec) = @_;
    warn "DBG: calling parse_subrec_hash_long for rec=$rec\n" if (DBG);
    my %r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@{$r{$subrec_type}}, $val) if (defined $val);
	$p += $subrec_len;
    }
    return(\%r);
}

sub parse_subrec_hash {
    my($rec) = @_;
    my %r = ();
    eval {
	my @parts = unpack("(a4L/a*)*", $rec);
	while (my($key, $buff) = splice(@parts, 0, 2)) {
	    push(@{$r{$key}}, $buff);
	}
    };
    if ($@) {
	warn qq{DBG: parse_subrec_hash failed on "$rec", retrying with safer parser\n} if (DBG);
	return(parse_subrec_hash_long($rec));
    }
    return(\%r);
}

sub parse_cell_objects {
    my($rec) = @_;
    my($hdr, $obj, @objs, %objidx);
    my $srl = parse_subrec_list($rec);
    foreach my $subr (@$srl) {
	my($subtype, $subrec) = @$subr;
	if ($subtype eq 'NAM0') {
	    if ($obj) {
		my @newobj = @$obj;
		push(@objs, \@newobj);
		$objidx{$newobj[1]} = $newobj[0];
	    }
	    push(@objs, 'NAM0');
	} elsif ($subtype eq 'FRMR') {
	    if ($obj) {
		my @newobj = @$obj;
		push(@objs, \@newobj);
		$objidx{$newobj[1]} = $newobj[0];
	    }
	    # start new object
	    $obj->[0] = [unpack($RD{'CELL.FRMR'}, $subrec)];
	    $obj->[1] = '';
	} else {
	    if ($obj) {		# collecting object
		$obj->[1] .= pack("a4L/a*", $subtype, $subrec);
	    } else {		# still collecting header
		$hdr .= pack("a4L/a*", $subtype, $subrec);
	    }
	}
    }
    if ($obj) {
	my @newobj = @$obj;
	push(@objs, \@newobj);
	$objidx{$newobj[1]} = $newobj[0];
    }
    return($hdr, \@objs, \%objidx);
}

sub assemble_cell_objects {
    my($hdr, $objs) = @_;
    my $rec = $hdr;
    my $idx = 1;
    foreach my $obj (@$objs) {
	if ($obj eq 'NAM0') {
	    my $nam0 = scalar(@$objs) - $idx;
	    $rec .= pack("a4LL", 'NAM0', 4, $nam0) if ($nam0 > 0);
	} else {
	    my $frmr = pack($RD{'CELL.FRMR'}, @{$obj->[0]});
	    $rec .=  pack("a4L/a*", 'FRMR', $frmr) . $obj->[1];
	}
	$idx++;
    }
    return($rec);
}

sub new_rec {
    my($sub_recs) = @_;
    my @rec;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	my $len = length($val);
	push(@rec, pack("a4La*", $type, $len, $val));
    }
    return(join("", @rec));
}

sub pprec {
    my($rec, $subtype) = @_;
    warn "DBG: pprec($rec)\n" if (DBG);
    my $recstr = join(":", grep(!/[^[:print:]]/, map { s/[\000]+$//gm; tr/\r\n/ /; $_; } split(/\000?([A-Z][A-Z_][A-Z_][A-Z_\d])...\000/, $rec)));
    $recstr =~ s/^:$subtype:.*?:// if ($subtype);
    $recstr =~ s/:([A-Z][A-Z_][A-Z_][A-Z_\d])/|$1/g;
    return(substr($recstr, 0, $::opt_w));
}

sub open_input_plugin {
    my($plugin) = @_;
    my $fh = IO::Handle->new();
    unless(open($fh, "<$plugin")) {
	die qq{Error opening "$plugin" for input ($!)\n};
    }
    unless (binmode($fh)) {
	die "Error setting binmode on $plugin ($!)\n";
    }
    return($fh);
}

sub open_output_plugin {
    my($plugin) = @_;
    my $fh = IO::Handle->new();
    unless(open($fh, ">$plugin")) {
	die qq{Error opening "$plugin" for output ($!)\n};
    }
    unless(binmode($fh, ':raw')) {
	die qq{Error setting binmode on "$plugin" ($!)\n};
    }
    return($fh);
}

sub get_record_count {
    my($plugin) = @_;
    my $count = -1;		# we don't count the TES3 record
    process_plugin_for_read($plugin, sub { $count++; });
    return($count);
}

sub make_temp {
    my($plugin) = @_;
    die qq{Error, "$plugin" name does not end in .esm/.esp/.ess\n}
	if ($plugin !~ /\.(es[mps])$/i);
    my $plugtmp = "$plugin.tmp";
    my $inp = open_input_plugin($plugin);
    my $out = open_output_plugin($plugtmp);
    return($inp, $out);
}

sub fix_output {
    my($inp, $out, $plugin, $modified, $newname) = @_;
    close($inp);
    close($out);
    my $plugtmp = "$plugin.tmp";
    unless ($modified) {
	print "$plugin was not modified\n";
	unlink($plugtmp);
	return;
    }
    if ($::opt_O) {
	$newname = $plugin unless ($newname);
	# prepend given output directory
	$newname = "$::opt_O/" . (fileparse($newname))[0];
    }
    if (my($ext) = ($plugin =~ /\.(es[mps])$/i)) {
	my($atime, $mtime) = (stat($plugin))[8,9];
	if (File::Spec->rel2abs($newname) eq File::Spec->rel2abs($plugin)) {
	    warn "fix_output(): newname ($newname) same as plugin ($plugin)\n";
	    undef $newname;
	}
	if (defined($newname)) {
	    unless ($newname =~ /\.(es[mps])$/i) {
		fatal_error(qq{"$newname" name does not end in .esm/.esp/.ess});
	    }
	    unless (rename($plugtmp, $newname)) {
		fatal_error(qq{Renaming "$plugtmp" to "$newname"});;
	    }
	    update_header($newname, undef, undef, get_record_count($newname));
	    utime($atime, $mtime, $newname);
	    print qq{Output saved in: "$newname"\nOriginal unaltered: "$plugin"\n};
	} else {
	    my $plugbak = $plugin;
	    while (-f $plugbak) {
		$plugbak =~ s/(?:~(\d+))?\.$ext$/'~' . ($1 + 1) . ".$ext"/e;
	    }
	    unless (rename($plugin, $plugbak)) {
		fatal_error(qq{Renaming "$plugin" to "$plugbak" ($!)});
	    }
	    unless (rename($plugtmp, $plugin)) {
		fatal_error(qq{Renaming "$plugtmp" to "$plugin"});
	    }
	    update_header($newname, undef, undef, get_record_count($newname));
	    utime($atime, $mtime, $plugin);
	    print qq{Output saved in: "$plugin"\nOriginal backed up to: "$plugbak"\n};
	}
    } else {
	die qq{Error, "$plugin" name does not end in .esm/.esp/.ess\n};
    }
}

sub cleanup_temp {
    my($inp, $plugin) = @_;
    close($inp);
    my $plugtmp = "$plugin.tmp";
    unlink($plugtmp);
}

sub read_object_ids {
    my($plugin, $fun) = @_;
    my $inp = open_input_plugin($plugin);
    my %plugin_id = ();
    eval {
	while (my($rec_type, $rec, $flags, $unk) = read_rec($inp, undef, $plugin)) {
	    last if not defined $rec_type;
	    if ($flags & 0x1000) {
		warn "plugin($plugin) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
		next;
	    }
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    if ($fun) {
		$fun->($rec_type, $id);
	    } else {
		warn "$plugin: $rec_type: $id\n" if (DBG);
		$plugin_id{$rec_type}->{$id} = 1 if (defined $id);
	    }
	}
    };
    warn $@ if ($@);
    close($inp);
    return(\%plugin_id) unless ($fun);
}

sub read_dialogs {
    my($plugin, $dialref) = @_;
    my $inp = open_input_plugin($plugin);
    eval {
	while (my($rec_type, $rec, $flags, $unk) = read_rec($inp, undef, $plugin)) {
	    last if not defined $rec_type;
	    if ($flags & 0x1000) {
		warn "plugin($plugin) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
		next;
	    }
	    next if ($rec_type ne "DIAL");
	    my $srh = parse_subrec_hash($rec);
	    my $id = chop_nulls($srh->{NAME}[0]);
	    my $type = unpack("C", $srh->{DATA}[0]);
	    $dialref->{$plugin}->{$id}++ if ($type == 0 and $id);
	}
    };
    warn $@ if ($@);
    close($inp);
}


sub get_wanted {
    my $wanted_ids;
    my $wanted_types;
    if ($::opt_i) {
	$wanted_ids = '(' . join('|', split(m!/!, $::opt_i)) . ')';
    }
    if ($::opt_t) {
	$::opt_t = uc $::opt_t;
	foreach my $option (split(m!/!, $::opt_t)) {
	    my($type, $subtype) = split(/\./, $option);
	    if (length($type) != 4) {
		warn qq{get_wanted_types: Invalid record type: "$type" (must be 4 characters long)\n};
		next;
	    }
	    $wanted_types->{$type}++;
	    if ($subtype) {
		if (length($subtype) == 4) {
		    $wanted_types->{"$type.$subtype"}++;
		} else {
		    warn qq{get_wanted_types: Invalid record subtype: "$subtype" (must be 4 characters long)\n};
		    next;
		}
	    }
	}
    }
    return($wanted_ids, $wanted_types);
}

my $CURRENT_DIAL;
sub rec_to_string {
    my($rec, $rec_type, $id, $plugin, $flags, $unk) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @print_rec;
    my $separator = $::opt_s || "\n ";
    my($prefix, $unkstr);
    $prefix = "\n" unless ($::opt_s);
    if (DBG) {
	$prefix = "$plugin ";
	$unkstr = sprintf "  Unk:%04x", $unk;
    }
    my $dial_str = ($rec_type eq 'INFO') ? " $CURRENT_DIAL" : '';
    my $flagstr = decode_flags($flags, \@REC_FLAGS);
    warn "REC=$rec_type $id flags=$flagstr\n" if (DBG);
    my $hdr = defined($flags) ? qq{${prefix}Record: $rec_type "$id"${dial_str} Flags: $flagstr${unkstr}$separator} : " ";
    my @frmr_data;
    my $first_frmr_seen = 0;
    my $frmr_match = 0;
    # TBD, for opt_C, we seem to bung the fog density.
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	$p += $subrec_len;
	if (defined $subrec) {
	    my $full_type = "${rec_type}.${subrec_type}";
	    my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type}  || $TOSTR_UNK;
	    my $subrec_str = $tostr->($subrec);
	    if ($::opt_C and ($rec_type eq 'CELL')) {
		if ($first_frmr_seen) {
		    if ($subrec_type eq 'FRMR') {
			if (join(" ", @frmr_data) =~ /$::opt_C/i) {
			    $frmr_match++;
			    push(@print_rec, @frmr_data);
			}
			@frmr_data = (); # start a new group
		    }
		    push(@frmr_data, "$subrec_type: $subrec_str");
		} else {
		    if ($subrec_type eq 'FRMR') {
			# start the first FRMR group
			$first_frmr_seen = 1;
			push(@frmr_data, "$subrec_type: $subrec_str");
		    } else {
			# we push subrecs onto print_rec up until the first FRMR
			push(@print_rec, "$subrec_type: $subrec_str");
		    }
		}
	    } else {
		push(@print_rec, "$subrec_type: $subrec_str");
	    }
	} else {
	    warn "$plugin: Error, malformed subrec for ($rec_type $id) type=$subrec_type pos=$p len=$subrec_len\n";
	}
    }
    # if -C, check the last FRMR group
    if ($::opt_C) {
	if (join(" ", @frmr_data) =~ /$::opt_C/i) {
	    $frmr_match++;
	    push(@print_rec, @frmr_data);
	}
	return("") unless ($frmr_match);
    }
    return($hdr . join($separator, @print_rec));
}

# read record-matching files user specified with -f/-F and add patterns to -m/-M switches
sub read_match_files {
    if ($::opt_f) {
	my @pats;
	my $mf = IO::Handle->new();
	unless(open($mf, "<$::opt_f")) {
	    die qq{Error opening "$::opt_f" for input ($!)\n};
	}
	while (<$mf>) {
	    chomp;
	    push(@pats, $_);
	}
	if (scalar(@pats) > 0) {
	    push(@pats, $::opt_m) if ($::opt_m);
	    $::opt_m = '(?:' . join('|', @pats) . ')';
	}
    }
    if ($::opt_F) {
	my @pats;
	my $mf = IO::Handle->new();
	unless(open($mf, "<$::opt_F")) {
	    die qq{Error opening "$::opt_F" for input ($!)\n};
	}
	while (<$mf>) {
	    chomp;
	    push(@pats, $_);
	}
	if (scalar(@pats) > 0) {
	    push(@pats, $::opt_M) if ($::opt_M);
	    $::opt_M = '(?:' . join("|", @pats) . ')';
	}
    }
}

sub decode_rec {
    my($plugin, $rec_type, $rec) = @_;
    #warn "decode_rec($plugin, $rec_type, $rec)\n";
    my $p = 0;
    my $rec_len = length($rec);
    # decode the sub-records for this record
    my @subrecs = ();
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	$p += $subrec_len;
	if (defined $subrec) {
	    my($hr) = decoder($rec_type, $subrec_type)->($subrec);
	    push(@subrecs, [$subrec_type, $hr]);
	} else {
	    warn "$plugin: Error, malformed subrec for ($rec_type) type=$subrec_type pos=$p len=$subrec_len\n";
	}
    }
    return(\@subrecs);
}

# encode and return a buffer for the subrecords that comprise the body of a full record.
sub encode_rec {
    my($rec_type, $r) = @_;
    my $newrec = '';
    foreach my $subr (@$r) {
	my($subrec_type, $hr) = @$subr;
	my $full_type = "${rec_type}.${subrec_type}";
	my $subrec = encoder($rec_type, $subrec_type)->($hr);
	$newrec .= pack("a4L/a*", $subrec_type, $subrec);
    }
    return($newrec);
}

sub process_plugin_for_read {
    my($plugin, $fun) = @_;
    read_match_files();
    my $inp = open_input_plugin($plugin);
    my $expected = "TES3";
    my($wanted_ids, $wanted_types) = get_wanted();
    # process each record in the plugin
    eval {
	while (my($rec_type, $rec, $flags, $unk, $rec_hdr) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if not defined $rec_type;
	    warn "REC=$rec_type flags=$flags\n" if (DBG);
	    if ($wanted_types) {
		unless ($wanted_types->{INFO} and ($rec_type eq 'DIAL')) {
		    next unless ($wanted_types->{$rec_type});
		}
	    }
	    my $srh = parse_subrec_hash($rec);
	    if ($rec_type eq 'DIAL') {
		$CURRENT_DIAL = '(' . $DIAL_TYPE{unpack("C", $srh->{DATA}[0])} . ':' . chop_nulls($srh->{NAME}[0]) . ')';
	    }
	    next if ($wanted_types and not $wanted_types->{$rec_type});
	    # process list of sub-records
	    my $id = rec_id($srh, $rec_type);
	    next if ($wanted_ids and $id !~ /$wanted_ids/i);
	    if ($::opt_m or $::opt_M) {
		my $print_rec = rec_to_string($rec, $rec_type, $id, $plugin, $flags, $unk);
		if (((not $::opt_m) or ($print_rec =~ /$::opt_m/i)) and
		    ((not $::opt_M) or ($print_rec !~ /$::opt_M/i))) {
		    $fun->($rec_type, $id, $rec, $srh, $flags, $unk, $rec_hdr)
		}
	    } else {
		$fun->($rec_type, $id, $rec, $srh, $flags, $unk, $rec_hdr)
	    }
	}
    };
    warn $@ if ($@);
    close($inp);
}

sub process_plugin_for_update {
    my($plugin, $fun, $prefix) = @_;
    read_match_files();
    my($inp, $out) = make_temp($plugin);
    my $expected = "TES3";
    my($wanted_ids, $wanted_types) = get_wanted();
    my $modified = 0;
    # process each record in the plugin
    eval {
	while (my($rec_type, $rec, $flags, $unk, $rec_hdr) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if not defined $rec_type;
	    warn "REC=$rec_type flags=$flags\n" if (DBG);
	    if ($wanted_types) {
		unless ($wanted_types->{INFO} and ($rec_type eq 'DIAL')) {
		    next unless ($wanted_types->{$rec_type});
		}
	    }
	    my $srh = parse_subrec_hash($rec);
	    if ($rec_type eq 'DIAL') {
		$CURRENT_DIAL = '(' . $DIAL_TYPE{unpack("C", $srh->{DATA}[0])} . ':' . chop_nulls($srh->{NAME}[0]) . ')';
	    }
	    next if ($wanted_types and not $wanted_types->{$rec_type});
	    # process list of sub-records
	    my $id = rec_id($srh, $rec_type);
	    next if ($wanted_ids and $id !~ /$wanted_ids/i);
	    my($newrec, $newflags);
	    if ($::opt_m or $::opt_M) {
		my $print_rec = rec_to_string($rec, $rec_type, $id, $plugin, $flags, $unk);
		if (((not $::opt_m) or ($print_rec =~ /$::opt_m/i)) and
		    ((not $::opt_M) or ($print_rec !~ /$::opt_M/i))) {
		    ($newrec, $newflags) = $fun->($rec_type, $id, $rec, $srh, $flags, $unk, $rec_hdr);
		}
	    } else {
		($newrec, $newflags) = $fun->($rec_type, $id, $rec, $srh, $flags, $unk, $rec_hdr);
	    }
	    if ($newrec) {
		write_rec($out, $rec_type, $newrec, $newflags, $unk);
		$modified++ if ($rec ne $newrec);
	    } else {
		$modified++;	# rec was deleted
	    }
	}
    };
    if ($@) {
	$modified = 0;
	warn $@;
    }
    if ($prefix) {
	my($file, $dir) = fileparse($plugin);
	my $newname = ($dir eq './') ? "${prefix}${file}" : "${dir}${prefix}${file}";
	fix_output($inp, $out, $plugin, $modified, $newname);
    } else {
	fix_output($inp, $out, $plugin, $modified);
    }
}

sub search_and_replace {
    my($x, $mref) = @_;
    my $type = ref($x);
    if ($type eq 'ARRAY') {
	foreach (@$x) {
	    if (ref($_) eq '') {
		${$mref} = 1 if eval qq{\$_ =~ s$::opt_r;};
	    } else {
		search_and_replace($_, $mref);
	    }
	}
    } elsif ($type eq 'HASH') {
	while (my($k, $v) = each %$x) {
	    if (ref($x->{$k}) eq '') {
		${$mref} = 1 if eval qq{\$x->{\$k} =~ s$::opt_r;};
	    } else {
		search_and_replace($x->{$k}, $mref);
	    }
	}
    } elsif ($type eq '') {
	my $x_before = $x;
	${$mref} = 1 if eval qq{\$_ =~ s$::opt_r;};
    }
}

sub getrec {
    my($r, $opt) = @_; 		# opt is hashref with keys: "i", "t", "f"
    my @indices = defined($opt->{i}) ? ($opt->{i}) : (0 .. $#$r);
    foreach my $i (@indices) {
	my $type = $r->[$i]->[0];
	next if (defined($opt->{t}) and ($type !~ /^$opt->{t}/i));
	if (defined($opt->{f})) {
	    my $key = lc($opt->{f});
	    if (defined($r->[$i]->[1]->{$key})) {
		return($r->[$i]->[1]->{$key});
	    } else {
		next;
	    }
	} else {
	    # give first (default) field
	    my @ordered_fields = ();
	    my @unordered_fields = ();
	    while (my($key, $val) = each %{$r->[$i]->[1]}) {
		if (defined $r->[$i]->[2]->{$key}) {
		    $ordered_fields[$r->[$i]->[2]->{$key}] = $val;
		} else {
		    push(@unordered_fields, $val);
		}
	    }
	    my @fields;
	    push(@fields, @ordered_fields, @unordered_fields);
	    return(shift, @fields);
	}
    }
    die "getrec: no match\n";
}

sub dumprec {
    my($r, $opt) = @_; 		# opt is hashref with keys: "i", "t", "f"
    my @indices = defined($opt->{i}) ? @{$opt->{i}} : (0 .. $#$r);
    foreach my $i (@indices) {
	my $type = $r->[$i]->[0];
	next if (defined($opt->{t}) and ($type !~ /^$opt->{t}/i));
	if (defined($opt->{f})) {
	    my $key = lc($opt->{f});
	    if (defined($r->[$i]->[1]->{$key})) {
		print qq{$i: $type  $key = $r->[$i]->[1]->{$key}\n};
	    } else {
		next;
	    }
	} else {
	    # dump all fields
	    my @ordered_fields = ();
	    my @unordered_fields = ();
	    while (my($key, $val) = each %{$r->[$i]->[1]}) {
		$val = qq{"$val"} if ($val =~ /[^\d.]/);
		my $print_key = lcfirst($key);
		if (defined $r->[$i]->[2]->{$key}) {
		    $ordered_fields[$r->[$i]->[2]->{$key}] = "$key = $val";
		} else {
		    push(@unordered_fields, "$key = $val");
		}
	    }
	    print " $i: $type ", join(", ", @ordered_fields, @unordered_fields), "\n";
	}
    }
    return(0);
}

sub setrec {
    my($r, $opt, $newval) = @_;	# opt is hashref with keys: "i", "t", "f"
    unless (defined $newval) {
	warn qq{Usage: setrec(\$option_hash, \$newvalue)
option_hash can have the keys: "i", "t", or "f"\n};
	return;
    }
    my $rc = 0;
    my @indices = defined($opt->{i}) ? @{$opt->{i}} : (0 .. $#$r);
    foreach my $i (@indices) {
	my $type = $r->[$i]->[0];
	next if (defined($opt->{t}) and ($opt->{t} ne $type));
	if (defined($opt->{f})) {
	    my $key = lc($opt->{f});
	    if (defined($r->[$i]->[1]->{$key})) {
		if ($r->[$i]->[1]->{$key} ne $newval) {
		    $r->[$i]->[1]->{$key} = $newval;
		    $rc++;
		}
		#print qq{$i: $type  $key = $r->[$i]->[1]->{$key}\n};
	    } else {
		next;
	    }
	} else {
	    # set all fields
	    my @ordered_fields = ();
	    my @unordered_fields = ();
	    while (my($key, $val) = each %{$r->[$i]->[1]}) {
		if ($newval ne $val) {
		    $val = $r->[$i]->[1]->{$key} = $newval;
		    $rc++;
		}
		if (defined $r->[$i]->[2]->{$key}) {
		    $ordered_fields[$r->[$i]->[2]->{$key}] = "$key = $val";
		} else {
		    push(@unordered_fields, "$key = $val");
		}
	    }
	    #print "$i: $type ", join(", ", @ordered_fields, @unordered_fields), "\n";
	}
    }
    return($rc);
}

sub remove_subrec {
    my($r, $subtype, $n) = @_;
    my @new_r = ();
    my $c = 0;
    foreach my $subr (@$r) {
	if ($subr->[0] eq $subtype) {
	    next unless ((defined $n) and ($c++ >= $n));
	}
	push(@new_r, $subr);
    }
    return(\@new_r);
}

sub run_code {
    my($rec_type, $r, $flags, $unk) = @_;
    my $mod = 0;
    search_and_replace($r, \$mod) if ($::opt_r);
    if ($::opt_e) {
	# under the covers, add the first argument '$r' (pointer to current record).
	$::opt_e =~ s/\b(dump|set)rec\s*\(/${1}rec(\$r,/g;
	$mod ||= eval($::opt_e);
	if ($@) {
	    warn qq{Error running "$::opt_e" on: $rec_type ($@)\n};
	    $mod = 0;
	}
    }
    return(($mod) ? $r : undef)
}

sub encoder {
    my($rec_type, $subrec_type) = @_;
    return($ENCODE{"${rec_type}.${subrec_type}"} || $ENCODE{$subrec_type} || $ENCODER_UNKNOWN);
}

sub decoder {
    my($rec_type, $subrec_type) = @_;
    return($DECODE{"${rec_type}.${subrec_type}"} || $DECODE{$subrec_type} || $DECODER_UNKNOWN);
}

sub master_cache_name {
    my($esm) = @_;
    my $cname = "$TES3CMD_DIR/$esm";
    $cname =~ s/\.esm$/.dat/;
    #warn "DBG: master_cache_name($esm) -> $cname\n";
    return($cname);
}

sub load_master_cache {
     my($esm) = @_;
    my $esm_file = list_files($DATADIR)->{$esm};
    my $mcache = master_cache_name($esm);
    warn "DBG: master cache name = $mcache\n" if (DBG);
    eval {
	if (my $listref = retrieve($mcache)) {
	    my($prev_size, $master_data) = @{$listref};
	    my $curr_size = (-s "$DATADIR/$esm_file");
	    if ($curr_size == $prev_size) {
		$MASTER_ID->{$esm} = $master_data;
		my $name = $mcache;
		$name =~ s/$DATADIR/<DATADIR>/;
		print "Loaded cached Master: $name\n";
	    } else {
		die "Cache Invalidated for: $esm_file (curr_size == $curr_size, prev_size == $prev_size)\n";
	    }
	} else {
	    die "Error retrieving master cache for: $esm_file\n";
	}
    };
    if ($@) {
	warn $@ unless ($@ =~ /can't open .*\.dat: No such file or directory/);
	return(0);
    } else {
	return(1);
    }
}

sub save_master_cache {
    my($esm) = @_;
    my $esm_file = list_files($DATADIR)->{$esm};
    my $mcache = master_cache_name($esm);
    mkdir($TES3CMD_DIR, 0755) unless (-d $TES3CMD_DIR);
    my $size = (-s "$DATADIR/$esm_file");
    warn "DBG: save_master_cache($esm) saving size: $size\n" if (DBG);
    store([ $size, $MASTER_ID->{$esm}], $mcache);
}

# load all the records from a master .esm into a dictionary.
sub load_master {
    my($esm, $types) = @_;
    $esm = lc($esm);
    warn "DBG: load_master($esm, $types)\n" if (DBG);
    find_datadir();
    if (defined $MASTER_ID->{$esm}) {
	warn "DBG: re-using master data: $esm\n" if (DBG);
	return;
    }
    return if (load_master_cache($esm)); # load pre-parsed data
    print "Loading Master: $esm\n";
    my $esm_file = list_files($DATADIR)->{$esm};
    my $inp = open_input_plugin("$DATADIR/$esm_file");
    eval {
	while (my($rec_type, $rec, $flags) = read_rec($inp, undef)) {
	    last if not defined $rec_type;
	    next if (defined $types and not $types->{$rec_type});
	    if ($flags & 0x1000) {
		print "Master($esm) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
		next;
	    }
	    print "DBG: rec_type = $rec_type\n" if (DBG);
	    my $srh = parse_subrec_hash($rec);
	    my $id = rec_id($srh, $rec_type);
	    $MASTER_ID->{$esm}->{$id}->{$rec_type} = [$srh, $rec, $flags];
	}
    };
    warn $@ if ($@);
    close($inp);
    save_master_cache($esm);
}

sub dumpit {
    my($label, $it) = @_;
    $it =~ s/([[:cntrl:]])/"^".chr(ord($1)+64)/ge;
    warn("$label: [$it]\n" . (($::opt_D) ? unpack("H*", $it) . "\n" : ''));
}

###COMMANDS

sub cmd_codectest {
    my($plugin) = @_;
    return if ($plugin =~ /^test_/);
    my %exclude;
    if ($::opt_x) {
	# optional types to exclude
	foreach (split(m!/!, uc($::opt_x))) { $exclude{$_}++; }
    }
    print "\n", ("=" x 65), "\n";
    print "TESTING codec on: $plugin ...\n";
    my $fun = sub {
	my($rec_type, $id, $rec, $srh, $flags, $unk, $rec_hdr) = @_;
	my $r = decode_rec($plugin, $rec_type, $rec);
	my $newflags = $flags;
	my $newrec = '';
	my $p = 0;
	my $rec_len = length($rec);
	while ($p < $rec_len) {
	    my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	    my $full_type = "${rec_type}.${subrec_type}";
	    $p += 8;
	    my $subrec = substr($rec, $p, $subrec_len);
	    $p += $subrec_len;
	    if (defined $subrec) {
		my($hr) = decoder($rec_type, $subrec_type)->($subrec);
		my $newsubrec = encoder($rec_type, $subrec_type)->($hr);
		unless ($exclude{$full_type}) {
		    if ($newsubrec ne $subrec) {
			warn "CODEC FAILURE on sub-record ${full_type}:\n";
			if (length($newsubrec) != length($subrec)) {
			    warn "Encoded length mismatch: newrec: @{[length($newsubrec)]}  subrec: @{[length($subrec)]}\n";
			}
			dumpit('original', $subrec);
			dumpit('re-coded', $newsubrec);
			warn Dumper($hr);
			my $print_rec = rec_to_string($rec, $rec_type, $id, $plugin, $newflags, $unk);
			warn "Full Record:\n$print_rec\n";
			die "Test Halted\n" unless ($::opt_s);
		    }
		}
		$newrec .= pack("a4L/a*", $subrec_type, $newsubrec);
	    } else {
		warn "$plugin: Error, malformed subrec for ($rec_type) type=$subrec_type pos=$p len=$subrec_len\n";
	    }
	}
	unless ($exclude{$rec_type}) {
	    if ($rec ne $newrec) {
		warn "CODEC FAILURE on record ${rec_type}:\n";
		dumpit('original', $rec);
		dumpit('re-coded', $newrec);
		my $print_rec = rec_to_string($rec, $rec_type, $id, $plugin, $newflags, $unk);
		warn "Full Record:\n$print_rec\n";
	    }
	    if ((my $new_hdr = pack("a4LLL", $rec_type, length($rec), $unk, $newflags)) ne $rec_hdr) {
		warn "CODEC FAILURE on ${rec_type} Record Header:\n";
		dumpit('original', $rec_hdr);
		dumpit('re-coded', $new_hdr);
		my $print_rec = rec_to_string($rec, $rec_type, $id, $plugin, $newflags, $unk);
		warn "Full Record:\n$print_rec\n";
	    }
	}
	return($newrec, $newflags);
    };
    process_plugin_for_update($plugin, $fun, "test_");
}

sub cmd_wikiout {
    foreach my $cmd (sort keys %CMDS) {
	next if (($cmd eq 'help') or ($cmd =~ /^-/));
	my $usage = eval "\$@{[uc $cmd]}_USAGE";
	$usage =~ s/'/''/g;
	print "==$cmd==\n{{{\n$usage\n}}}\n\n";
    }
}

sub cmd_fogpatch {
    find_datadir();
    warn "Data Files is: $DATADIR\nScanning Active Plugins...\n";
    my $fogpatch = "$DATADIR/fogpatch.esp";
    my %cell;
    foreach my $plugin (load_order()) {
	next unless ($plugin =~ /\.es[mp]$/i);
	next if ($plugin eq "fogpatch.esp");
	warn "Scanning plugin: $plugin\n" if (DBG);
	my $inp = open_input_plugin("$DATADIR/$plugin");
	my $expected = "TES3";
	eval {
	    while (my($rec_type, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
		$expected = undef;
		last if not defined $rec_type;
		next unless ($rec_type eq 'CELL');
		my $srh = parse_subrec_hash($rec);
		my $data = $srh->{DATA}[0];
		my($flags, $fog_den_data) = unpack("Lx[L]f", $data);
		if (is_interior($srh)) {
		    unless ($flags & 128) { # behave like exterior
			my $name = chop_nulls($srh->{NAME}[0]);
			my $ambi = $srh->{AMBI}[0];
			my $fog_den_ambi;
			my $ambilen = length($ambi);
			if ($ambilen == 16) {
			    my $fog_den_ambi = unpack("x[L3]f", $ambi);
			    if ($fog_den_ambi != $fog_den_data) {
				$fog_den_data = 0.0 if ($fog_den_ambi == 0.0);
				warn "Warning, Fog Density in DATA ($fog_den_data) != AMBI ($fog_den_ambi)\n" if ($fog_den_data == 0.0);
			    }
			    if (0.0 == $fog_den_data) {
				warn "  FOGBUG: $plugin\t\tCELL: $name\n";
				$cell{$name} = [$data, $ambi, $plugin];
			    } else {
				if (defined($cell{$name})) {
				    warn qq{          $plugin CORRECTED fogbug in CELL: $name\n};
				    delete $cell{$name};
				}
			    }
			} else {
			    warn "Error: $plugin, CELL: $name, len(AMBI) subrec $ambilen != 16, skipping\n"
				if ($ambilen != 0);
			}
		    }
		}
	    }
	};
	warn $@ if ($@);
	close($inp);
    }
    my $out = open_output_plugin($fogpatch);
    print $out $blank_header;
    my $n = scalar keys %cell;
    warn qq{\n"Generating $fogpatch" to patch $n cells.\n} if ($n > 0);
    foreach my $name (sort keys %cell) {
	my($data, $ambi, $plugin) = @{$cell{$name}};
	print "  CELL: $name\t\t[$plugin]\n";
	# put in a non-zero fog density
	substr($data, 8, 4) = substr($ambi, 12, 4) = pack("f", 0.01);
	# write NAME, DATA, AMBI
	my $newrec = subrec("NAME", "$name\000") . subrec("DATA", $data) . subrec("AMBI", $ambi);
	write_rec($out, 'CELL', $newrec, $flags, $unk);
    }
    close($out);
    $::opt_a = "tes3cmd";
    $::opt_d = "Fogbug Patch";
    $::opt_q = 1;
    cmd_header($fogpatch);
}

sub cmd_cellnamepatch {
    find_datadir();
    warn "Data Files is: $DATADIR\nScanning Active Plugins...\n";
    my $patch_file = "cellnamepatch.esp";
    my $patch_path = "$DATADIR/$patch_file";
    my $n = 0;
    my %cell;
    my $outputflag = 0;
    foreach my $plugin (load_order()) {
	next if ($plugin eq $patch_file);
	warn "Scanning plugin: $plugin\n" if (DBG);
	my $inp = open_input_plugin("$DATADIR/$plugin");
	my $expected = "TES3";
	eval {
	    while (my($rec_type, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
		$expected = undef;
		last if not defined $rec_type;
		next unless ($rec_type eq 'CELL');
		my $srh = parse_subrec_hash($rec);
		my $data = $srh->{DATA}[0];
		my($flags) = unpack("L", $data);
		unless ($flags & 1) { # only do exterior cells
		    my $name = chop_nulls($srh->{NAME}[0]);
		    my $coord = join(", ", unpack("x[L]ll", $srh->{DATA}[0]));
		    if (exists $cell{$coord}->{NAME}) {
			my $prevname = $cell{$coord}->{NAME};
			if ($prevname ne $name) {
			    if ($name eq $cell{$coord}->{ORIGNAME}) {
				warn qq{CELL: ($coord) RENAME REVERTED by: [$plugin] from: "$prevname" to: "$name". Reversion will be undone.\n};
				$cell{$coord}->{OUTPUTFLAG}++;
				$outputflag++;
			    } elsif ($name) {
				warn qq{CELL: ($coord) Renamed by: [$plugin] from: "$prevname" to: "$name"\n};
				my $prevname = $cell{$coord}->{NAME};
				my $prevplug = $cell{$coord}->{PLUG};
				warn qq{CELL: ($coord) Replacing: [$prevplug]:"$prevname" with: [$plugin]:"$name"\n};
				my $newrec = subrec("NAME", "$name\000") . subrec("DATA", $data);
				$cell{$coord}->{NAME} = $name;
				$cell{$coord}->{PLUG} = $plugin;
				$cell{$coord}->{REC} = [$rec_type, $newrec, $flags, $unk];
			    } else {
				warn qq{CELL: ($coord) Skipping null name: [$plugin]:"$name"\n};
			    }
			}
		    } else {
			$cell{$coord}->{ORIGNAME} = $name;
			$cell{$coord}->{ORIGPLUG} = $plugin;
			$cell{$coord}->{NAME} = $name;
			$cell{$coord}->{PLUG} = $plugin;
		    }
		}
	    }
	};
	warn $@ if ($@);
	close($inp);
    }
    if ($outputflag) {
	warn "\nGenerating $patch_file to preserve the following CELL renamings:\n";
	my $out = open_output_plugin($patch_path);
	print $out $blank_header;
	foreach my $coord (%cell) {
	    if ($cell{$coord}->{OUTPUTFLAG}) {
		my $recref = $cell{$coord}->{REC};
		if ($recref) {
		    warn qq{CELL: ($coord) -> NAME: "$cell{$coord}->{NAME}"\n};
		    write_rec($out, @{$recref});
		}
	    }
	}
	close($out);
	$::opt_a = "tes3cmd";
	$::opt_d = "Cell Name Patch";
	$::opt_q = 1;
	cmd_header($patch_path);
    }
}

sub cmd_overdial {
    my(@plugins) = @_;
    my %dialog;
    foreach my $plugin (@plugins) {
	read_dialogs($plugin, \%dialog);
    }
    my @testplugins = ($::opt_1) ? ($plugins[0]) : sort keys %dialog;
    foreach my $plugin1 (sort keys %dialog) {
	foreach my $plugin2 (@testplugins) {
	    if ($plugin1 ne $plugin2) {
		foreach my $id1 (keys %{$dialog{$plugin1}}) {
		    foreach my $id2 (keys %{$dialog{$plugin2}}) {
			if (length($id1) > length($id2) and $id1 =~ /\b$id2\b/i) {
			    printf qq{%-40s "$id1"\n%-40s "$id2"\n\n}, "$plugin1:", "$plugin2:";
			}
		    }
		}
	    }
	}
    }
}

# find objects in common between 2 plugins
sub cmd_common {
    my($plugin1, $plugin2) = @_;
    # swap plugins if plugin1 is larger than plugin2
    ($plugin1, $plugin2) = ($plugin2, $plugin1)
	if (-s $plugin1 > -s $plugin2);
    # read objects from smaller plugin
    my $objects1 = read_object_ids($plugin1);
    # compare to objects second plugin
    my $compare_fun = sub {
	my($rec_type, $id) = @_;
	if ($objects1->{$rec_type}->{$id} and ($rec_type ne 'TES3')) {
	    warn "  $rec_type: $id\n";
	}
    };
    read_object_ids($plugin2, $compare_fun);
}

sub read_objects {
    my($plugin, $fun) = @_;
    my $inp = open_input_plugin($plugin);
    my %plugin_id = ();
    eval {
	while (my($rec_type, $rec, $flags, $unk) = read_rec($inp, undef, $plugin)) {
	    last if not defined $rec_type;
	    if ($flags & 0x1000) {
		warn "plugin($plugin) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
		next;
	    }
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    if ($fun) {
		$fun->($rec_type, $id);
	    } else {
		$plugin_id{$rec_type}->{$id} = $rec if (defined $id);
	    }
	}
    };
    warn $@ if ($@);
    close($inp);
    return(\%plugin_id) unless ($fun);
}

sub output_diff {
    my($diff_file, $diff) = @_;
    if (@{$diff}) {
	my $fh = IO::Handle->new();
	if (open($fh, ">$diff_file")) {
	    print $fh join("\n", @{$diff});
	    close($fh);
	} else {
	    warn "Error opening $diff_file for output ($!)\n";
	}
    }
}

sub cmd_diff {
    my($plugin1, $plugin2) = @_;
    my $ignore;
    if ($::opt_i) {
	$ignore = '^(\s+(?:' . join('|', split(m!/!, $::opt_i)) . '):)\s.*$';
    }
    warn "IGNORE = $ignore\n" if (DBG);
    $::opt_o ||= 'e1/e2/eq/ne';
    my %rpt = map { $_, 1 } split(m!/!, lc($::opt_o));
    my $obj1 = read_objects($plugin1);
    my $obj2 = read_objects($plugin2);
    my @p1_not_p2;	     # objects in plugin1 that do not exist in plugin2
    my @p2_not_p1;	     # objects in plugin2 that do not exist in plugin1
    my @p1_equal_p2;	     # objects in plugin1 that are equal in plugin2
    my @p1_diff_p2;	     # objects in plugin1 that are different in plugin2
    my @diffs;		     # detailed diffs
    my(@diff1, @diff2);
    foreach my $rec_type (sort keys %{$obj1}) {
	next if ($rec_type eq 'TES3');
	foreach my $id (sort keys %{$obj1->{$rec_type}}) {
	    if (defined(my $rec2 = $obj2->{$rec_type}->{$id})) {
		my $rec1 = $obj1->{$rec_type}->{$id};
		my $print_rec1 = rec_to_string($rec1, $rec_type, $id, $plugin1);
		$print_rec1 =~ s/$ignore/$1 (IGNORED)/gmi if ($ignore);
		$print_rec1 =~ s/CELL.FRMR: ObjIdx: \d+ ModIdx: 0/CELL.FRMR: ObjIdx: (IGNORED) ModIdx: 0/gm;
		my $print_rec2 = rec_to_string($rec2, $rec_type, $id, $plugin2);
		$print_rec2 =~ s/$ignore/$1 (IGNORED)/gmi if ($ignore);
		$print_rec2 =~ s/CELL.FRMR: ObjIdx: \d+ ModIdx: 0/CELL.FRMR: ObjIdx: (IGNORED) ModIdx: 0/gm;
		if ($print_rec1 eq $print_rec2) {
		    push(@p1_equal_p2, "$rec_type: $id") if ($rpt{eq});
		} elsif ($rpt{ne}) {
		    push(@p1_diff_p2, "$rec_type: $id");
		    push(@diff1, "\n$rec_type: $id");
		    push(@diff1, $print_rec1);
		    push(@diff2, "\n$rec_type: $id");
		    push(@diff2, $print_rec2);
		}
	    } else {
		push(@p1_not_p2, "$rec_type: $id") if ($rpt{e1});
	    }
	}
    }
    foreach my $rec_type (sort keys %{$obj2}) {
	foreach my $id (sort keys %{$obj2->{$rec_type}}) {
	    unless (defined $obj1->{$rec_type}->{$id}) {
		push(@p2_not_p1, "$rec_type: $id") if ($rpt{e2});
	    }
	}
    }
    # now print the diff report
    if ($rpt{e1} and my $n = @p1_not_p2) {
	print qq{\nRecords in "$plugin1" not in "$plugin2" ($n):\n};
	foreach (@p1_not_p2) { print "$_\n"; }
    }
    if ($rpt{e2} and my $n = @p2_not_p1) {
	print qq{\nRecords in "$plugin2" not in "$plugin1" ($n):\n};
	foreach (@p2_not_p1) { print "$_\n"; }
    }
    if ($rpt{eq} and my $n  = @p1_equal_p2) {
	print qq{\nRecords that are equal in "$plugin1" and "$plugin2" ($n):\n};
	foreach (@p1_equal_p2) { print "$_\n"; }
    }
    if ($rpt{ne}) {
	my $diff1_file = fileparse($plugin1) . ".diff"; # get file basename
	my $diff2_file = fileparse($plugin2) . ".diff"; # get file basename
	if (my $n = @p1_diff_p2) {
	    print qq{\nRecords that are different between "$plugin1" and "$plugin2" ($n):\n(Compare $diff1_file to $diff2_file)\n};
	    foreach (@p1_diff_p2) {
		print "$_\n";
	    }
	}
	output_diff($diff1_file, \@diff1);
	output_diff($diff2_file, \@diff2);
    }
}

sub cmd_delete {
    my($plugin) = @_;
    unless ($::opt_i or $::opt_m and not $::opt_M) {
	die qq{Error: you must specify at least one of: -i, -m or -M to ensure deletions are intentional.\n};
	return;
    }
    read_match_files();
    my($inp, $out) = make_temp($plugin);
    my $expected = "TES3";
    my $modified = 0;
    my($wanted_ids, $wanted_types) = get_wanted();
    eval {
	while (my($rec_type, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if not defined $rec_type;
	    warn "REC=$rec_type flags=$flags\n" if (DBG);
	    my $nodelete = 0;
	    if ($wanted_ids) {
		my $id = rec_id(parse_subrec_hash($rec), $rec_type);
		$nodelete = 1 if ($id !~ /$wanted_ids/i);
	    }
	    $nodelete = 1 if ($wanted_types and not $wanted_types->{$rec_type});
	    if ($nodelete) {
		write_rec($out, $rec_type, $rec, $flags, $unk);
		next;
	    }
	    my $p = 0;
	    my $rec_len = length($rec);
	    my $first = 1;
	    my $print_rec = "";
	    my $newrec = "";
	    while ($p < $rec_len) {
		my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
		$p += 8;
		my $subrec = substr($rec, $p, $subrec_len);
		$p += $subrec_len;
		if (defined $subrec) {
		    my $full_type = "${rec_type}.${subrec_type}";
		    my $match = 0;
		    unless ($wanted_types and not $wanted_types->{$full_type}) {
			my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type}  || $TOSTR_UNK;
			my $subrec_str = $tostr->($subrec);
			if ($::opt_s) {
			    $match = 1 if (((not $::opt_m) or ($subrec_str =~ /$::opt_m/i)) and
					   ((not $::opt_M) or ($subrec_str !~ /$::opt_M/i)));
			}
			if ($match) {
			    warn "DELETED SUBRECORD: $subrec_str\n";
			    $modified++;
			}
			$print_rec .= "   $full_type: $subrec_str\n";
		    }
		    $newrec .= pack("a4La*", $subrec_type, $subrec_len, $subrec) unless ($match);
		} else {
		    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
		    warn "$plugin: Error, malformed subrec for ($rec_type $id) type=$subrec_type pos=$p len=$subrec_len\n";
		}
	    }
	    if ($::opt_s) {
		write_rec($out, $rec_type, $newrec, $flags, $unk);
	    } else {
		if (((not $::opt_m) or ($print_rec =~ /$::opt_m/i)) and
		    ((not $::opt_M) or ($print_rec !~ /$::opt_M/i))) {
		    warn "DELETED RECORD:\n$print_rec\n";
		    $modified++;
		} else {
		    write_rec($out, $rec_type, $rec, $flags, $unk);
		}
	    }
	}
    };
    if ($@) {
	warn $@;
	$modified = 0;
    }
    fix_output($inp, $out, $plugin, $modified);
}

sub cmd_objdelete {
    # TBD - switch to use parse_cell_objects/assemble_cell_objects
    my($plugin) = @_;
    unless ($::opt_i or $::opt_m and not $::opt_M) {
	die qq{Error: you must specify at least one of: -i, -m or -M to ensure deletions are intentional.\n};
    }
    my($inp, $out) = ($::opt_l) ? open_input_plugin($plugin) : make_temp($plugin);
    my $modified = 0;
    my $expected = "TES3";
    my $delete_ids = ($::opt_i) ? '(' . join('|', split(m!/!, $::opt_i)) . ')' : undef;
    eval {
	while (my($rec_type, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if not defined $rec_type;
	    my $nodelete = 0;
	    my $cell_id;
	    if ($rec_type eq 'CELL') {
		$cell_id = rec_id(parse_subrec_hash($rec), $rec_type);
		warn "REC=$rec_type flags=$flags CELL_ID=[$cell_id] DELETE_IDS=$delete_ids\n" if (DBG);
		$nodelete = 1 if ($delete_ids and $cell_id !~ /$delete_ids/i);
	    } else {
		$nodelete = 1;
	    }
	    if ($nodelete) {
		write_rec($out, $rec_type, $rec, $flags, $unk) unless ($::opt_l);
		next;
	    }
	    my $p = 0;
	    my $rec_len = length($rec);
	    my $print_obj = "";
	    my $newrec;
	    my $objrec;		# group of subrecs for current object
	    while ($p < $rec_len) {
		my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
		$p += 8;
		my $subrec = substr($rec, $p, $subrec_len);
		$p += $subrec_len;
		if (defined $subrec) {
		    my $full_type = "${rec_type}.${subrec_type}";
		    my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type} || $TOSTR_UNK;
		    my $subrec_str = $tostr->($subrec);
		    if ($subrec_type eq 'FRMR') { # TBD: NAM0 can also mark end, or MVRF(.ess)!
			# start of a new group of subrecs for new object
			if (((not $::opt_m) or ($print_obj =~ /$::opt_m/i)) and
			    ((not $::opt_M) or ($print_obj !~ /$::opt_M/i))) {
			    if ($::opt_l) {
				warn "MATCHED OBJECT IN CELL: $cell_id\n$print_obj\n";
			    } else {
				warn "DELETED OBJECT FROM CELL: $cell_id\n$print_obj\n";
				$modified++;
				$objrec = '';
			    }
			} else {
			    $newrec .= $objrec; # save last object group
			}
			$objrec = pack("a4La*", $subrec_type, $subrec_len, $subrec); # initialize new object group
			$print_obj = "   $full_type: $subrec_str\n";
		    } elsif ($objrec) {
			$objrec .= pack("a4La*", $subrec_type, $subrec_len, $subrec); # append to object group
			$print_obj .= "   $full_type: $subrec_str\n";
		    } else {
			# this block only for header subrecs (until first FRMR)
			$newrec .= pack("a4La*", $subrec_type, $subrec_len, $subrec);
		    }
		} else {
		    warn "$plugin: Error, malformed subrec for ($rec_type $cell_id) type=$subrec_type pos=$p len=$subrec_len\n";
		}
	    }
	    unless ($::opt_l) {
		$newrec .= $objrec if ($objrec);
		write_rec($out, $rec_type, $newrec, $flags, $unk);
	    }
	}
    };
    if ($@) {
	warn $@;
	$modified = 0;
    }
    if ($::opt_l) {
	close($inp);
    } else {
	fix_output($inp, $out, $plugin, $modified);
    }
}

sub cmd_modify {
    my($plugin) = @_;
    read_match_files();
    # load Perl program if specified with -p
    if ($::opt_p) {
	unless (do $::opt_p) {	# execute opt_p file
	    die "Error processing $::opt_p ($@)\n" if ($@);
	}
	$::opt_e = 'main($rec_type, $r, $flags, $unk);' unless ($::opt_e);
    }
    $::opt_m ||= '.'; 		# default is to match any record.
    my($inp, $out) = make_temp($plugin);
    my $expected = "TES3";
    my($wanted_ids, $wanted_types) = get_wanted();
    my $modified = 0;
    eval {
	while (my($rec_type, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if not defined $rec_type;
	    warn "REC=$rec_type flags=$flags\n" if (DBG);
	    my $nomodify = 0;
	    my $recid;
	    my $srh;
	    if ($wanted_ids) {
		$srh = parse_subrec_hash($rec);
		$recid = rec_id($srh, $rec_type);
		$nomodify = 1 if ($recid !~ /$wanted_ids/i);
	    }
	    $nomodify = 1 if ($wanted_types and not $wanted_types->{$rec_type});
	    if ($nomodify) {
		write_rec($out, $rec_type, $rec, $flags, $unk);
		next;
	    }
	    my $p = 0;
	    my $rec_len = length($rec);
	    my $first = 1;
	    my $print_rec = "";
	    my $newrec = "";
	    my @subrecs = ();
	    while ($p < $rec_len) {
		my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
		$p += 8;
		my $subrec = substr($rec, $p, $subrec_len);
		$p += $subrec_len;
		if (defined $subrec) {
		    my $full_type = "${rec_type}.${subrec_type}";
		    unless ($wanted_types and not $wanted_types->{$rec_type}) {
			my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type}  || $TOSTR_UNK;
			my($hr) = decoder($rec_type, $subrec_type)->($subrec);
			my $subrec_str = $tostr->($subrec);
			if ($::opt_s) {
			    if (((not $::opt_m) or ($subrec_str =~ /$::opt_m/i)) and
				((not $::opt_M) or ($subrec_str !~ /$::opt_M/i))) {
				# sub-record matches, so run our code on it ...
				warn "full_type=$full_type\n";
				if (my $newhr = run_code($full_type, $hr)) {
				    my $encoder = encoder($rec_type, $subrec_type);
				    $subrec = $encoder->($newhr);
				    $modified++;
				    $subrec_str = $tostr->($subrec);
				    warn "MODIFIED SUBRECORD: $subrec_str\n";
				} else {
				    $subrec = undef;
				}
			    }
			}
			push(@subrecs, [$subrec_type, $hr]);
			$print_rec .= "   $full_type: $subrec_str\n";
		    }
		    $newrec .= pack("a4La*", $subrec_type, $subrec_len, $subrec);
		} else {
		    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
		    warn "$plugin: Error, malformed subrec for ($rec_type $id) type=$subrec_type pos=$p len=$subrec_len\n";
		}
	    }
	    if ($::opt_s) {
		write_rec($out, $rec_type, $newrec, $flags, $unk);
	    } else {
		if (((not $::opt_m) or ($print_rec =~ /$::opt_m/i)) and
		    ((not $::opt_M) or ($print_rec !~ /$::opt_M/i))) {
		    if (my $modrec = run_code($rec_type, \@subrecs, $flags, $unk)) {
			#warn "Record was modified, encoding modified record\n";
			my $newrec = '';
			$newrec = encode_rec($rec_type, $modrec);
			if ($newrec ne $rec) {
			    $rec = $newrec;
			    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
			    warn "MODIFIED RECORD:\n" . rec_to_string($rec, $rec_type, $id, $plugin) . "\n";
			    $modified++;
			}
		    }
		}
		write_rec($out, $rec_type, $rec, $flags, $unk);
	    }
	}
    };
    if ($@) {
	warn $@;
	$modified = 0;
    }
    fix_output($inp, $out, $plugin, $modified);
}

my $plugin_banner;
sub cmd_print {
    my($plugin) = @_;
    read_match_files();
    warn "### Scanning $plugin\n" if ($::opt_v);
    my $inp = open_input_plugin($plugin);
    my $expected = "TES3";
    my($wanted_ids, $wanted_types) = get_wanted();
    my $dial; 			# current dialog string, used for printing INFOs
    if ($::opt_R) {
	$plugin_banner = $blank_header unless (defined $plugin_banner);
    } else {
	$plugin_banner = "\n$plugin:\n";
	$plugin_banner = undef if ($::opt_r);
	$plugin_banner = undef if ($::opt_n);
    }
    my $n = 1;
    eval {
	while (my($rec_type, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if not defined $rec_type;
	    my $srh = parse_subrec_hash($rec);
	    my $id = rec_id($srh, $rec_type);
	    next if ($wanted_ids and $id !~ /$wanted_ids/i);
	    if ($rec_type eq 'DIAL') {
		$CURRENT_DIAL = '(' . $DIAL_TYPE{unpack("C", $srh->{DATA}->[0])} . ':' . chop_nulls($srh->{NAME}->[0]) . ')';
	    }
	    next if ($wanted_types and not $wanted_types->{$rec_type});
	    $n = 0 if ($rec_type eq "TES3");
	    my $print_rec = rec_to_string($rec, $rec_type, $id, $plugin, $flags, $unk);
	    next if ($::opt_m and $print_rec !~ /$::opt_m/i);
	    next if ($::opt_M and $print_rec =~ /$::opt_M/i);
	    if ($print_rec and $plugin_banner) {
		print $plugin_banner;
		$plugin_banner = undef;
	    }
	    if ($::opt_l) {
		my $id = rec_id(parse_subrec_hash($rec), $rec_type);
		if ($rec_type eq 'CELL') {
		    my $objcnt;
		    $objcnt++ while ($print_rec =~ / FRMR:/g);
		    printf "$rec_type: %-45s\t%5d objects\n", $id, $objcnt;
		} else {
		    print "$rec_type: $id\n";
		}
	    } elsif ($::opt_r or $::opt_R) {
		if ($::opt_C and ($rec_type eq 'CELL')) {
		    my @frmr_data;
		    my $frmr_match = 0;
		    my $srl = parse_subrec_list($rec);
		    my @newrec = ();
		    my $first_frmr_seen = 0;
		    my $subrec_str = '';
		    my $tostr;
		    while (@$srl) {
			my $subrecref = shift(@$srl);
			my($subtype, $subrec) = @$subrecref;
			$tostr = $TOSTR{"CELL.$subtype"} || $TOSTR{$subtype};
			$subrec_str .= $tostr->($subrec);
			if ($first_frmr_seen) {
			    if ($subtype eq 'FRMR') {
				if ($subrec_str =~ /$::opt_C/i) {
				    $frmr_match++;
				    push(@newrec, @frmr_data);
				}
				$subrec_str = '';
				@frmr_data = (); # start a new group
			    }
			    push(@frmr_data, pack("a4L/a", $subtype, $subrec));
			} else {
			    if ($subtype eq 'FRMR') {
				$first_frmr_seen = 1;
				push(@frmr_data, pack("a4L/a", $subtype, $subrec));
			    } else {
				push(@newrec, pack("a4L/a", $subtype, $subrec));
			    }
			}
		    }
		    if ($subrec_str =~ /$::opt_C/i) {
			$frmr_match++;
			push(@newrec, @frmr_data);
		    }
		    if ($frmr_match) {
			my $newrec = join("", @newrec);
			print pack("a4LLLa*", $rec_type, length($newrec), $unk, $flags, $newrec);
		    }
		} else {
		    print pack("a4LLLa*", $rec_type, length($rec), $unk, $flags, $rec);
		}
	    } else {
		print "$print_rec\n" if ($print_rec);
	    }
	    $n++;
	}
    };
    warn $@ if ($@);
    $plugin_banner = "";
    close($inp);
} # cmd_print

sub cmd_rename {
    my($plugin) = @_;
    my($inp, $out) = ($::opt_l) ? open_input_plugin($plugin) : make_temp($plugin);
    my $modified = 0;
    unless ($::opt_l) {
	warn "\n$plugin: RENAMING Records:\n";
    }
    my $expected = "TES3";
    eval {
	while (my($rec_type, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if not defined $rec_type;
	    warn "REC=$rec_type flags=$flags\n" if (DBG);
	    if ($rec_type eq 'SCPT') {
		my $renamed_schd = 0;
		my $renamed_sctx = 0;
		my $srl = parse_subrec_list($rec);
		foreach my $subrec (@{$srl}) {
		    my $subtype = $subrec->[0];
		    if ($subtype eq "SCHD") {
			my($name, @schd_longs) = unpack("Z32L5", $subrec->[1]);
			if ($::opt_l) {	# only list records
			    printf qq{  $rec_type.$subtype  %-30s\n}, $name;
			} else {
			    my $newname;
			    eval qq{(\$newname = \$name) =~ s!$REN_FROM!$REN_TO!g};
			    if (length($newname) < 32) {
				if ($name ne $newname) {
				    $subrec->[1] = pack("a32L5", $newname, @schd_longs);
				    $renamed_schd = 1;
				    printf qq{    Renaming: $rec_type.$subtype %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
				}
			    } else {
				warn qq{New name for script: "$newname" is too long, must be less than 32 bytes\n};
			    }
			}
		    } elsif ($subtype eq "SCTX") {
			my $script = $subrec->[1];
			my $name = ($script =~ m!^[^;]*?\bbegin\s+(\S+)!im) ? $1 : "unknown";
			if ($::opt_l) {	# only list records
			    printf qq{  $rec_type.$subtype  %-30s\n}, $name;
			} else {
			    my $newname;
			    eval qq{(\$newname = \$name) =~ s!$REN_FROM!$REN_TO!g};
			    if ($name ne $newname) {
				$script =~ s/^[^;]*?\bbegin\s+(\S+)/Begin $newname/im;
				$subrec->[1] = $script;
				$renamed_sctx = 1;
				printf qq{    Renaming: $rec_type.$subtype %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			    }
			}
		    }
		}
		unless ($::opt_l) {
		    if ($renamed_schd and $renamed_sctx) {
			$modified++;
			$rec = new_rec($srl);
		    } else {
			my $what = "";
			$what .= " SCHD" unless $renamed_schd;
			$what .= " SCTX" unless $renamed_sctx;
			warn "Error renaming$what, record NOT updated.\n";
		    }
		}
	    } elsif ($rec_type eq $REN_TYPE) {
		my $renamed = 0;
		my $srl = parse_subrec_list($rec);
		my $name_idx = ($srl->[0]->[0] eq 'NAME') ? 0 : undef;
		if (defined($name_idx) and
		    my $name = chop_nulls($srl->[$name_idx]->[1])) {
		    if ($::opt_l) { # only list records
			my $recstr = pprec($rec, $REN_SUBTYPE);
			printf qq{  $rec_type  %-30s [%s]\n}, $name, $recstr;
		    } else {	# rename records
			my $do_rename = 1;
			$do_rename = 0 if ($rec_type eq "CELL" and not allowed_cell_type($srl));
			if ($do_rename) {
			    my $newname;
			    eval qq{(\$newname = \$name) =~ s!$REN_FROM!$REN_TO!g};
			    if ($name ne $newname) {
				$srl->[$name_idx]->[1] = "$newname\000";
				$renamed = 1;
				$modified++;
				printf qq{    Renaming: $REN_TYPE %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			    }
			}
		    }
		} else {
		    warn "Error, Record has no $REN_SUBTYPE sub-record: $rec\n";
		}
		$rec = new_rec($srl) if $renamed;
	    }
	    write_rec($out, $rec_type, $rec, $flags, $unk) unless($::opt_l);
	}
    };
    if ($@) {
	warn $@;
	$modified = 0;
    }
    if ($::opt_l) {
	cleanup_temp($inp, $plugin);
    } else {
	fix_output($inp, $out, $plugin, $modified);
    }
}

sub cmd_header {
    my($plugin) = @_;
    update_header($plugin, $::opt_a, $::opt_d, (($::opt_n) ? get_record_count($plugin) : 0));
}

sub convert_plugin {
    my($input) = @_;
    my $output;
    my $byte_expected;
    my $byte_new;
    if ($input =~ /\.esp$/i) {
	# convert plugin to master
	$byte_expected = "\000";
	$byte_new = "\001";
	($output = $input) =~ s/\.esp$/.esm/i;
    } else {
	# convert master to plugin
	$byte_expected = "\001";
	$byte_new = "\000";
	($output = $input) =~ s/\.esm$/.esp/i;
    }
    die qq{Error, $output already exists! (Use -o to overwrite)\n}
	if (-f $output and not $::opt_o);
    copy($input, $output) or die "Error, copy failed $input -> $output ($!)\n";
    eval {
	open(OUT, "+<$output") or die qq{Error opening "$output" for read/write ($!)};
	binmode(OUT) or die "Error setting binmode on $output ($!)";
	my $magic;
	(sysread(OUT, $magic, 4) == 4) or die "$output: Error reading magic ($!)";
	if ($magic eq "TES3") {
	    sysseek(OUT, 28, 0) or die "sysseek";
	    my $byte;
	    (sysread(OUT, $byte, 1) == 1) or die "$output: Error reading master byte ($!)\n";
	    my $val = unpack("C", $byte);
	    #warn "masterbyte = $val\n";
	    ($byte eq $byte_expected) or
		die qq{Error, expected master byte value of @{[unpack("C",$byte_expected)]}, got $val instead};
	    sysseek(OUT, 28, 0) or die "sysseek";
	    (syswrite(OUT, $byte_new, 1) == 1) or die "$output: Error writing master byte ($!)\n";
	} elsif ($magic eq "TES4") {
	    die "This function is not yet implemented for TES4 files";
	} else {
	    die "$output: Error, this does not appear to be Morrowind plugin";
	}
	close(OUT);
    };
    if ($@) {
	warn "$@\n";
	close(OUT);
	unlink($output);
	return;
    }
    my($atime, $mtime) = (stat($input))[8,9];
    utime($atime, $mtime, $output);
    warn "$input copied to $output\n"
}

# convert a master to a plugin
sub cmd_esp {
    my($master) = @_;
    die "Error, input must be a master (.esm)\n"
	unless($master =~ /\.esm$/i);
    convert_plugin($master);
}

# convert a plugin to a master
sub cmd_esm {
    my($plugin) = @_;
    die "Error, input must be a plugin (.esp)\n"
	unless($plugin =~ /\.esp$/i);
    convert_plugin($plugin);
}

my %gmst_type = ('i' => 'INTV', 'f' => 'FLTV', 's' => 'STRV');
sub cmd_clean {
    my($plugin) = @_;
    if ($plugin =~ /\.ess$/) {
	warn "Don't know how to clean savegames: $plugin ... yet\n";
	return;
    }
    if ($plugin =~ /^(Morrowind|Tribunal|Bloodmoon)\.esm$/i) {
	warn "Skipping Bethesda Master: $plugin\n";
	return;
    }
    if ($plugin =~ /~\d+\.es[mps]$/i) {
	warn "Skipping Backup: $plugin\n";
	return;
    }
    print "\nCLEANING: $plugin ...\n";
#    print "\nCLEANING: $plugin with options: ";
#    print "-c " if ($::opt_c);
#    print "-d " if ($::opt_d);
#    print "-g " if ($::opt_g);
#    print "-j " if ($::opt_j);
#    print "-o " if ($::opt_o);
#    print "\n";
    my %duptype;
    $duptype{$_}++ foreach (@CLEAN_DUP_TYPES);
    my %my_master;
    my $fun = sub {
	my($rec_type, $id, $rec, $srh, $flags, $unk) = @_;
	my $newrec = $rec;
	my $newflags = $flags;
	my $r;
	if ($rec_type eq 'GMST') {
	    if ($::opt_g) {
		my $type = $gmst_type{substr($id, 0, 1)};
		my $val = $srh->{$type}[0];
		my $hexval = unpack("H*", "$type $val");
		if ($EVIL_BM{$id} eq $hexval) {
		    print " Cleaned Evil GMST Bloodmoon: $id\n";
		    return;
		} elsif ($EVIL_TB{$id} eq $hexval) {
		    print " Cleaned Evil GMST Tribunal:  $id\n";
		    return;
		}
	    }
	} elsif ($rec_type eq 'CELL') {
	    my $cleaned_ambi;
	    my $cleaned_whgt;
	    my $plug_srl;
	    if ($::opt_o) {
		# CLEAN CELL OBJECTS
		my($p_hdr, $p_objs, $p_objidx) = parse_cell_objects($rec);
		my @new_objs;
		foreach my $obj (@$p_objs) {
		    do { push(@new_objs, $obj); next; } if ($obj eq 'NAM0');
		    my $object_body = $obj->[1];
		    my $cleaned_obj = 0;
		    foreach my $master (keys %{my_master}) {
			if (my $lref = $MASTER_ID->{$master}->{$id}->{CELL}) {
			    my($mast_srh, $mast_rec) = @{$lref};
			    my($m_hdr, $m_objs, $m_objidx) = parse_cell_objects($mast_rec);
			    if ($m_objidx->{$object_body}->[0] == $obj->[0]->[0]) { # compare master and plugin FRMR object indices
				$cleaned_obj++;
				last;
			    }
			}
		    }
		    if ($cleaned_obj) {
			my $obj_info = chop_nulls(parse_subrec_hash($obj->[1])->{NAME}[0]) . " FRMR:" . $obj->[0]->[0];
			print " Cleaned redundant object ($obj_info) from CELL: $id\n";
		    } else {
			push(@new_objs, $obj);
		    }
		}
		if (scalar(@new_objs) != scalar(@$p_objs)) {
		    $rec = assemble_cell_objects($p_hdr, \@new_objs);
		    $r = decode_rec($plugin, $rec_type, $rec);
		    $plug_srl = parse_subrec_list($rec);
		}
	    }
	    # we check plugin against all masters, as we can't know with which masters the author created it
	    # and ideally, we don't want the result of cleaning to be dependent on load order.
	    foreach my $master (keys %{my_master}) {
		if (my $lref = $MASTER_ID->{$master}->{$id}->{CELL}) {
		    my($mast_srh, $mast_rec) = @{$lref};
		    if (is_interior($srh)) {
			if ($::opt_c) { # check for redundant AMBI/WHGT
			    # CLEAN AMBI
			    $r ||= decode_rec($plugin, $rec_type, $rec);
			    unless ($cleaned_ambi) {
				if (defined($srh->{AMBI}) and ($srh->{AMBI}[0] eq $mast_srh->{AMBI}[0])) {
				    $r = remove_subrec($r, 'AMBI');
				    $cleaned_ambi++;
				}
			    }
			    # CLEAN WHGT
			    # (some plugins, like Morrowind.esm, use an INTV sub-record instead of WHGT)
			    unless ($cleaned_whgt) {
				my $plugin_whgt = (defined($srh->{WHGT}) and $srh->{WHGT}[0]) ? unpack("f", $srh->{WHGT}[0]) : undef;
				my $whgt_type = 'WHGT';
				unless (defined $plugin_whgt) {
				    $plug_srl ||= parse_subrec_list($rec);
				    if ($plug_srl->[2]->[0] eq 'INTV') {
					# this would be unusual. I think INTV water heights must be from very old Construction Sets.
					$plugin_whgt = unpack("l", $plug_srl->[2]->[1]);
					$whgt_type = 'INTV';
				    }
				}
				my $master_whgt = ($mast_srh->{WHGT}[0]) ? unpack("f", $mast_srh->{WHGT}[0]) : undef;
				unless (defined $master_whgt) {
				    my $mast_srl = parse_subrec_list($mast_rec);
				    if ($mast_srl->[2]->[0] eq 'INTV') {
					$master_whgt = unpack("l", $mast_srl->[2]->[1]);
				    }
				}
				if (defined($plugin_whgt) and defined($master_whgt) and ($plugin_whgt == $master_whgt)) {
				    $r = remove_subrec($r, $whgt_type, 1);
				    $cleaned_whgt++;
				}
			    }
			}
		    }
		    if ($::opt_j) {	# check for junkcell
			if ((scalar keys %{$srh}) < 4) {
			    # junk cells always contain less than 4 sub-records
			    my $modified = 0;
			    for my $type (keys %{$srh}) {
				if (not $JUNKCELL_SUBTYPE{$type} or
				    $srh->{$type}[0] ne $mast_srh->{$type}[0]) {
				    # record contains subrecords or some modified data, so it isn't junk
				    $modified++;
				    last;
				}
			    }
			    unless ($modified) {
				print " Cleaned Junk CELL:  $id\n";
				return;
			    }
			}
		    }
		}
	    }
	    my @what;
	    push(@what, 'AMBI') if ($cleaned_ambi);
	    push(@what, 'WHGT') if ($cleaned_whgt);
	    if (@what) {
		print " Cleaned redundant " . join(',', @what) . " from CELL: $id\n";
	    }
	} elsif ($rec_type eq 'TES3') {
	    foreach my $mast (@{$srh->{MAST}}) {
		my $master = chop_nulls($mast);
		$my_master{lc($master)}++;
		load_master($master);
	    }
	}
	if ($::opt_d) {
	    # check for duped records
	    foreach my $master (keys %{my_master}) {
		if (my $lref = $MASTER_ID->{$master}->{$id}->{$rec_type}) {
		    my($mast_srh, $mast_rec, $mast_flags) = @{$lref};
		    if ($duptype{$rec_type} and ($rec eq $mast_rec) and ($flags eq $mast_flags)) {
			print " Cleaned Duplicate $rec_type:  $id\n";
			return;
		    }
		}
	    }
	}
	$newrec = encode_rec($rec_type, $r) if ($r); # update record buffer if we have modified it
	return($newrec, $newflags);
    };
    if ($::opt_R) {
	process_plugin_for_update($plugin, $fun);
    } else {
	process_plugin_for_update($plugin, $fun, "Clean_");
    }
}

sub cmd_dump {
    my($plugin) = @_;
    print "#(Dump_Version: $DUMP_VERSION)\n";
    print "\nPlugin: $plugin\n";
    my $fun = sub {
	my($rec_type, $id, $rec, $srh, $flags, $unk) = @_;
	my $unkstr = (DBG) ? sprintf("  Unk:%04x", $unk) : '';
	my $flagstr = decode_flags($flags, \@REC_FLAGS);
	my $dial_str = ($rec_type eq 'INFO') ? " $CURRENT_DIAL" : '';
	print qq{\nRecord: $rec_type "$id"${dial_str} Flags: $flagstr${unkstr}\n};
	dumprec(decode_rec($plugin, $rec_type, $rec));
    };
    process_plugin_for_read($plugin, $fun);
}

sub cmd_recover {
    my($plugin) = @_;
    my($inp, $out) = make_temp($plugin);
    my $typlen = $REC_TYPE_LEN - 1;
    my $buff;
    my $buff_size = 4096;
    my $expected = "TES3";
    my $inp_len = sysseek($inp, 0, 2); # seek to end
    my $inp_offset = sysseek($inp, 0, 0); # seek to start
    my $rectypes = join('|', @RECTYPES);
    my %valid_type; $valid_type{$_}++ foreach (@RECTYPES);
    my %valid_subtype; $valid_subtype{$_}++ foreach (@SUBRECTYPES);
    print qq{$plugin: length = $inp_len\n};
    my @removed;
  READREC:
    while ($inp_offset < $inp_len) {
	my($rec_type, $rec, $flags, $unk);
	eval {
	    ($rec_type, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin);
	    $expected = undef;
	    die "Error, Invalid record type: $rec_type\n" unless ($valid_type{$rec_type});
	    my $srh = parse_subrec_hash($rec);
	    foreach my $subtype (keys %$srh) {
		die qq{Error, Invalid record subtype: "$subtype"\n} unless ($valid_subtype{$subtype});
	    }
	    my $id = rec_id($srh, $rec_type);
	    printf "Offset: %8d  Found: $rec_type $id\n", $inp_offset if (DBG);
	};
	if ($@) {
	    warn $@;
	    # start a scan from last input offset for something that looks like a record header
	    my $start_offset = $inp_offset;
	    print qq{READ ERROR on record starting at: $start_offset\n};
	    $inp_offset = sysseek($inp, $inp_offset + 1, 0);
	    print qq{Scanning for records from: $inp_offset\n};
	    while (1) {
		my $n_read = sysread($inp, $buff, $buff_size + $typlen);
		last READREC if ($n_read == 0); # EOF
		if (my($stuff, $rec_type) = split(/($rectypes)/, $buff)) {
		    my $new_offset = $inp_offset + length($stuff);
		    print qq{Scan found $rec_type at: $new_offset\n};
		    $inp_offset = sysseek($inp, $new_offset, 0);
		    push(@removed, [$start_offset, $new_offset]);
		    last;
		} else {
		    # Just in case record header started at end boundary, back up by len of rec ID
		    $inp_offset = sysseek($inp,  0 - $typlen, 1) if ($n_read == ($buff_size + $typlen));
		}
	    }
	} else {
	    # everything was AOK
	    write_rec($out, $rec_type, $rec, $flags, $unk);
	    $inp_offset = sysseek($inp, 0, 1); # set inp_offset to current seek position
	}
    }
    if (@removed) {
	my $n = scalar(@removed);
	print "Recovery removed $n section@{[($n > 1) ? 's' : '']} of bad data:\n";
	my $total = 0;
	foreach my $chunk (@removed) {
	    my $lost = $chunk->[1] - $chunk->[0];
	    printf "  From: %8d To: %8d  (lost %d bytes)\n",
		$chunk->[0], $chunk->[1], $lost;
	    $total += $lost;
	}
	if (scalar(@removed) > 1) {
	    print "Total bytes lost: $total\n";
	}
	fix_output($inp, $out, $plugin, 1);
    } else {
	print "Recovery found no bad data in $plugin\n";
	cleanup_temp($inp, $plugin);
    }
}

sub main {
    die $USAGE_ALL if (scalar(@ARGV) == 0);
    my $cmd_ref;
    my $cmd_name = shift(@ARGV);
    die $USAGE_ALL unless ($cmd_ref = $CMDS{$cmd_name});
    my($cmd_getopts, $cmd, $type) = @{$cmd_ref};
    $cmd_getopts->();
    my @plugins;
    foreach my $arg (@ARGV) {
	if ($arg =~ /[$GLOBCHARS]/) {
	    push(@plugins, glob($arg));
	} else {
	    push(@plugins, $arg);
	}
    }
    if ($::opt_O and not -d $::opt_O) {
	eval { mkdir($::opt_O, 0755); };
	die $@ if ($@);
    }
    if ($type eq 'm') {
	# these commands process multiple plugins at once
	$cmd->(@plugins);
    } else {		    # type eq 's'
	# these commands process a single plugin at a time
	die $USAGE_ALL if (scalar(@plugins) == 0);
	for my $plugin (@plugins) {
	    $cmd->($plugin);
	}
    }
}

main();
