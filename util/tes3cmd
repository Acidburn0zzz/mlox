#!/usr/bin/perl
$::VERSION = "0.37h";
# tes3cmd: command line tool to do various hacks on a TES3 plugin
# Copyright 2010 by John Moonsugar
# Distributed as part of the mlox project:
#   http://code.google.com/p/mlox/
# under the MIT License:
#   http://code.google.com/p/mlox/source/browse/trunk/License.txt
# Documentation:
#   http://code.google.com/p/mlox/wiki/Tes3cmd

# UPDATE/TEST: cmd_dump
# UPDATE/TEST: cmd_header
# UPDATE/TEST: cmd_esp
# UPDATE/TEST: cmd_esm
# UPDATE/TEST: cmd_recover
# UPDATE/TEST: cmd_shell
# UPDATE/TEST: cmd_overdial
# UPDATE/TEST: cmd_common
# UPDATE/TEST: cmd_diff
# UPDATE/TEST: cmd_delete
# UPDATE/TEST: cmd_modify
# UPDATE/TEST: cmd_rename
# UPDATE/TEST: cmd_clean
# UPDATE/TEST: cmd_fixit

# TBD:
# put commands and opts in a big dispatch table?
# allow commands to be abbreviated
# finish RECDEFs/codec/TOSTR/prettyprinter rewrite
# TES::File (open_for_read, backup, etc)
# implement proper verbosity
# diff: report type diffs
# cleanup .tmp if die
# rewrite "modify", "rename" commands to use the "process" subroutines?
# and add more examples, esp. "modify"
# write some tests
# clean would be sped up if command added a "clean <size>" mark to plugin (SSCR + VERSION + length + date at EOF? mark ignored?)
# GUI
# reformat overdial output? just list each topic once, with list of plugins that have it
# implement script compiler
# add new commands:
# * "undo" (revert to last backups for modifying commands)
# * "tidy" (remove cache and undo stuff)
# * "undump" (text to record, can't undump from wrong version)
# * "combine" (merge listed plugins into one plugin)
# * "conflict" (detailed report, toggle mergeable records from report)
# * "lint" (splice in tes3lint functionality)
# * "multipatch", to include:
# ** --activate switch to add it to [Game Files]
# ** generate book rotate scripts (need compiler)
# ** generate multimark scripts (need compiler)
# ** gmst/global tweaks: (timescale, fCombatAngleXY)
# ** import faces/hairs (avoid conflicts by dropping rest of object definition)
# ** merge objects (add mergeable flag to record defs)
# ** turn-off auto-calced spells.

use Carp;
use IO::Handle;
use Fcntl qw(SEEK_SET SEEK_CUR SEEK_END);
use File::Basename;
use File::Spec;
use File::Copy;
use Getopt::Long qw(:config auto_abbrev);
use Data::Dumper;
use Storable;
use Cwd;
use strict;
use warnings;

package Util;

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant DBG => scalar(grep(/^(?:-d|-?-debug)$/, @ARGV));
    use constant ASSERT => scalar(grep(/^-?-assert$/, @ARGV));
    use constant VERBOSE => (DBG or grep(/^(?:-v|-?-verbose)$/, @ARGV)); # debug turns on verbosity

    use Exporter ();
    our @ISA = qw(Exporter);
    our @EXPORT_OK = qw(err dbg prn abort);
    our %EXPORT_TAGS = ( FIELDS => [ @EXPORT_OK ] );
}

### UTILITY FUNCTIONS

sub err { warn "[@{[__PACKAGE__]}: $_[0]]\n"; }
sub dbg { err("DEBUG: $_[0]") if (DBG > 1); }
sub prn { print("@{[__PACKAGE__]}: $_[0]\n"); }
sub abort {
    my($msg) = @_;
    my $diagnosis = '';
    if ($^O =~ /^MSWin/) {
	if ($msg =~ /permission denied/i) {
	    $diagnosis =<<END
Permission errors may occur in recent versions of Windows (since Vista) due to
the UAC feature and new protected nature of "Program Files". The ideal
solution is to install Morrowind some place other than "Program Files", such
as "C:\\Games\\Morrowind". You can also try disabling UAC, although may make your
system less secure.
END
	}
    }
    die qq{FATAL ERROR: $msg$diagnosis\n"};
}


package TES3::Util;

BEGIN {
    use constant DBG => grep(/^(?:-d|-?-debug)$/, @ARGV);
    use constant ASSERT => scalar(grep(/^-?-assert$/, @ARGV));
    use constant VERBOSE => (DBG or grep(/^(?:-v|-?-verbose)$/, @ARGV)); # debug turns on verbosity
    Util->import(qw(err dbg prn abort));
}


### PACKAGE GLOBALS

our $DATADIR;	       # where "Data Files" lives.
our $TES3CMD_DIR;      # tes3cmd directory under "Data Files" (for cache, ...)

use constant RELOAD => 1;	# tell methods not to use cached data

### UTILITY FUNCTIONS

# return a dictionary of all the files found in the given directory.
# keys are lowercased for caseless file finding.
sub list_files {
    my($dir) = @_;
    my %files = ();
    if (opendir(DH, $dir)) {
	while (my $file = readdir(DH)) {
	    next if (($file eq '.') or ($file eq '..'));
	    $files{lc($file)} = $file;
	}
	closedir(DH);
    } else {
	abort(qq{Opening "$dir" ($!)});
    }
    return(\%files);
}

# sort list of files by their modification date
sub sort_by_date {
    my($dir, @files) = @_;
    my $dirlist = list_files($dir);
    my @sorted = sort { (-M "$dir/$dirlist->{lc $b}") <=> (-M "$dir/$dirlist->{lc $a}") } @files;
    dbg(qq{sorted files:} . join("\n", @sorted) . "\n") if (DBG);
    return(@sorted);
}

# assuming the program is run somewhere under the Morrowind game directory, find the
# location of the "Data Files" directory by walking up the hierarchy.
sub find_datadir {
    return($DATADIR) if (defined($DATADIR));
    my $dir = Cwd::getcwd();
    dbg("checking for data dir in: $dir") if (DBG);
    while (($dir =~ m!\bmorrowind\b!i) and (-d $dir)) {
	my $datadir = list_files($dir)->{"data files"};
	if ($datadir) {
	    $DATADIR = "$dir/$datadir";
	    err(qq{DATADIR = $DATADIR}) if (VERBOSE);
	    $TES3CMD_DIR = "$DATADIR/tes3cmd";
	    unless (-d $TES3CMD_DIR) {
		if (-e $TES3CMD_DIR) {
		    abort(qq{"$TES3CMD_DIR" exists, but is not a directory, please remove or rename it.});
		}
		mkdir($TES3CMD_DIR, 0755) or
		    abort(qq{Unable to make directory: "$TES3CMD_DIR" ($!)});
	    }
	    return($DATADIR);
	}
	my @parts = split(m![\\/]!, $dir);
	pop(@parts);
	$dir = join("/", @parts);
	dbg(qq{Checking for "Data Files" in: $dir}) if (DBG);
    }
    err(qq{Can't find "Data Files" directory, functionality reduced. Run me under "Morrowind" somewhere.});
    return(undef);		# not running under morrowind directory
}

BEGIN {
    find_datadir();
}

### TES3::Util methods

sub new {
    my($class) = @_;
    return(bless({}, $class));
}

# map of "Data Files" directory for caseless filename lookup
sub datafiles_map {
    my($self, $reload) = @_;
    return($self->{datafiles_map})
	if (defined($self->{datafiles_map} and not $reload));
    return($self->{datafiles_map} = list_files($DATADIR));
}

sub datapath { "$DATADIR/" . $_[0]->datafiles_map()->{lc($_[1])}; }
sub datafile { $_[0]->datafiles_map()->{lc($_[1])}; }

sub ini_file {
    my($self, $reload) = @_;
    return(@{$self->{ini_file}})
	if (defined($self->{ini_file} and not $reload));
    my $mwfiles = list_files("$DATADIR/..");
    return($self->{ini_file} = "$DATADIR/../$mwfiles->{'morrowind.ini'}");
}

sub load_order {
    my($self, $reload) = @_;
    return(@{$self->{load_order}})
	if (defined($self->{load_order} and not $reload));
    die "DATADIR not defined\n" unless (defined($DATADIR));
    my $ini = $self->ini_file();
    my @active;
    my $fh = IO::Handle->new();
    if (open($fh, "<$ini")) {
	dbg qq{INI is: "$ini"} if (DBG);
	while (<$fh>) {
	    if (my($plugin) = (/GameFile\d+=([^\r\n]*)/)) {
		if ($self->datafile($plugin)) {
		    dbg qq{Found Gamefile: "$plugin"} if (DBG);
		    push(@active, $plugin);
		} else {
		    dbg qq{MISSING Gamefile: "$1"} if (DBG);
		}
	    }
	}
    } else {
	err qq{Error opening "$ini" for input ($!)};
    }
    my @sorted = sort_by_date($DATADIR, @active);
    return(@{$self->{load_order} = [grep(/\.esm$/i, @sorted), grep(/\.esp$/i, @sorted)]});
}

### end of TES3::Util package

package TES3::Record;
BEGIN {
    use constant DBG => grep(/^(?:-d|-?-debug)$/, @ARGV);
    use constant ASSERT => scalar(grep(/^-?-assert$/, @ARGV));
    use constant VERBOSE => (DBG or grep(/^(?:-v|-?-verbose)$/, @ARGV)); # debug turns on verbosity
    Util->import(qw(err dbg prn abort));
}
use Data::Dumper;
use strict;

use constant { STASHBUF => 1 };

our $CODEC_VERSION = "0.2";
our $HDR_AUTH_LENGTH = 32;
our $HDR_DESC_LENGTH = 256;
our $MARGIN = "  ";
our $DIALTYPE;

### SYMBOLIC NAMES FOR FIELD VALUES

my %AIDT_FLAGS = ("weapon" => 0x00001,
		  "armor" => 0x00002,
		  "clothing" => 0x00004,
		  "books" => 0x00008,
		  "ingredient" => 0x00010,
		  "picks" => 0x00020,
		  "probes" => 0x00040,
		  "lights" => 0x00080,
		  "apparatus" => 0x00100,
		  "repair" => 0x00200,
		  "misc" => 0x00400,
		  "spells" => 0x00800,
		  "magic_items" => 0x01000,
		  "potions" => 0x02000,
		  "training" => 0x04000,
		  "spellmaking" => 0x08000,
		  "enchanting" => 0x10000,
		  "repair_item" => 0x20000);

my %APPARATUS_TYPE = (0 => "Mortar_and_Pestle",
		      1 => "Alembic",
		      2 => "Calcinator",
		      3 => "Retort");

my %ARMOR_INDEX = (0 => "Head",
		   1 => "Hair",
		   2 => "Neck",
		   3 => "Cuirass",
		   4 => "Groin",
		   5 => "Skirt",
		   6 => "Right_Hand",
		   7 => "Left_Hand",
		   8 => "Right_Wrist",
		   9 => "Left_Wrist",
		   10 => "Shield",
		   11 => "Right_Forearm",
		   12 => "Left_Forearm",
		   13 => "Right_Upper_Arm",
		   14 => "Left_Upper_Arm",
		   15 => "Right_Foot",
		   16 => "Left_Foot",
		   17 => "Right_Ankle",
		   18 => "Left_Ankle",
		   19 => "Right_Knee",
		   20 => "Left_Knee",
		   21 => "Right_Upper_Leg",
		   22 => "Left_Upper_Leg",
		   23 => "Right_Pauldron",
		   24 => "Left_Pauldron",
		   25 => "Weapon",
		   26 => "Tail");

my %ARMOR_TYPE = (0 => "Helmet",
		  1 => "Cuirass",
		  2 => "Left_Pauldron",
		  3 => "Right_Pauldron",
		  4 => "Greaves",
		  5 => "Boots",
		  6 => "Left_Gauntlet",
		  7 => "Right_Gauntlet",
		  8 => "Shield",
		  9 => "Left_Bracer",
		  10 => "Right_Bracer");

my %ATTRIBUTE = (0 => "Strength",
		 1 => "Intelligence",
		 2 => "Willpower",
		 3 => "Agility",
		 4 => "Speed",
		 5 => "Endurance",
		 6 => "Personality",
		 7 => "Luck");

my %AUTOCALC_FLAGS = ("weapon" => 0x00001,
		      "armor" => 0x00002,
		      "clothing" => 0x00004,
		      "books" => 0x00008,
		      "ingredient" => 0x00010,
		      "picks" => 0x00020,
		      "probes" => 0x00040,
		      "lights" => 0x00080,
		      "apparatus" => 0x00100,
		      "repair" => 0x00200,
		      "misc" => 0x00400,
		      "spells" => 0x00800,
		      "magic_items" => 0x01000,
		      "potions" => 0x02000,
		      "training" => 0x04000,
		      "spellmaking" => 0x08000,
		      "enchanting" => 0x10000,
		      "repair_item" => 0x20000);

my %BYDT_PART = ('0' => "Head",
		 '1' => "Hair",
		 '2' => "Neck",
		 '3' => "Chest",
		 '4' => "Groin",
		 '5' => "Hand",
		 '6' => "Wrist",
		 '7' => "Forearm",
		 '8' => "Upperarm",
		 '9' => "Foot",
		 '10' => "Ankle",
		 '11' => "Knee",
		 '12' => "Upperleg",
		 '13' => "Clavicle",
		 '14' => "Tail");

my %BYDT_FLAGS = ('0' => "None", '1' => "Female", '2' => "Playable");

my %BYDT_PTYP = ('0' => "Skin", "1" => "Clothing", "2" => "Armor");

my %CELL_FLAGS = ("has_water" => 0x02,
		  "illegal_to_sleep_here" => 0x041,
		  "behave_like_exterior" => 0x80);

my %CONTAINER_FLAGS = ("Organic" => 0x0001,
		       "Respawns,_Organic_only" => 0x0002,
		       "Default" => 0x0008);

my %CREATURE_FLAGS = ("biped" => 0x0001,
		      "respawn" => 0x0002,
		      "weapon_and_shield" => 0x0004,
		      "movement:none" => 0x0008,
		      "swims" => 0x0010,
		      "flies" => 0x0020,
		      "walks" => 0x0040,
		      "essential" => 0x0080,
		      "skeleton_blood" => 0x0400,
		      "metal_blood" => 0x0800);

my %CREA_TYPE = ( 0 => 'Creature', 1 => 'Daedra', 2 => 'Undead', 3 => 'Humanoid' );

my %CTDT_TYPE = (0 => "Pants",
		 1 => "Shoes",
		 2 => "Shirt",
		 3 => "Belt",
		 4 => "Robe",
		 5 => "Right_Glove",
		 6 => "Left_Glove",
		 7 => "Skirt",
		 8 => "Ring",
		 9 => "Amulet");

my %DIAL_TYPE = (0 => "Topic",
		 1 => "Voice",
		 2 => "Greeting",
		 3 => "Persuasion",
		 4 => "Journal");

my %ENCHANT_TYPE = (0 => "Cast_Once",
		    1 => "Cast_on_Strike",
		    2 => "Cast_when_Used",
		    3 => "Constant_Effect");

my %INFO_FUN = ('00' => "Reaction_Low",
		'01' => "Reaction_High",
		'02' => "Rank_Requirement",
		'03' => "Reputation",
		'04' => "Health_Percent",
		'05' => "PC_Reputation",
		'06' => "PC_Level",
		'07' => "PC_Health_Percent",
		'08' => "PC_Magicka",
		'09' => "PC_Fatigue",

		'10' => "PC_Strength",
		'11' => "PC_Block",
		'12' => "PC_Armorer",
		'13' => "PC_Medium_Armor",
		'14' => "PC_Heavy_Armor",
		'15' => "PC_Blunt_Weapon",
		'16' => "PC_Long_Blade",
		'17' => "PC_Axe",
		'18' => "PC_Spear",
		'19' => "PC_Athletics",

		'20' => "PC_Enchant",
		'21' => "PC_Destruction",
		'22' => "PC_Alteration",
		'23' => "PC_Illusion",
		'24' => "PC_Conjuration",
		'25' => "PC_Mysticism",
		'26' => "PC_Restoration",
		'27' => "PC_Alchemy",
		'28' => "PC_Unarmored",
		'29' => "PC_Security",

		'30' => "PC_Sneak",
		'31' => "PC_Acrobatics",
		'32' => "PC_Light_Armor",
		'33' => "PC_Short_Blade",
		'34' => "PC_Marksman",
		'35' => "PC_Mercantile",
		'36' => "PC_Speechcraft",
		'37' => "PC_Hand_To_Hand",
		'38' => "PC_Sex",
		'39' => "PC_Expelled",

		'40' => "PC_Common_Disease",
		'41' => "PC_Blight_Disease",
		'42' => "PC_Clothing_Modifier",
		'43' => "PC_Crime_Level",
		'44' => "Same_Sex",
		'45' => "Same_Race",
		'46' => "Same_Faction",
		'47' => "Faction_Rank_Difference",
		'48' => "Detected",
		'49' => "Alarmed",

		'50' => "Choice",
		'51' => "PC_Intelligence",
		'52' => "PC_Willpower",
		'53' => "PC_Agility",
		'54' => "PC_Speed",
		'55' => "PC_Endurance",
		'56' => "PC_Personality",
		'57' => "PC_Luck",
		'58' => "PC_Corprus",
		'59' => "Weather",

		'60' => "PC_Vampire",
		'61' => "Level",
		'62' => "Attacked",
		'63' => "Talked_To_PC",
		'64' => "PC_Health",
		'65' => "Creature_Target",
		'66' => "Friend_Hit",
		'67' => "Fight",
		'68' => "Hello",
		'69' => "Alarm",

		'70' => "Flee",
		'71' => "Should_Attack",
		'72' => "Werewolf",
		'73' => "Werewolf_Kills",

		'CX' => "Not_Class",
		'DX' => "Dead_Type",
		'FX' => "Not_Faction",
		'IX' => "Item_Type",
		'JX' => "Journal_Type",
		'LX' => "Not_Cell",
		'RX' => "Not_Race",
		'XX' => "Not_ID_Type",
		'fX' => "Global",
		'lX' => "PCGold",
		'sX' => "Variable_Compare",
	       );

my %INFO_SCVR_CMP =
    ('0' => '=',
     '1' => '!=',
     '2' => '>',
     '3' => '>=',
     '4' => '<',
     '5' => '<=');

my %INFO_SCVR_TYPE =
    ('0' => "Nothing",
     '1' => "Function",
     '2' => "Global",
     '3' => "Local",
     '4' => "Journal",
     '5' => "Item",
     '6' => "Dead",
     '7' => "Not_ID",
     '8' => "Not_Faction",
     '9' => "Not_Class",
     'A' => "Not_Race",
     'B' => "Not_Cell",
     'C' => "Not_Local");

my %LEVC_FLAGS = ("Calc_from_all_levels_<=_PC_level" => 1);

my %LEVI_FLAGS = ("Calc_from_all_levels_<=_PC_level" => 1,
		  "Calc_for_each_item" => 2);

my %LHDT_FLAGS = ("dynamic" => 0x0001,
		  "can_carry" => 0x0002,
		  "negative" => 0x0004,
		  "flicker" => 0x0008,
		  "fire" => 0x0010,
		  "off_default" => 0x0020,
		  "flicker_slow" => 0x0040,
		  "pulse" => 0x0080,
		  "pulse_slow" => 0x0100);

my %MGEF_FLAGS = ("spellmaking" => 0x0200,
		  "enchanting" => 0x0400,
		  "negative" => 0x0800);

my %NPC_FLAGS = ("female" => 0x0001,
		 "essential" => 0x0002,
		 "respawn" => 0x0004,
		 "autocalc" => 0x0010,
		 "blood_skel" => 0x0400,
		 "blood_metal" => 0x0800);

my %PLAYABLE = ( 0 => "Non-Playable", 1 => "Playable" );

my %RADT_FLAGS = ("playable" => 0x01,
		  "beast_race" => 0x02);

my %RANGE_TYPE = (0 => "Self", 1 => "Touch", 2 => "Target");

my %REC_FLAGS = ("deleted"     => 0x0020,
		 "persistent"  => 0x0400,
		 "ignored"     => 0x1000,
		 "blocked"     => 0x2000);
$REC_FLAGS{substr($_, 0, 1)} = $REC_FLAGS{$_} foreach (keys %REC_FLAGS);

my %SEX = (0 => "Male", 1 => "Female", 0xFF => "None");

my %SKILL = ( 0 => "Block",
	      1 => "Armorer",
	      2 => "MediumArmor",
	      3 => "HeavyArmor",
	      4 => "BluntWeapon",
	      5 => "LongBlade",
	      6 => "Axe",
	      7 => "Spear",
	      8 => "Athletics",
	      9 => "Enchant",
	      10 => "Destruction",
	      11 => "Alteration",
	      12 => "Illusion",
	      13 => "Conjuration",
	      14 => "Mysticism",
	      15 => "Restoration",
	      16 => "Alchemy",
	      17 => "Unarmored",
	      18 => "Security",
	      19 => "Sneak",
	      20 => "Acrobatics",
	      21 => "LightArmor",
	      22 => "ShortBlade",
	      23 => "Marksman",
	      24 => "Mercantile",
	      25 => "SpeechCraft",
	      26 => "HandToHand",
	      -1 => "None");

my %SPECIALIZATION = (0 => "Combat", 1 => "Magic", 2 => "Stealth");

my %SPEL_FLAGS = ("autocalc" => 0x0001,
		  "pc_start" => 0x0002,
		  "always_succeeds" => 0x0004);

my %SPEL_TYPE = (0 => "Spell",
		 1 => "Ability",
		 2 => "Blight",
		 3 => "Disease",
		 4 => "Curse",
		 5 => "Power");

my %SPELL_EFFECT = ('0' => "Water_Breathing",
		    '1' => "Swift_Swim",
		    '2' => "Water_Walking",
		    '3' => "Shield",
		    '4' => "Fire_Shield",
		    '5' => "Lightning_Shield",
		    '6' => "Frost_Shield",
		    '7' => "Burden",
		    '8' => "Feather",
		    '9' => "Jump",
		    '10' => "Levitate",
		    '11' => "Slowfall",
		    '12' => "Lock",
		    '13' => "Open",
		    '14' => "Fire_Damage",
		    '15' => "Shock_Damage",
		    '16' => "Frost_Damage",
		    '17' => "Drain_Attribute",
		    '18' => "Drain_Health",
		    '19' => "Drain_Magicka",
		    '20' => "Drain_Fatigue",
		    '21' => "Drain_Skill",
		    '22' => "Damage_Attribute",
		    '23' => "Damage_Health",
		    '24' => "Damage_Magicka",
		    '25' => "Damage_Fatigue",
		    '26' => "Damage_Skill",
		    '27' => "Poison",
		    '28' => "Weakness_to_Fire",
		    '29' => "Weakness_to_Frost",
		    '30' => "Weakness_to_Shock",
		    '31' => "Weakness_to_Magicka",
		    '32' => "Weakness_to_Common_Disease",
		    '33' => "Weakness_to_Blight_Disease",
		    '34' => "Weakness_to_Corprus_Disease",
		    '35' => "Weakness_to_Poison",
		    '36' => "Weakness_to_Normal_Weapons",
		    '37' => "Disintegrate_Weapon",
		    '38' => "Disintegrate_Armor",
		    '39' => "Invisibility",
		    '40' => "Chameleon",
		    '41' => "Light",
		    '42' => "Sanctuary",
		    '43' => "Night_Eye",
		    '44' => "Charm",
		    '45' => "Paralyze",
		    '46' => "Silence",
		    '47' => "Blind",
		    '48' => "Sound",
		    '49' => "Calm_Humanoid",
		    '50' => "Calm_Creature",
		    '51' => "Frenzy_Humanoid",
		    '52' => "Frenzy_Creature",
		    '53' => "Demoralize_Humanoid",
		    '54' => "Demoralize_Creature",
		    '55' => "Rally_Humanoid",
		    '56' => "Rally_Creature",
		    '57' => "Dispel",
		    '58' => "Soultrap",
		    '59' => "Telekinesis",
		    '60' => "Mark",
		    '61' => "Recall",
		    '62' => "Divine_Intervention",
		    '63' => "Almsivi_Intervention",
		    '64' => "Detect_Animal",
		    '65' => "Detect_Enchantment",
		    '66' => "Detect_Key",
		    '67' => "Spell_Absorption",
		    '68' => "Reflect",
		    '69' => "Cure_Common_Disease",
		    '70' => "Cure_Blight_Disease",
		    '71' => "Cure_Corprus_Disease",
		    '72' => "Cure_Poison",
		    '73' => "Cure_Paralyzation",
		    '74' => "Restore_Attribute",
		    '75' => "Restore_Health",
		    '76' => "Restore_Magicka",
		    '77' => "Restore_Fatigue",
		    '78' => "Restore_Skill",
		    '79' => "Fortify_Attribute",
		    '80' => "Fortify_Health",
		    '81' => "Fortify_Magicka",
		    '82' => "Fortify_Fatigue",
		    '83' => "Fortify_Skill",
		    '84' => "Fortify_Maximum_Magicka",
		    '85' => "Absorb_Attribute",
		    '86' => "Absorb_Health",
		    '87' => "Absorb_Magicka",
		    '88' => "Absorb_Fatigue",
		    '89' => "Absorb_Skill",
		    '90' => "Resist_Fire",
		    '91' => "Resist_Frost",
		    '92' => "Resist_Shock",
		    '93' => "Resist_Magicka",
		    '94' => "Resist_Common_Disease",
		    '95' => "Resist_Blight_Disease",
		    '96' => "Resist_Corprus_Disease",
		    '97' => "Resist_Poison",
		    '98' => "Resist_Normal_Weapons",
		    '99' => "Resist_Paralysis",
		    '100' => "Remove_Curse",
		    '101' => "Turn_Undead",
		    '102' => "Summon_Scamp",
		    '103' => "Summon_Clannfear",
		    '104' => "Summon_Daedroth",
		    '105' => "Summon_Dremora",
		    '106' => "Summon_Ancestral_Ghost",
		    '107' => "Summon_Skeltal_Minion",
		    '108' => "Summon_Bonewalker",
		    '109' => "Summon_Greater_Bonewalker",
		    '110' => "Summon_Bonelord",
		    '111' => "Summon_Winged_Twilight",
		    '112' => "Summon_Hunger",
		    '113' => "Summon_Golden_Saint",
		    '114' => "Summon_Flame_Atronach",
		    '115' => "Summon_Frost_Atronach",
		    '116' => "Summon_Storm_Atronach",
		    '117' => "Fortify_Attack",
		    '118' => "Command_Creature",
		    '119' => "Command_Humanoid",
		    '120' => "Bound_Dagger",
		    '121' => "Bound_Longsword",
		    '122' => "Bound_Mace",
		    '123' => "Bound_Battle_Axe",
		    '124' => "Bound_Spear",
		    '125' => "Bound_Longbow",
		    '126' => "EXTRA_SPELL",
		    '127' => "Bound_Cuirass",
		    '128' => "Bound_Helm",
		    '129' => "Bound_Boots",
		    '130' => "Bound_Shield",
		    '131' => "Bound_Gloves",
		    '132' => "Corprus",
		    '133' => "Vampirism",
		    '134' => "Summon_Centurion_Spider",
		    '135' => "Sun_Damage",
		    '136' => "Stunted_Magicka",
		    '137' => "Summon_Fabricant",
		    '138' => "Call_Wolf",
		    '139' => "Call_Bear",
		    '140' => "Summon_Bonewolf",
		    '141' => "sEffectSummonCreature04",
		    '142' => "sEffectSummonCreature05",
		   );

my %SPLM_TYPE = (1 => "Spell", 2 => "Enchantment");

my %TRUTH = ( 0 => "False", 1 => "True");

my %WEAPON_FLAGS = ("[ignores_normal_weapon_resistance]" => 1);

my %WEAPON_TYPE = (0 => "ShortBladeOneHand",
		   1 => "LongBladeOneHand",
		   2 => "LongBladeTwoClose",
		   3 => "BluntOneHand",
		   4 => "BluntTwoClose",
		   5 => "BluntTwoWide",
		   6 => "SpearTwoWide",
		   7 => "AxeOneHand",
		   8 => "AxeTwoHand",
		   9 => "MarksmanBow",
		   10 => "MarksmanCrossbow",
		   11 => "MarksmanThrown",
		   12 => "Arrow",
		   13 => "Bolt");

my %YESNO = ( 0 => "No", 1 => "Yes");

### RECORD DEFINITIONS

sub unpack_float_array {
    my($self, $buff) = @_;
    my $i = 1;
    $self->{$i++} = $_ foreach (unpack("f*", $buff));
    $self->{_last_idx} = $i - 1;
    $self;
}
sub pack_float_array { pack("f*", map { $_[0]->{$_} } sort { $a <=> $b } grep { !/^_/ } keys %{$_[0]}); }
my @RD_float_array = ([], { decode => \&unpack_float_array, encode => \&pack_float_array,
			    tostr => sub {
				my($self) = @_;
				"Float_Vals: " . join(", ", map { sprintf("%0.2f", $self->{$_}) } 1..$self->{_last_idx});
			    }});

sub unpack_long_array {
    my($self, $buff) = @_;
    my $i = 1;
    $self->{$i++} = $_ foreach (unpack("l*", $buff));
    $self->{_last_idx} = $i - 1;
    $self;
}
sub pack_long_array { pack("l*", map { $_[0]->{$_} } sort { $a <=> $b } grep { !/^_/ } keys %{$_[0]}); }
my @RD_long_array  = ([], { decode => \&unpack_long_array,  encode => \&pack_long_array,
			    tostr => sub {
				my($self) = @_;
				"Long_Vals: " . join(", ", map { $self->{$_} } 1..$self->{_last_idx});
			    }});

sub unpack_short_array {
    my($self, $buff) = @_;
    my $i = 1;
    $self->{$i++} = $_ foreach (unpack("s*", $buff));
    $self->{_last_idx} = $i - 1;
    $self;
}
sub pack_short_array { pack("s*", map { $_[0]->{$_} } sort { $a <=> $b } grep { !/^_/ } keys %{$_[0]}); }
my @RD_short_array = ([], { decode => \&unpack_short_array, encode => \&pack_short_array,
			    tostr => sub {
				my($self) = @_;
				"Short_Vals: " . join(", ", map { $self->{$_} } 1..$self->{_last_idx});
			    }});

my @RD_widx = ([["Equipped_Index", "l"], # JMS index into NPCO inventory items of those that are equipped
		["Ammo_Flag", "l"]],
	       { tostr => sub {
		     my($self) = @_;
		     sprintf("Equipped_Index:%d%s", $self->{equipped_index},
			     ($self->{ammo_flag} == 0) ? "" : " (Ammo)");
		 },
	       });

my $RD_Actor_Data =
#     Field                              Offset
    [(["Unknown_1", "L"],	       #   0
      ["Unknown_1", "L"],	       #   4
      ["Unknown_1", "L"],	       #   8
      ["Unknown_1", "L"],	       #  12
      ["Unknown_1", "L"],	       #  16
      ["Unknown_1", "L"],	       #  20
      ["Unknown_1", "L"],	       #  24
      ["Unknown_1", "L"],	       #  28
      ["Unknown_1", "L"],	       #  32
      ["Unknown_1", "L"],	       #  36
      ["Health", "f"],		       #  40
      ["Max_Health", "f"],	       #  44
      ["Fatigue", "f"],		       #  48
      ["Max_Fatigue", "f"],	       #  52
      ["Unknown_1", "f"],	       #  56
      ["Unknown_1", "f"],	       #  60
      ["Unknown_1", "f"],	       #  64
      ["Unknown_1", "f"],	       #  68
      ["Unknown_1", "f"],	       #  72
      ["Encumbrance", "f"],	       #  76
      ["STR", "f"],		       #  80
      ["STR_Base", "f"],	       #  84
      ["INT", "f"],		       #  88
      ["INT_Base", "f"],	       #  92
      ["WIL", "f"],		       #  96
      ["WIL_Base", "f"],	       # 100
      ["AGI", "f"],		       # 104
      ["AGI_Base", "f"],	       # 108
      ["SPD", "f"],		       # 112
      ["SPD_Base", "f"],	       # 116
      ["END", "f"],		       # 120
      ["END_Base", "f"],	       # 124
      ["PER", "f"],		       # 128
      ["PER_Base", "f"],	       # 132
      ["LUC", "f"],		       # 136
      ["LUC_Base", "f"],	       # 140
      ["Fortify_Attack", "L"],	       # 144
      ["Sanctuary", "L"],	       # 148
      ["Resist_Magicka", "C"],	       # 152
      ["Unknown_1", "a3"],
      ["Resist_Fire", "C"],	# 156 (+ Fire Shield)
      ["Unknown_1", "a3"],
      ["Resist_Frost", "C"],	# 160 (+ Frost Shield)
      ["Unknown_1", "a3"],
      ["Resist_Shock", "C"],	# 164 (+ Lightning Shield)
      ["Unknown_1", "a3"],
      ["Resist_Common_Disease", "L"],		   # 168
      ["Unknown_1", "L"],			   # 172
      ["Unknown_1", "L"],			   # 176
      ["Resist_Poison", "L"],			   # 180
      ["Resist_Paralysis", "L"],		   # 184
      ["Chameleon", "L"],			   # 188
      ["Resist_Normal_Weapons", "L"],		   # 192
      ["Water_Breathing", "L"],			   # 196
      ["Water_Walking", "L"],			   # 200
      ["Swift_Swim", "L"],			   # 204
      ["Unknown_1", "L"],			   # 208
      ["Levitate", "L"],			   # 212
      ["Shield", "L"],				   # 216
      ["Unknown_1", "L"],			   # 220
      ["Unknown_1", "L"],			   # 224
      ["Blind", "L"],				   # 228
      ["Unknown_1", "L"],			   # 232
      ["Invisibility", "L"],			   # 236
      ["Unknown_1", "L"],			   # 240
      ["Unknown_1", "L"],			   # 244
      ["Unknown_1", "L"],			   # 248
      ["Unknown_1", "L"],			   # 252
      ["Unknown_1", "L"],			   # 256
      ["Unknown_1", "L"])];

my @RD_Enchantment =
    ([["Spell_Effect", "S"], ["Skill", "c"], ["Attribute", "C"], ["Range", "L"],
      ["Area", "L"], ["Duration", "L"], ["Mag_Min", "L"], ["Mag_Max", "L"]],
     { tostr => sub {
	   my($self) = @_;
	   my $spell = $SPELL_EFFECT{$self->{spell_effect}};
	   if ($spell =~ /_attribute$/i) {
	       $spell .= "/$ATTRIBUTE{$self->{attribute}}";
	   } elsif ($spell =~ /_skill$/i) {
	       $spell .= "/$SKILL{$self->{skill}}";
	   }
	   sprintf "%s  Range:%s  Area:%d  Duration:%d  Mag_Min:%d  Mag_Max:%d",
	       $spell, $RANGE_TYPE{$self->{range}}, $self->{area}, $self->{duration}, $self->{mag_min}, $self->{mag_max} },
     });

my $RD_Unknown = [["Unknown_1", "H*"]];

my @RECDEFS =
    (
     [ACTI => [
	       [NAME => [["ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [ALCH => [
	       [NAME => [["ID", "Z*"]]],
	       [ALDT => [["Weight", "f"], ["Value", "L"], ["Autocalc", "L"]],
		{ flags => [qw(mergeable)] }],
	       [ENAM => @RD_Enchantment],
	       [FNAM => [["Name", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	       [TEXT => [["Icon", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [APPA => [
	       [NAME => [["ID", "Z*"]]],
	       [AADT => [["Type", "L", { lookup => \%APPARATUS_TYPE }],
			 ["Quality", "f"], ["Weight", "f"], ["Value", "L"]],
		{ flags => [qw(mergeable)] }],
	       [FNAM => [["Name", "Z*"]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [ARMO => [
	       [NAME => [["ID", "Z*"]]],
	       [AODT => [["Type", "L", { lookup => \%ARMOR_TYPE }], ["Weight", "f"], ["Value", "L"], ["Health", "L"],
			 ["Enchant_Points", "L"], ["Armor_Rating", "L"]], { flags => [qw(mergeable)] }],
	       [BNAM => [["Male_Body_ID", ["Z*", "a*"]]]],
	       [CNAM => [["Female_Body_ID", "a*"]]],
	       [ENAM => [["Enchantment", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [INDX => [["Part_Index", "C", { lookup => \%ARMOR_INDEX }]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [BODY => [
	       [NAME => [["ID", "Z*"]]],
	       [BYDT => [["Body_Part", "C", { lookup => \%BYDT_PART }], ["Vampire", "C"],
			 ["Flags", "C", { symflag => \%BYDT_FLAGS }], ["Part_Type", "C", { lookup => \%BYDT_PTYP }]]],
	       [FNAM => [["Name", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [BOOK => [
	       [NAME => [["ID", "Z*"]]],
	       [BKDT => [["Weight", "f"], ["Value", "L"], ["Scroll", "L", { lookup => \%YESNO }],
			 ["Skill", "l"], ["Enchant_Points", "L"]], { flags => [qw(mergeable)] }],
	       [ENAM => [["Enchantment", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	       [TEXT => [["Text", "a*"]],
		{ tostr => sub {
		      my $str = $_[0]->{text};
		      $str =~ tr/\r//d if ($^O eq 'linux');
		      "Text:$str";
		  },
		}],
	      ], { flags => [qw(mergeable)] }],
     [BSGN => [
	       [NAME => [["ID", "Z*"]]],
	       [DESC => [["Description", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [NPCS => [["Spell", ["Z32", "a32"]]]],
	       [TNAM => [["Image", "Z*"]]]
	      ], { flags => [qw(mergeable)] }],
     [CELL => [
	       [
		[AMBI => [["Ambient_Color", "L:0x%08x"], ["Sunlight_Color", "L:0x%08x"], ["Fog_Color", "L:0x%08x"], ["Fog_Density", "f"]]],
	       ],
	       [
		[FRMR => [["ObjIdx", "S"], ["Unknown", "C"], ["ModIdx", "C"]]],
	       ],
	       [ACDT => $RD_Actor_Data],
	       [ACSC => $RD_Unknown],
	       [ACSL => $RD_Unknown],
	       [ACTN => $RD_Unknown],
	       [ANAM => $RD_Unknown],
	       [ANIS => $RD_Unknown],
	       [APUD => $RD_Unknown],
	       [BNAM => $RD_Unknown],
	       [CHRD => $RD_Unknown],
	       [CNAM => $RD_Unknown],
	       [CNDT => $RD_Unknown],
	       [CRED => $RD_Unknown],
	       [CSHN => $RD_Unknown],
	       [CSTN => [["Target", "Z*"]]], # guessing this is: "Cast/Current Spell Target Name"
	       [DATA => [],
		{
		 decode => sub {
		     my($self, $buff) = @_;
		     if (length($buff) == 24) {
			 ($self->{x}, $self->{y}, $self->{z},
			  $self->{x_angle}, $self->{y_angle}, $self->{z_angle}) = unpack("f6", $buff);
		     } elsif (length($buff) == 12) {
			 my($flags, $unk, $fog) = unpack("LLf", $buff);
			 if ($flags & 0x01) { # Interior
			     $self->{_parent_}->{_is_interior_} = 1;
			     $self->{flags} = $flags;
			     $self->{unknown} = $unk;
			     $self->{fog_density} = $fog;
			 } else { # Exterior
			     $self->{_parent_}->{_is_interior_} = 0;
			     $self->{flags} = $flags;
			     ($self->{x}, $self->{y}) = unpack("x[L]ll", $buff);
			 }
		     } else {
			 $self->bad_length(length($buff));
		     }
		     return($self);
		 },
		 encode => sub {
		     my($self) = @_;
		     if (exists $self->{flags}) {
			 if ($self->{flags} & 0x01) { # Interior
			     return(pack("LLf", $self->{flags}, $self->{unknown}, $self->{fog_density}));
			 } else { # Exterior
			     return(pack("Lll", $self->{flags}, $self->{x}, $self->{y}));
			 }
		     } else {
			 return(pack("f6", $self->{x}, $self->{y}, $self->{z},
				     $self->{x_angle}, $self->{y_angle}, $self->{z_angle}));
		     }
		 },
		 tostr => sub {
		     my($self) = @_;
		     if (exists $self->{flags}) {
			 if ($self->{flags} & 0x01) { # Interior
			     # we don't print $self->{unknown} as it is really unused
			     sprintf("(Interior) Fog_Density:%0.2f  Flags:%s",
				    $self->{fog_density}, decode_flags($self->{flags}, \%CELL_FLAGS));
			 } else {
			     sprintf("(Exterior) Coordinates: (%d, %d)  Flags:%s",
				    $self->{x}, $self->{y}, decode_flags($self->{flags}, \%CELL_FLAGS));
			 }
		     } else {
			 sprintf("X:%0.2f  Y:%0.2f  Z:%0.2f  X_Angle:%0.2f  Y_Angle:%0.2f  Z_Angle:%0.2f",
				 $self->{x}, $self->{y}, $self->{z}, $self->{x_angle}, $self->{y_angle}, $self->{z_angle});
		     }
		 },
		}],
	       [DNAM => [["Door_ID", "Z*"]]],
	       [DODT => [["X", "f"], ["Y", "f"], ["Z", "f"], ["Angle_X", "f"], ["Angle_Y", "f"], ["Angle_Z", "f"]]],
	       [FGTN => $RD_Unknown],
	       [FLTV => [["Unknown_1", "f"]]],
	       [INDX => $RD_Unknown],
	       [INTV => $RD_Unknown],
	       [KNAM => $RD_Unknown],
	       [LSHN => $RD_Unknown],
	       [LSTN => $RD_Unknown],
	       [LVCR => $RD_Unknown],
	       [MNAM => $RD_Unknown],
	       [MVRF => [["Moved_Ref", "L"]]], # .ess
	       [NAM0 => [["Object_Count", "L"]]],
	       [NAM5 => [["Red", "C"], ["Green", "C"], ["Blue", "C"], ["Unused", "C"]]], # Map Color
	       [NAM8 => $RD_Unknown],
	       [NAM9 => [["Owner", "L"]]],
	       [NAME => [["Name", "Z*"]]],
	       [ND3D => $RD_Unknown],
	       [PRDT => $RD_Unknown],
	       [PWPC => $RD_Unknown],
	       [PWPS => $RD_Unknown],
	       [RGNN => [["Region", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	       [SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]]],
	       [SLFD => @RD_float_array],
	       [SLLD => @RD_long_array],
	       [SLSD => @RD_short_array],
	       [STPR => $RD_Unknown],
	       [TGTN => $RD_Unknown],
	       [TNAM => $RD_Unknown],
	       [UNAM => $RD_Unknown],
	       [WHGT => $RD_Unknown],
	       [WNAM => $RD_Unknown],
	       [XCHG => [["Enchant_Charge", "L"]]],
	       [XNAM => $RD_Unknown],
	       [XSCL => [["Scale", "f"]]],
	       [XSOL => [["Soul", "Z*"]]],
	       [YNAM => $RD_Unknown],
	       [ZNAM => $RD_Unknown],
	      ], { id => sub {
		       my($self) = @_;
		       return($self->{_id_}) if ($self->{_id_});
		       my $name = $self->get_type('NAME','name');
		       return($name) if ($self->is_interior());
		       $name = $self->get_type('RGNN','region') unless ($name);
		       $name ||= 'Wilderness';
		       my $x = $self->get_type('DATA', 'x');
		       my $y = $self->get_type('DATA', 'y');
		       return("$name ($x, $y)");
		   },
		   is_interior => sub {
		       my($self) = @_;
		       return($self->{_is_interior_}) if (defined($self->{_is_interior_}));
		       return($self->{_is_interior_} = ($self->get_type('DATA', 'flags') & 0x01));
		   }
		 }],
     [CLAS => [
	       [NAME => [["ID", "Z*"]]],
	       [CLDT => [["Primary_Attribute", "L", { lookup => \%ATTRIBUTE }],
			 ["Secondary_Attribute", "L", { lookup => \%ATTRIBUTE }],
			 ["Specialization", "L", { lookup => \%SPECIALIZATION }],
			 ["Minor_Skill_1", "l", { lookup => \%SKILL }], ["Major_Skill_1", "l", { lookup => \%SKILL }],
			 ["Minor_Skill_1", "l", { lookup => \%SKILL }], ["Major_Skill_1", "l", { lookup => \%SKILL }],
			 ["Minor_Skill_1", "l", { lookup => \%SKILL }], ["Major_Skill_1", "l", { lookup => \%SKILL }],
			 ["Minor_Skill_1", "l", { lookup => \%SKILL }], ["Major_Skill_1", "l", { lookup => \%SKILL }],
			 ["Minor_Skill_1", "l", { lookup => \%SKILL }], ["Major_Skill_1", "l", { lookup => \%SKILL }],
			 ["Flags", "L", { lookup => \%PLAYABLE }], ["AutoCalc", "L", { symflags => \%AUTOCALC_FLAGS }]]],
	       [DESC => [["Description", "a*"]],
		{ tostr => sub {
		      my $str = $_[0]->{description};
		      $str =~ tr/\r//d if ($^O eq 'linux');
		      "Description:$str";
		  },
		}],
	       [FNAM => [["Name", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [CLOT => [
	       [NAME => [["ID", "Z*"]]],
	       [BNAM => [["Male_Body_ID", "a*"]]],
	       [CNAM => [["Female_Body_ID", ["Z*", "a*"]]]],
	       [CTDT => [["Type", "L", { lookup => \%CTDT_TYPE }], ["Weight", "f"],
			 ["Value", "S"], ["Enchant_Points", "S"]], { flags => [qw(mergeable)] }],
	       [ENAM => [["Enchantment_ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [INDX => [["Index", "C"]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [CNTC => [
	       [NAME => [["ID", "Z*"]]],
	       [INDX => [["Index", "L"]]],
	       [NPCO => [["Count", "l"], ["Name", ["Z32", "a32"]]]],
	       [SCRI => [["Script", "Z*"]]],
	       [SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]]],
	       [SLFD => @RD_float_array],
	       [SLLD => @RD_long_array],
	       [SLSD => @RD_short_array],
	       [XCHG => [["Enchant_Charge", "L"]]],
	       [XHLT => [["Health", "L"]]],
	       [XIDX => [["Scripted_Item_Index", "L"]]],
	       [XSOL => [["Soul", "Z*"]]],
	      ]],
     [CONT => [
	       [NAME => [["ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [CNDT => [["Weight", "f"]]],
	       [FLAG => [["Container_Flags", "L", { symflags => \%CONTAINER_FLAGS }]]],
	       [INDX => [["Unknown_1", "L"]]], # .ess
	       [MODL => [["Model", "Z*"]]],
	       [NPCO => [["Count", "l"], ["Name", ["Z32", "a32"]]]],
	       [SCRI => [["Script", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [CREA => [
	       [NAME => [["ID", "Z*"]]],
	       [AIDT => [["Hello", "C"], ["Unknown_1", "C"], ["Fight", "C"], ["Flee", "C"],
			 ["Alarm", "C"], ["Unknown_1", "H6"], ["Flags", "L", { symflags => \%AIDT_FLAGS }]],
		{ flags => [qw(mergeable)] }],
	       [AI_E => $RD_Unknown],
	       [AI_F => $RD_Unknown],
	       [AI_T => $RD_Unknown],
	       [AI_W => [["Distance", "S"], ["Duration", "C"], ["Time_of_day", "C"],
			 ["Idle_1", "C"], ["Idle_1", "C"], ["Idle_1", "C"], ["Idle_1", "C"], ["Idle_1", "C"],
			 ["Idle_1", "C"], ["Idle_1", "C"], ["Idle_1", "C"], ["Idle_1", "C"], ["Idle_1", "C"]]],
	       [CNAM => $RD_Unknown],
	       [DNAM => $RD_Unknown],
	       [DODT => [["X", "f"], ["Y", "f"], ["Z", "f"], ["Angle_X", "f"], ["Angle_Y", "f"], ["Angle_Z", "f"]]],
	       [FLAG => [["Flags", "L", { symflags => \%CREATURE_FLAGS }]]],
	       [FNAM => [["Name", "Z*"]]],
	       [INDX => $RD_Unknown],
	       [MODL => [["Model", "Z*"]]],
	       [NPCO => [["Count", "l"], ["Name", ["Z*", "a32"]]]],
	       [NPCS => $RD_Unknown],
	       [NPDT => [["Type", "L", { lookup => \%CREA_TYPE }], ["Lev", "L"], ["Str", "L"], ["Int", "L"], ["Wil", "L"],
			 ["Agi", "L"], ["Spd", "L"], ["End", "L"], ["Per", "L"], ["Lck", "L"],
			 ["Health", "L"], ["Spell_Points", "L"], ["Fatigue", "L"], ["Soul", "L"],
			 ["Combat", "L"], ["Magic", "L"], ["Stealth", "L"], ["Attack_1_Min", "L"],
			 ["Attack_1_Max", "L"], ["Attack_2_Min", "L"], ["Attack_2_Max", "L"],
			 ["Attack_3_Min", "L"], ["Attack_3_Max", "L"], ["Gold", "L"]], { flags => [qw(mergeable)] }],
	       [SCRI => [["Script", "Z*"]]],
	       [XSCL => [["Scale", "f"]]],
	      ], { flags => [qw(mergeable)] }],
     [CREC => [
	       [NAME => [["ID", "Z*"]]],
	       [AI_F => $RD_Unknown],
	       [AI_T => $RD_Unknown],
	       [AI_W => $RD_Unknown],
	       [INDX => $RD_Unknown],
	       [NPCO => [["Count", "l"], ["Name", ["Z*", "a32"]]]],
	       [SCRI => [["Script", "Z*"]]],
	       [SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]]],
	       [SLFD => @RD_float_array],
	       [SLLD => @RD_long_array],
	       [SLSD => @RD_short_array],
	       [WIDX => @RD_widx],
	       [XCHG => [["Enchant_Charge", "L"]]],
	       [XHLT => [["Health", "L"]]],
	       [XIDX => $RD_Unknown],
	       [XSCL => [["Scale", "f"]]],
	      ]],
     [DIAL => [
	       [NAME => [["ID", "Z*"]]],
	       [DATA => [["Type", "C"]],
		{
		 tostr => sub {
		      my($self) = @_;
		      $DIALTYPE = $DIAL_TYPE{$self->{type}};
		}}],
	       [XIDX => $RD_Unknown],
	      ]],
     [DOOR => [
	       [NAME => [["ID", "Z*"]]],
	       [ANAM => [["Door_Close_Sound", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	       [SNAM => [["Door_Open_Sound", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [ENCH => [
	       [NAME => [["ID", "Z*"]]],
	       [ENAM => @RD_Enchantment],
	       [ENDT => [["Type", "L", { lookup => \%ENCHANT_TYPE }], ["Cost", "L"], ["Charge", "L"], ["Autocalc", "L"]]],
	      ], { flags => [qw(mergeable)] }],
     [FACT => [
	       [NAME => [["ID", "Z*"]]],
	       [ANAM => [["Contra_Faction", "a*"]]],
	       [FADT => [["Primary_Attribute", "L", { lookup => \%ATTRIBUTE}], ["Secondary_Attribute", "L", { lookup => \%ATTRIBUTE}],
			 ["At1_1", "L"], ["At2_1", "L"], ["Sk1_1", "L"], ["Sk2_1", "L"], ["Fact_1", "L"],
			 ["At1_1", "L"], ["At2_1", "L"], ["Sk1_1", "L"], ["Sk2_1", "L"], ["Fact_1", "L"],
			 ["At1_1", "L"], ["At2_1", "L"], ["Sk1_1", "L"], ["Sk2_1", "L"], ["Fact_1", "L"],
			 ["At1_1", "L"], ["At2_1", "L"], ["Sk1_1", "L"], ["Sk2_1", "L"], ["Fact_1", "L"],
			 ["At1_1", "L"], ["At2_1", "L"], ["Sk1_1", "L"], ["Sk2_1", "L"], ["Fact_1", "L"],
			 ["At1_1", "L"], ["At2_1", "L"], ["Sk1_1", "L"], ["Sk2_1", "L"], ["Fact_1", "L"],
			 ["At1_1", "L"], ["At2_1", "L"], ["Sk1_1", "L"], ["Sk2_1", "L"], ["Fact_1", "L"],
			 ["At1_1", "L"], ["At2_1", "L"], ["Sk1_1", "L"], ["Sk2_1", "L"], ["Fact_1", "L"],
			 ["At1_1", "L"], ["At2_1", "L"], ["Sk1_1", "L"], ["Sk2_1", "L"], ["Fact_1", "L"],
			 ["At1_1", "L"], ["At2_1", "L"], ["Sk1_1", "L"], ["Sk2_1", "L"], ["Fact_1", "L"],
			 ["Sk_1", "L"], ["Sk_1", "L"], ["Sk_1", "L"], ["Sk_1", "L"], ["Sk_1", "L"], ["Sk_1", "L"],
			 ["Unknown_1", "l"], ["Flags", "L"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [INTV => [["Contra_Faction_Factor", "l"]]],
	       [RNAM => [["Rank", ["Z32", "a32"]]]],
	      ], { flags => [qw(mergeable)] }],
     [FMAP => [			# ess, single record, no id needed
	       [MAPD => $RD_Unknown],
	       [MAPH => $RD_Unknown],
	      ]],
     [GAME => [			# ess, single record, no id needed
	       [GMDT => [["Current_Cell", "Z*"], ["Unknown", "H*"]]], # there is junk following the cell name ... not clear if there's a max cell name size?
	      ]],
     [GLOB => [
	       [NAME => [["ID", "Z*"]]],
	       [FLTV => [["Float", "f"]]],
	       [FNAM => [["Type", "a"]]],
	      ]],
     [GMST => [
	       [NAME => [["ID", ["Z*", "a*"]]]],
	       [FLTV => [["Float", "f"]]],
	       [INTV => [["Integer", "l"]]],
	       [STRV => [["String", "a*"]],
		{ tostr => sub {
		      my $str = $_[0]->{string};
		      $str =~ tr/\r//d if ($^O eq 'linux');
		      "String:$str";
		  },
		}],
	      ]],
     [INFO => [
	       [INAM => [["ID", "Z*"]]],
	       [ACDT => [["Actor_Data", "Z*"]]], # .ess
	       [ANAM => [["Cell", "Z*"]]],
	       [BNAM => [["Result", "a*"]],
		{ tostr => sub {
		      my($self) = @_;
		      my $str = $self->{result};
		      $str =~ tr/\r//d if ($^O eq 'linux');
		      $str =~ s/\n/\n\t\t/g;
		      "Result:\t$str";
		  },
		}],
	       [CNAM => [["Class", "Z*"]]],
	       [DATA => [["Unknown_1", "L"], ["Disposition", "L"], ["Rank", "C"],
			 ["Sex", "C"], ["PC_Rank", "C"], ["Unknown_1", "C"]],
		{ tostr => sub {
		      my($self) = @_;
		      if ($DIALTYPE =~ /Journal/i) {
			  sprintf("JournalIndex:%s", $self->{disposition});
		      } else {
			  sprintf("Disposition:%s  Rank:%s  Sex:%s  PC_Rank:%s",
				  $self->{disposition},
				  ($self->{rank} == 255) ? "None" : $self->{rank},
				  $SEX{$self->{sex}},
				  ($self->{pc_rank} == 255) ? "None" : $self->{pc_rank});
		      }
		  }
		}],
	       [DNAM => [["PC_Faction", "Z*"]]],
	       [FLTV => [["Result_Value", "f"]]],
	       [FNAM => [["Faction", "Z*"]]],
	       [INTV => [["Compare_Value", "L"]]],
	       [NAME => [["Response", "a*"]],
		{ tostr => sub {
		      my($self) = @_;
		      my $str = $self->{response};
		      $str =~ tr/\r//d if ($^O eq 'linux');
		      $str =~ s/\n/\n\t\t/g;
		      "Response:\t$str";
		  },
		}],
	       [NNAM => [["Next_ID", "Z*"]]],
	       [ONAM => [["Actor", "Z*"]]],
	       [PNAM => [["Prev_ID", "Z*"]]],
	       [QSTF => [["Quest_Finished", "C:"]]],
	       [QSTN => [["Quest_Name", "C:"]]],
	       [QSTR => [["Quest_Restart", "C:"]]],
	       [RNAM => [["Race", "Z*"]]],
	       [SCVR => [["Index", "a"],
			 ["Type", "a", { lookup => \%INFO_SCVR_TYPE}],
			 ["Function", "a2", { lookup => \%INFO_FUN }],
			 ["Comparison", "a", { lookup => \%INFO_SCVR_CMP }],
			 ["Name", "a*"]]],
	       [SNAM => [["Sound_File", "Z*"]]],
	      ]],
     [INGR => [
	       [NAME => [["ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [IRDT => [["Weight", "f"], ["Value", "L"],
			 ["Effect_1", "l"], ["Effect_1", "l"], ["Effect_1", "l"], ["Effect_1", "l"],
			 ["Skill_1", "l"], ["Skill_1", "l"], ["Skill_1", "l"], ["Skill_1", "l"],
			 ["Attribute_1", "l"], ["Attribute_1", "l"], ["Attribute_1", "l"], ["Attribute_1", "l"],
			],
	       { tostr => sub {
		     my($self) = @_;
		     my @effects;
		     foreach my $i (1..4) {
			 if ($self->{"effect_$i"} != -1) {
			     my $eix = $self->{"effect_$i"};
			     my $effect = $SPELL_EFFECT{$eix} || "${eix}???";
			     if ($effect =~ /_attribute$/i) {
				 push(@effects, qq{$effect/$ATTRIBUTE{$self->{"attribute_$i"}}});
			     } elsif ($effect =~ /_skill$/i) {
				 push(@effects, qq{$effect/$SKILL{$self->{"skill_$i"}}});
			     } else {
				 push(@effects, $effect);
			     }
			 }
		     }
		     sprintf("Weight:%0.2f  Value:%d  Effects:%s",
			 $self->{weight}, $self->{value}, join(",", @effects));
		 }}],
	       [ITEX => [["Icon", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [JOUR => [
	       [NAME => [["ID", "Z*"]]],
	      ]],
     [KLST => [
	       [
		[KNAM => [["ID", "Z*"]]],
		[CNAM => [["Dead_Count", "L"]]],
		[INTV => [["End_of_List", "L"]]],
	       ]
	      ]],
     [LAND => [
	       [INTV => [["X", "l"], ["Y", "l"]]],
	       [DATA => $RD_Unknown],
	       [VCLR => $RD_Unknown],
	       [VHGT => $RD_Unknown],
	       [VNML => $RD_Unknown],
	       [VTEX => $RD_Unknown],
	       [WNAM => $RD_Unknown],
	      ], { id => sub {
		       my($self) = @_;
		       return($self->{_id_}) if ($self->{_id_});
		       my $x = $self->get_type('INTV', 'x');
		       my $y = $self->get_type('INTV', 'y');
		       return($self->{_id_} = "($x, $y") if (defined($x) and defined($y));
		       err "Bad LAND id: missing INTV";
		       if (ASSERT) {
			   err Dumper($self);
		       }
		   }
		 }],
     [LEVC => [
	       [NAME => [["ID", "Z*"]]],
	       [DATA => [["List_Flags", "L", { symflags => \%LEVC_FLAGS }]]],
	       [INDX => [["Item_Count", "L"]]],
	       [NNAM => [["Chance_None", "C"]]],
	       [
		[CNAM => [["Creature_ID", "Z*"]]],
		[INTV => [["Level", "S"]]],
	       ],
	      ]],
     [LEVI => [
	       [NAME => [["ID", "Z*"]]],
	       [DATA => [["List_Flags", "L", { symflags => \%LEVI_FLAGS }]]],
	       [INDX => [["Item_Count", "L"]]],
	       [NNAM => [["Chance_None", "C"]]],
	       [
		[INAM => [["Item_ID", "Z*"]]],
		[INTV => [["Level", "S"]]],
	       ],
	      ]],
     [LIGH => [
	       [NAME => [["ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [LHDT => [["Weight", "f"], ["Value", "L"], ["Time", "L"], ["Radius", "L"],
			 ["Red", "C"], ["Green", "C"], ["Blue", "C"],
			 ["Unknown_1", "C"], ["Flags", "L", { symflags => \%LHDT_FLAGS }]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	       [SNAM => [["Sound_ID", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [LOCK => [
	       [NAME => [["ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [LKDT => [["Weight", "f"], ["Value", "L"], ["Quality", "f"], ["Uses", "L"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [LTEX => [
	       [NAME => [["ID", "Z*"]]],
	       [DATA => [["Texture_Path", "Z*"]]],
	       [INTV => [["Unknown_1", "L"]]],
	      ]],
     [MGEF => [
	       [INDX => [["ID", "L"]]],
	       [ASND => [["Area_Sound", "Z*"]]],
	       [AVFX => [["Area_VFX", "Z*"]]],
	       [BSND => [["Bolt_Sound", "Z*"]]],
	       [BVFX => [["Bolt_VFX", "Z*"]]],
	       [CSND => [["Cast_Sound", "Z*"]]],
	       [CVFX => [["Cast_VFX", "Z*"]]],
	       [DESC => [["Description", "a*"]],
		{ tostr => sub {
		      my $str = $_[0]->{description};
		      $str =~ tr/\r//d if ($^O eq 'linux');
		      "Description:$str";
		  },
		}],
	       [HSND => [["Hit_Sound", "Z*"]]],
	       [HVFX => [["Hit_VFX", "Z*"]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [MEDT => [["School", "L"], ["Base_Cost", "f"],["Flags", "L", { symflags => \%MGEF_FLAGS }],
			 ["Red", "L"], ["Green", "L"], ["Blue", "L"],
			 ["Speed", "f"], ["Size", "f"], ["SizeCap", "f"]]],
	       [PTEX => [["Particle_Texture", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [MISC => [
	       [NAME => [["ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [MCDT => [["Weight", "f"], ["Value", "L"], ["Unknown_1", "L"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [NPCC => [
	       [NAME => [["ID", "Z*"]]],
	       [AI_E => $RD_Unknown],
	       [AI_F => $RD_Unknown],
	       [AI_T => $RD_Unknown],
	       [AI_W => $RD_Unknown],
	       [NPCO => [["Count", "l"], ["Name", ["Z*", "a32"]]]],
	       [NPDT => $RD_Unknown],
	       [SCRI => [["Script", "Z*"]]],
	       [SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]]],
	       [SLFD => @RD_float_array],
	       [SLLD => @RD_long_array],
	       [SLSD => @RD_short_array],
	       [WIDX => @RD_widx],
	       [XCHG => [["Enchant_Charge", "L"]]],
	       [XHLT => [["Health", "L"]]],
	       [XIDX => $RD_Unknown],
	       [XSOL => [["Soul", "Z*"]]],
	      ]],
     [NPC_ => [
	       [NAME => [["ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [AIDT => [["Hello", "C"], ["Unknown_1", "C"], ["Fight", "C"], ["Flee", "C"], ["Alarm", "C"],
			 ["Unknown_1", "H6"], ["Flags", "L", { symflags => \%AIDT_FLAGS }]]],
	       [AI_E => [["X", "l"], ["Y", "l"], ["Z", "l"], ["Duration", "S"], ["ID", "a32"], ["Unknown_1", "S"]]],
	       [AI_F => $RD_Unknown],
	       [AI_T => $RD_Unknown],
	       [AI_W => [["Distance", "S"], ["Duration", "S"], ["Time_of_day", "C"],
			 ["Idle_1", "C"], ["Idle_1", "C"], ["Idle_1", "C"], ["Idle_1", "C"],
			 ["Idle_1", "C"], ["Idle_1", "C"], ["Idle_1", "C"], ["Idle_1", "C"],
			 ["Unknown_1", "C"]]],
	       [ANAM => $RD_Unknown],
	       [BNAM => $RD_Unknown],
	       [CNAM => $RD_Unknown],
	       [CNDT => [["Data", "Z*"]]],
	       [DNAM => $RD_Unknown],
	       [DODT => [["X", "f"], ["Y", "f"], ["Z", "f"], ["Angle_X", "f"], ["Angle_Y", "f"], ["Angle_Z", "f"]]],
	       [FLAG => [["Flags", "L", { symflags => \%NPC_FLAGS }]]],
	       [KNAM => $RD_Unknown],
	       [MODL => [["Model", "Z*"]]],
	       [NPCO => [["Count", "l"], ["Name", ["Z*", "a32"]]]],
	       [NPCS => [["Spell", ["Z32", "a32"]]]],
	       [NPDT => [],
		{
		 decode => sub {
		     my($self, $buff) = @_;
		     if (length($buff) == 12) {
			 ($self->{level}, $self->{disposition}, $self->{faction}, $self->{rank},
			  $self->{unk1}, $self->{unk2}, $self->{unk3}, $self->{gold}) =
			      unpack("SC6L", $buff);
		     } elsif (length($buff) == 52) {
			 my $i = 0;
			 foreach my $skill_level (unpack("x[SC8]C27", $buff)) {
			     $self->{lc($SKILL{$i++})} = $skill_level;
			 }
			 ($self->{level}, $self->{str}, $self->{int}, $self->{wil}, $self->{agi}, $self->{spd},
			  $self->{end}, $self->{per}, $self->{lck}, $self->{rep}, $self->{health},
			  $self->{magicka}, $self->{fatigue}, $self->{disposition}, $self->{faction},
			  $self->{rank}, $self->{gold}) = unpack("SC8x[C27]CSSSCCCxL", $buff);
		     } else {
			 $self->bad_length(length($buff));
		     }
		     return($self);
		 },
		 encode => sub {
		     my($self) = @_;
		     if (exists $self->{magicka}) {
			 return(pack("SC8C27CSSSCCCxL",
				     $self->{level}, $self->{str}, $self->{int}, $self->{wil}, $self->{agi},
				     $self->{spd}, $self->{end}, $self->{per}, $self->{lck},
				     $self->{block}, $self->{armorer}, $self->{mediumarmor}, $self->{heavyarmor},
				     $self->{bluntweapon}, $self->{longblade}, $self->{axe}, $self->{spear},
				     $self->{athletics}, $self->{enchant}, $self->{destruction}, $self->{alteration},
				     $self->{illusion}, $self->{conjuration}, $self->{mysticism}, $self->{restoration},
				     $self->{alchemy}, $self->{unarmored}, $self->{security}, $self->{sneak},
				     $self->{acrobatics}, $self->{lightarmor}, $self->{shortblade}, $self->{marksman},
				     $self->{mercantile}, $self->{speechcraft}, $self->{handtohand},
				     $self->{rep}, $self->{health}, $self->{magicka}, $self->{fatigue},
				     $self->{disposition}, $self->{faction}, $self->{rank}, $self->{gold}));
		     } else {
			 return(pack("SC6L", $self->{level}, $self->{disposition}, $self->{faction}, $self->{rank},
				     $self->{unk1}, $self->{unk2}, $self->{unk3},  $self->{gold}));
		     }
		 },
		 tostr => sub {
		     my($self) = @_;
		     if (exists $self->{str}) { # long form
			 my $skills = "";
			 my $n = 0;
			 foreach my $skill (sort values %SKILL) {
			     next if ($skill eq 'None');
			     $skills .= "\n\t\t" if (($n++ % 7) == 0);
			     $skills .= " $skill: $self->{lc($skill)}";
			 }
			 sprintf "Level:%d  Str:%d  Int:%d  Wil:%d  Agi:%d  Spd:%d  End:%d  Per:%d  Lck:%d\n\t\tRep:%d  Health:%d Magicka:%d  Fatigue:%d  Disp:%d  Faction:%d  Rank:%d  Gold:%d\n\t\tSkills:$skills",
			     $self->{level}, $self->{str}, $self->{int}, $self->{wil}, $self->{agi}, $self->{spd},
				 $self->{end}, $self->{per}, $self->{lck}, $self->{rep}, $self->{health}, $self->{magicka},
				     $self->{fatigue}, $self->{disposition}, $self->{faction}, $self->{rank}, $self->{gold};
		     } else {	# short form (autocalced)
			 sprintf "Level:%d  Disposition:%d  Faction:%d  Rank:%d  Gold:%d",
			     $self->{level}, $self->{disposition}, $self->{faction}, $self->{rank}, $self->{gold};
		     }
		 }
		}],
	       [RNAM => $RD_Unknown],
	       [SCRI => [["Script", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [PCDT => [			# ess, single record, no id needed
	       [AADT => $RD_Unknown],
	       [ANIS => $RD_Unknown],
	       [BNAM => $RD_Unknown],
	       [CNAM => $RD_Unknown],
	       [DNAM => $RD_Unknown],
	       [ENAM => $RD_Unknown],
	       [FNAM => [["Name", "Z*"]]],
	       [KNAM => $RD_Unknown],
	       [LNAM => $RD_Unknown],
	       [MNAM => $RD_Unknown],
	       [NAM0 => $RD_Unknown],
	       [NAM1 => $RD_Unknown],
	       [NAM2 => $RD_Unknown],
	       [NAM3 => $RD_Unknown],
	       [NAM9 => $RD_Unknown],
	       [PNAM => $RD_Unknown],
	       [SNAM => $RD_Unknown],
	      ]],
     [PGRD => [
	       [NAME => [["ID", "Z*"]]],
	       [DATA => $RD_Unknown],
	       [PGRC => $RD_Unknown],
	       [PGRP => $RD_Unknown],
	      ]],
     [PROB => [
	       [NAME => [["ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [PBDT => [["Weight", "f"], ["Value", "L"], ["Quality", "f"], ["Uses", "L"]], { flags => [qw(mergeable)] }],
	      ], { flags => [qw(mergeable)] }],
     [QUES => [
	       [NAME => [["ID", "Z*"]]],
	       [DATA => [["Info_ID", "Z*"]]], # {ess => 1}
	      ]],
     [RACE => [
	       [NAME => [["ID", "Z*"]]],
	       [DESC => [["Description", "a*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [NPCS => [["Spell", ["Z32", "a32"]]]],
	       [RADT => [["Skill_1", "l", { lookup => \%SKILL }], ["Bonus_1", "L"],
			 ["Skill_1", "l", { lookup => \%SKILL }], ["Bonus_1", "L"],
			 ["Skill_1", "l", { lookup => \%SKILL }], ["Bonus_1", "L"],
			 ["Skill_1", "l", { lookup => \%SKILL }], ["Bonus_1", "L"],
			 ["Skill_1", "l", { lookup => \%SKILL }], ["Bonus_1", "L"],
			 ["Skill_1", "l", { lookup => \%SKILL }], ["Bonus_1", "L"],
			 ["Skill_1", "l", { lookup => \%SKILL }], ["Bonus_1", "L"],
			 ["Attr_Male_1", "L", { lookup => \%ATTRIBUTE }], ["Attr_Female_1", "L", { lookup => \%ATTRIBUTE }],
			 ["Attr_Male_1", "L", { lookup => \%ATTRIBUTE }], ["Attr_Female_1", "L", { lookup => \%ATTRIBUTE }],
			 ["Attr_Male_1", "L", { lookup => \%ATTRIBUTE }], ["Attr_Female_1", "L", { lookup => \%ATTRIBUTE }],
			 ["Attr_Male_1", "L", { lookup => \%ATTRIBUTE }], ["Attr_Female_1", "L", { lookup => \%ATTRIBUTE }],
			 ["Attr_Male_1", "L", { lookup => \%ATTRIBUTE }], ["Attr_Female_1", "L", { lookup => \%ATTRIBUTE }],
			 ["Attr_Male_1", "L", { lookup => \%ATTRIBUTE }], ["Attr_Female_1", "L", { lookup => \%ATTRIBUTE }],
			 ["Attr_Male_1", "L", { lookup => \%ATTRIBUTE }], ["Attr_Female_1", "L", { lookup => \%ATTRIBUTE }],
			 ["Attr_Male_1", "L", { lookup => \%ATTRIBUTE }], ["Attr_Female_1", "L", { lookup => \%ATTRIBUTE }],
			 ["Male_Height", "f"], ["Female_Height", "f"],
			 ["Male_Weight", "f"], ["Female_Weight", "f"],
			 ["Flags", "L", { symflags => \%RADT_FLAGS }]],
	       {
		tostr => sub {
		    my($self) = @_;
		    my $radt = sprintf "Flags:%s  Male_Height:%0.2f  Male_Weight:%0.2f  Female_Height:%0.2f  Female_Weight:%0.2f\n\t\tSkill Bonuses:",
			decode_flags($self->{flags}, \%RADT_FLAGS), $self->{male_height}, $self->{male_weight},
			    $self->{female_height}, $self->{female_weight};
		    foreach my $i (1..7) {
			my($skill_id, $bonus) = ($self->{"skill_$i"}, $self->{"bonus_$i"});
			if (ASSERT) {
			    die "Null Bonus: ".Dumper($self)."\n" unless defined $bonus;
			    die "Null skill_id:$skill_id: ".Dumper($self)."\n" unless defined $skill_id;
			    die "Null SKILL for skill_id:$skill_id: ".Dumper($self)."\n" unless defined $SKILL{$skill_id};
			}
			$radt .= sprintf("\n\t\t%-12s %3d", $SKILL{$skill_id}, $bonus);
		    }
		    $radt .= "\n\t\tBase Attributes: Male/Female";
		    my $i = 1;
		    foreach my $attr (qw(Strength Intelligence Willpower Agility Speed Endurance Personality Luck)) {
			my($male, $female) = ($self->{"attr_male_$i"}, $self->{"attr_female_$i"});
			$radt .= sprintf("\n\t\t%-12s    %3d  %3d", $attr, $male, $female);
			$i++;
		    }
		    $radt;
		}
	       }],
	      ]],
     [REFR => [
	       [NAME => [["ID", "Z*"]]],
	       [AADT => $RD_Unknown],
	       [ACDT => $RD_Actor_Data],
	       [ACSC => $RD_Unknown],
	       [ACSL => $RD_Unknown],
	       [ACTN => [["Unknown_1", "L"]]], # Actor Number???
	       [CHRD => $RD_Unknown],
	       [CSHN => $RD_Unknown],
	       [CSTN => $RD_Unknown],
	       [DATA => $RD_Unknown],
	       [FGTN => [["Uknown_1", "a*"]]], # Following Target Name???
	       [FRMR => [["Form_Ref", "L"]]],
	       [ND3D => [["Unknown_1", "C"]]],
	       [STPR => $RD_Unknown],
	       [TGTN => [["Target", "a*"]]],
	       [WNAM => [["Readied_Spell", "Z*"]]],
	       [XSCL => [["Scale", "f"]]],
	      ]],
     [REGN => [
	       [NAME => [["ID", "Z*"]]],
	       [BNAM => [["Sleep_Creature_ID", "Z*"]]],
	       [CNAM => [["Red", "C:%x"], ["Green", "C:%x"], ["Blue", "C:%x"], ["Unused", "C"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [SNAM => [["Sound_Name", ["Z32", "a32"]], ["Chance", "C"]]],
	       [WEAT => [],
		{
		 decode => sub {
		     my($self, $buff) = @_;
		     if (length($buff) == 10) {
			 ($self->{clear}, $self->{cloudy}, $self->{foggy}, $self->{overcast},
			  $self->{rain}, $self->{thunder}, $self->{ash}, $self->{blight},
			  $self->{snow}, $self->{blizzard}) = unpack("C10", $buff);
		     } elsif (length($buff) == 8) {
			 ($self->{clear}, $self->{cloudy}, $self->{foggy},
			  $self->{overcast}, $self->{rain}, $self->{thunder},
			  $self->{ash}, $self->{blight}) = unpack("C8", $buff);
		     } else {
			 $self->bad_length(length($buff));
		     }
		     return($self);
		 },
		 encode => sub {
		     my($self) = @_;
		     if (exists $self->{blizzard}) {
			 pack("C10",
			      $self->{clear}, $self->{cloudy}, $self->{foggy}, $self->{overcast},
			      $self->{rain}, $self->{thunder}, $self->{ash}, $self->{blight},
			      $self->{snow}, $self->{blizzard});
		     } else {
			 pack("C8",
			      $self->{clear}, $self->{cloudy}, $self->{foggy}, $self->{overcast},
			      $self->{rain}, $self->{thunder}, $self->{ash}, $self->{blight});
		     }
		 },
		 tostr => sub {
		     my($self) = @_;
		     if (exists $self->{blizzard}) {
			 sprintf("Clear:%d  Cloudy:%d  Foggy:%d  Overcast:%d  Rain:%d  Thunder:%d  Ash:%d  Blight:%d  Snow:%d  Blizzard:%d",
				 $self->{clear}, $self->{cloudy}, $self->{foggy}, $self->{overcast}, $self->{rain},
				 $self->{thunder}, $self->{ash}, $self->{blight}, $self->{snow}, $self->{blizzard});
		     } else {
			 sprintf("Clear:%d  Cloudy:%d  Foggy:%d  Overcast:%d  Rain:%d  Thunder:%d  Ash:%d  Blight:%d",
			      $self->{clear}, $self->{cloudy}, $self->{foggy}, $self->{overcast},
			      $self->{rain}, $self->{thunder}, $self->{ash}, $self->{blight});
		     }
		 },
		}],
	       [WNAM => [["Name", "L"]]],
	      ], { flags => [qw(mergeable)] }],
     [REPA => [
	       [NAME => [["ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [RIDT => [["Weight", "f"], ["Value", "L"], ["Uses", "L"], ["Quality", "f"]], { flags => [qw(mergeable)] }],
	       [SCRI => [["Script", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [SCPT => [
	       [SCHD => [["ID", ["Z32", "a32"]], ["Num_Shorts", "L"], ["Num_Longs", "L"], ["Num_Floats", "L"],
			 ["Data_Size", "L"], ["Local_Var_Size", "L"]]],
	       [RNAM => [["Unknown_1", "L"]]],
	       [SCDT => [["Bytecode", "H*:(compiled script code)"]]],
	       [SCTX => [["Script_Text", "a*"]],
		{ tostr => sub {
		      my $str = $_[0]->{script_text};
		      $str =~ tr/\r//d if ($^O eq 'linux');
		      "Script_Text:\n$str";
		  },
		}],
	       [SCVR => [["Variables", "a*"]],
		{ tostr => sub { "Script_Variables: " . join(',', split(/\000/, $_[0]->{variables})) },
		}],
	       [SLCS => [["Shorts", "L"], ["Longs", "L"], ["Floats", "L"]]],
	       [SLFD => @RD_float_array],
	       [SLLD => @RD_long_array],
	       [SLSD => @RD_short_array],
	      ]],
     [SKIL => [
	       [INDX => [["ID", "L", { lookup => \%SKILL }]]],
	       [DESC => [["Description", "a*"]]],
	       [SKDT => [["Attribute", "L", { lookup => \%ATTRIBUTE }],
			 ["Specialization", "L", { lookup => \%SPECIALIZATION }],
			 ["Use_Values_1", "f"], ["Use_Values_1", "f"], ["Use_Values_1", "f"], ["Use_Values_1", "f"]]],
	      ], { flags => [qw(mergeable)] }],
     [SNDG => [
	       [NAME => [["ID", "Z*"]]],
	       [CNAM => [["Creature_ID", "Z*"]]],
	       [DATA => [["Data", "L"]]],
	       [SNAM => [["Sound_ID", "Z*"]]],
	      ]],
     [SOUN => [
	       [NAME => [["ID", "Z*"]]],
	       [DATA => [["Volume", "C"], ["MinRange", "C"], ["MaxRange", "C"]]],
	       [FNAM => [["Name", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [SPEL => [
	       [NAME => [["ID", "Z*"]]],
	       [ENAM => @RD_Enchantment],
	       [FNAM => [["Name", "Z*"]]],
	       [SPDT => [["Type", "L", { lookup => \%SPEL_TYPE }], ["Cost", "L"],
			 ["Flags", "L", { symflags => \%SPEL_FLAGS }]],
		{ flags => [qw(mergeable)] }],
	      ], { flags => [qw(mergeable)] }],
     [SPLM => [			# ess, single record, no id needed
	       [NAME => [["Name", "L"]]],
	       [CNAM => [["Unknown_1", "L"], ["Unknown_1", "Z*"]]],
	       [NAM0 => [["Unknown_1", "C"]]],
	       [NPDT => [["Name", ["Z32", "a32"]], ["Unknown_1", "H16"], ["Magnitude", "l"],
			 ["Seconds_Active", "f"], ["Long_1", "l"], ["Long_1", "l"]]],
	       [SPDT => [["Type", "L", { lookup => \%SPLM_TYPE }], ["Name", ["Z40", "a40"]], ["Long_1", "L"], ["Long_1", "L"],
			 ["Caster", ["Z32", "a32"]], ["Item", ["Z32", "a32"]], ["Long_1", "L"], ["unknown_1", "H80"]]],
	       [TNAM => [["Target", "Z*"]]],
	       [VNAM => [["Unknown_1", "L"]]],
	       [XNAM => [["Unknown_1", "C"]]],
	      ]],
     [SSCR => [
	       [NAME => [["ID", "Z*"]]],
	       [DATA => [["Name", "Z*"]]],
	      ]],
     [STAT => [
	       [NAME => [["ID", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	      ], { flags => [qw(mergeable)] }],
     [STLN => [
	       [NAME => [["ID", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [ONAM => [["Name", "Z*"]]],
	      ]],
     [TES3 => [
	       [HEDR => [["Version", "f"], ["Is_Master", "L"], ["Author", ["Z32", "a32"]],
			 ["Description", ["Z256", "a256"]], ["NRecords", "L"]],
		{
		 tostr => sub { my($self) = @_;
				(my $ver = sprintf("%0.2f", $self->{version})) =~ s/0+$//;
				sprintf(qq{${MARGIN}Version:$ver  Is_Master:%s  Author:"$self->{author}"\n${MARGIN}Description:"$self->{description}"\n${MARGIN}NRecords:$self->{nrecords}}, ($self->{is_master}) ? "True" : "False"); },
		}],
	       [
		[MAST => [["Master", "Z*"]],
		 { tostr => sub {
		       my($self) = @_;
		       $self->{_parent_}->{_tostr_} = $self->{master}; # stash for later
		       undef;
		   }
		 }],
		[DATA => [],
		 {
		  decode => sub {
		      my($self, $buff) = @_;
		      my($l1, $l2) = unpack("L2", $buff);
		      $self->{length} = $l1 + ($l2 << 32);
		      $self;
		  },
		  encode => sub {
		      my $len = $_[0]->{length};
		      my $l1 = $len & 0xffffffff;
		      my $l2 = $len >> 32;
		      pack("L2", $l1, $l2);
		  },
		  tostr => sub {
		      my($self) = @_;
		      my $master_str = $self->{_parent_}->{_tostr_};
		      delete $self->{_parent_}->{_tostr_};
		      return("Master: $master_str: Length=$self->{length}");
		  },
		 }],
	       ],
	       [GMDT => [["Unknown_1", "H48"], ["Current_Cell", ["Z64", "a64"]], ["Unknown_1", "L"], ["PCName", ["Z32", "a32"]]]],
	       [SCRD => [["Long_1", "L"], ["Long_1", "L"], ["Long_1", "L"], ["Long_1", "L"], ["Long_1", "L"]]],
	       [SCRS => [["Screenshot", "H*"]]],
	      ], {
		  id => sub { 'TES3' },
		 }],
     [VFXM => [			# ess, single record, no id needed
	       [VNAM => [["Long_1", "L"], ["Long_1", "L"], ["Long_1", "L"], ["Long_1", "L"], ["Long_1", "L"], ["Long_1", "L"],
			 ["Short", "S"], ["Unknown_1", "a22"],
			 ["Name_1", ["Z36", "a36"]], ["Name_1", ["Z68", "a68"]]]],
	      ]],
     [WEAP => [
	       [NAME => [["ID", "Z*"]]],
	       [ENAM => [["Enchantment", "Z*"]]],
	       [FNAM => [["Name", "Z*"]]],
	       [ITEX => [["Icon", "Z*"]]],
	       [MODL => [["Model", "Z*"]]],
	       [SCRI => [["Script", "Z*"]]],
	       [WPDT => [["Weight", "f"], ["Value", "L"], ["Type", "S", { lookup => \%WEAPON_TYPE }],
			 ["Health", "S"], ["Speed", "f"],
			 ["Reach", "f"], ["Enchant_Points", "S"], ["Chop_Min", "C"], ["Chop_Max", "C"],
			 ["Slash_Min", "C"], ["Slash_Max", "C"], ["Thrust_Min", "C"], ["Thrust_Max", "C"],
			 ["Flags", "L", { symflags => \%WEAPON_FLAGS }]],
		{ flags => [qw(mergeable)] }],
	      ], { flags => [qw(mergeable)] }],
    );

our %CODEC;

# TES3::Record "factory' for creating the various record types
sub new {
    my($class, $plugin, $rectype, $recbuf, $recflags, $unk, $stashbuf) = @_;
    my $self = {};
    $self->{F} = $recflags;
    $self->{U} = $unk;
    bless($self, $rectype);	# we re-bless into the class "$rectype"
    if (ASSERT) {
	Carp::confess "TES3::Record::new($class, $plugin, $rectype) is not a TES3::Record" unless $self->isa('TES3::Record');
    }
    $self->decode($plugin, $rectype, $recbuf, $stashbuf);
    return($self);
}

sub id { $_[0]->{_id_} }

sub bad_length {
    my($self, $len) = @_;
    err "DECODER ERROR on @{[ref($self)]}, Invalid length: $len";
}

sub subrecs { @{$_[0]->{SL}} }	# internal subrec list

sub decode { # PERF 2
    my($self, $plugin, $rectype, $recbuf, $stashbuf) = @_;
    # decode the subrecords for this record
    eval {
	my @parts = unpack("(a4L/a*)*", $recbuf);
	while (my($subtype, $subrecbuf) = splice(@parts, 0, 2)) {
	    my $tsr = $CODEC{$rectype}->{$subtype}->{init}->($self, $subrecbuf, $stashbuf);
	    $self->{_id_} = $tsr->{id} if (defined $tsr->{id});
	    # inline $tr->append() for speed
	    push(@{$self->{SL}}, $tsr);
	    push(@{$self->{SH}->{$subtype}}, $tsr);
	}
    };
    if ($@) {
	# eval'ed unpack choked, so try a safer (slightly slower) decoder
	my $p = 0;
	my $rec_len = length($recbuf);
	while ($p < $rec_len) {
	    my($subtype, $sublen) = unpack("a4L", substr($recbuf, $p));
	    $p += 8;
	    my $subrecbuf = substr($recbuf, $p, $sublen);
	    $p += $sublen;
	    if (defined $subrecbuf) {
		my $tsr = $CODEC{$rectype}->{$subtype}->{init}->($self, $subrecbuf, $stashbuf);
		$self->{_id_} = $tsr->{id} if (defined $tsr->{id});
		# inline $tr->append() for speed
		push(@{$self->{SL}}, $tsr);
		push(@{$self->{SH}->{$subtype}}, $tsr);
	    } else {
		err "$plugin: Error, malformed subrec for ($rectype) type=$subtype pos=$p len=$sublen\n";
	    }
	}
    }
    return($self);
} # decode

sub encode {
    my($self) = @_;
    return( join("", map { pack("a4L/a*", $_->subtype(), $_->encode()) } $self->subrecs()) );
}

my %flag_cache;
sub decode_flags {
    my($flags, $flagdefs) = @_;
    return($flag_cache{"$flags.$flagdefs"}) if (defined $flag_cache{"$flags.$flagdefs"});
    my @list = ();
    while (my($name, $val) = each %$flagdefs) {
	next if (length($name) == 1);
	if ($flags & $val) {
	    $name =~ s/([[:alnum:]]+)/ucfirst($1)/ge;
	    push(@list, $name);
	}
    }
    return($flag_cache{$flags.$flagdefs} = sprintf("0x%04x", $flags)." (".join(', ',@list).")");
}

sub gen_custom {
    my($package, $optref) = @_;
    # generate custom methods for record classes
    warn "DBG: gen_custom($package)\n" if (DBG);
    while (my($opt, $val) = each (%$optref)) {
	if (ref($val) eq 'CODE') {
	    # define a new method
	    no strict "refs";
	    my $method = "${package}::${opt}";
	    warn "DBG: defining custom method: $method\n" if (DBG);
	    *$method = eval { use strict "refs"; $val; };
	} elsif ($opt eq 'flags') {
	    # set a flag
	    my $flags_ref = "${package}::FLAGS";
	    foreach my $flag (@{$val}) {
		no strict "refs";
		*$flags_ref->{$flag} = 1;
	    }
	} else {
	    # oops
	}
    }
}

sub gen_subrec_methods {
    my($rectype, $subtype, $subdefref, $suboptref) = @_;
    my $decode_pack_format;
    my $encode_pack_format;
    my $method;
    my $package = "${rectype}::${subtype}";
    gen_custom($package, $suboptref);
    if (@{$subdefref}) {
	# generic codec subs
	my $decode_pack_format;
	my $encode_pack_format;
	my @fieldnames;
	my %seen;
	my @formats;
	my $lookup;
	my $symflags;
	foreach (@{$subdefref}) {
	    if (ref eq 'ARRAY') {
		my($fieldname, $fmt, $opt) = @{$_};
		$fieldname = lc($fieldname);
		# make a unique numbered fieldname
		while (exists $seen{$fieldname}) {
		    $fieldname =~ s/_\d+$//;
		    $fieldname .= '_' . ++$seen{$fieldname};
		}
		$seen{$fieldname} ||= 1;
		push(@fieldnames, $fieldname);
		my $pfmt;
		my $custom_format;
		if (ref($fmt) eq 'ARRAY') {
		    # different decoder/encoder defs
		    my($decode_fmt, $encode_fmt) = @$fmt;
		    ($decode_fmt, $custom_format) = split(/:/, $decode_fmt, 2);
		    $decode_pack_format .= ($pfmt = $decode_fmt);
		    $encode_pack_format .= $encode_fmt;
		} else {
		    # standard definition pair
		    ($fmt, $custom_format) = split(/:/, $fmt, 2);
		    $decode_pack_format .= ($pfmt = $fmt);
		    $encode_pack_format .= $fmt;
		}
		if (my $hashref = $opt->{lookup}) {
		    $lookup->{$fieldname} = $hashref;
		}
		if (my $hashref = $opt->{symflags}) {
		    $symflags->{$fieldname} = $hashref;
		}
		my $label = $fieldname;
		$label =~ s/([[:alnum:]]+)/ucfirst($1)/ge;
		$label =~ s/(?:^|_)id$/ID/i;
		if (defined($custom_format)) {
		    push(@formats, ($custom_format) ? "$label:$custom_format" : $label);
		} else {
		    if ($pfmt =~ /^[aZH]/) {
			push(@formats, "$label:%s");
		    } elsif ($pfmt =~ /^f/) {
			push(@formats, "$label:\%0.2f");
		    } elsif ($pfmt =~ /^[LCS]/i) {
			if (defined $lookup->{$fieldname} or defined $symflags->{$fieldname}) {
			    push(@formats, "$label:%s");
			} else {
			    push(@formats, "$label:%d");
			}
		    } else {
			abort qq{($package): Don't know how to stringify: "$pfmt"};
		    }
		}
	    } else {
		die "$package: Invalid subrecord definition structure.\n";
	    }
	}
	no strict "refs";
	# tsr->decode - unpack fields of a subrec into our self hash
	unless ($package->can('decode')) {
	    $method = "${package}::decode";
	    *$method = sub {
		use strict "refs";
		my($self, $subrecbuf) = @_;
		my(@vals) = unpack($decode_pack_format, $subrecbuf);
		# assert scalar(@vals) == scalar(@fieldnames)
		$self->{$_} = shift(@vals) foreach (@fieldnames);
		return($self);
	    }; # PERF 3
	}

	# tsr->encode - pack fields of our self hash into a subrec buffer
	unless ($package->can('encode')) {
	    $method = "${package}::encode";
	    *$method = sub {
		use strict "refs";
		my @vals;
		push(@vals, $_[0]->{$_}) foreach (@fieldnames); # $_[0] is self
		pack($encode_pack_format, @vals);
	    };
	}

	# tsr->tostr - convert subrec to printable string
	unless ($package->can('tostr')) {
	    my $print_format = join("  ", @formats);
	    my $check_lookups = grep { defined $lookup->{$_} } @fieldnames;
	    my $check_symflags = grep { defined $symflags->{$_} } @fieldnames;
	    $method = "${package}::tostr";
	    if ($check_lookups or $check_symflags) {
		*$method = sub {
		    use strict "refs";
		    my($self) = @_;
		    my @values;
		    foreach my $fieldname (@fieldnames) {
			if (defined $lookup->{$fieldname}) {
			    if (my $symval = $lookup->{$fieldname}->{$self->{$fieldname}}) {
				push(@values, "($symval)");
			    } else {
				err qq{${package}::tostr: do not know how to lookup symbolic value for: "$fieldname" ($self->{$fieldname})};
			    }
			} elsif (defined $symflags->{$fieldname}) {
			    if (my $symval = decode_flags($self->{$fieldname}, $symflags->{$fieldname})) {
				push(@values, "[$symval]");
			    } else {
				err qq{${package}::tostr: do not know how to calculate symbolic flags for: "$fieldname"};
			    }
			} else {
			    push(@values, $self->{$fieldname});
			}
		    }
		    sprintf($print_format, @values);
		};
	    } else {
		*$method = sub {
		    use strict "refs";
		    my($self) = @_;
		    sprintf($print_format, map { $self->{$_} } @fieldnames);
		};
	    }
	}
    }
    $CODEC{$rectype}->{$subtype}->{init} = sub {
	use strict "refs";
	my($parent, $init, $stashbuf) = @_;
	my $self = { _parent_ => $parent };
	bless($self, $package);
	$self->{_buf_} = $init if ($stashbuf);
	$self->decode($init);
	return($self);
    }; # PERF 1
    no strict "refs";

    # tsr->new()
    $method = "${package}::new";
    *$method = sub {
	use strict "refs";
	my($class, $parent, $hashref) = @_;
	my $self = $hashref;
	$self->{_parent_} = $parent;
	bless($self, $class);
    };

    # tsr->getbuf()
    $method = "${package}::getbuf";
    *$method = sub {
	use strict "refs";
	return($_[0]->{_buf_});	# $_[0] is self
    };

    # tsr->fulltype()
    $method = "${package}::fulltype";
    *$method = sub { use strict "refs"; "${rectype}.${subtype}"; };

    # tsr->rectype()
    $method = "${package}::rectype";
    *$method = sub { use strict "refs"; ${rectype}; };

    # tsr->subtype()
    $method = "${package}::subtype";
    *$method = sub { ${subtype}; };
    return();
} # gen_subrec_methods

sub gen_class {
    my($recdefref) = @_;
    my($rectype, $subrecdefs, $optref) = @{$recdefref};
    my(@recdefs) = @{$subrecdefs};
    my $method;
    eval {
	no strict 'refs';
	# make class "$rectype" inherit from TES3::Record
	@{"${rectype}::ISA"} = qw(TES3::Record);
    };
    foreach my $defref (@recdefs) {
	if (ref($defref->[0]) eq 'ARRAY') {
	    # define group
	    my @group;
	    foreach (@{$defref}) {
		my($subtype, $subdefref, $suboptref) = @{$_};
		push(@group, $subtype);
		gen_subrec_methods($rectype, $subtype, $subdefref, $suboptref);
	    }
	    # TBD - do something with group information?
	} else {
	    gen_subrec_methods($rectype, @{$defref});
	}
    }
    gen_subrec_methods($rectype, DELE => [["DELETED", "L"]]);

    gen_custom("${rectype}", $optref);

    no strict "refs";
    # definitions of methods for record classes

    # $tr->new()
    $method = "${rectype}::new";
    *$method = sub {
	use strict "refs";
	my($rectype, $init) = @_;
	my $self = { R => [] };
	bless($self, $rectype);
	if (defined $init and ref($init) eq 'ARRAY') {
	    if (ref($init->[0]) eq 'ARRAY') {
		# allow caller to pass in an array of structs to be constructed into subrec objects
		foreach my $subrecref (@$init) {
		    my($subtype, $subhash) = @{$subrecref};
		    no strict 'refs';
		    $self->append("${rectype}::${subtype}"->new($self, $subhash));
		}
	    } else {
		# or alternatively pass in array of subrec objects
		foreach my $tsr (@$init) {
		    $self->append($tsr);
		}
	    }
	}
	$self;
    };


    # $tr->append()
    $method = "${rectype}::append";
    *$method = sub {
	use strict "refs";
	my $self = shift(@_);
	push(@{$self->{SL}}, @_);
	push(@{$self->{SH}->{$_->subtype()}}, $_) foreach (@_);
	$self;
    };

    # $tr->rectype()
    $method = "${rectype}::rectype";
    *$method = sub { use strict "refs"; ${rectype}; };

    # $tr->flagstr()
    unless ($rectype->can('flagstr')) {
	$method = "${rectype}::flagstr";
	*$method = sub {
	    use strict "refs";
	    decode_flags($_[0]->{F}, \%REC_FLAGS);
	};
    }

    # $tr->flags()
    unless ($rectype->can('flags')) {
	$method = "${rectype}::flags";
	*$method = sub {
	    use strict "refs";
	    $_[0]->{F};
	};
    }

    # $tr->unk()
    unless ($rectype->can('unk')) {
	$method = "${rectype}::unk";
	*$method = sub {
	    use strict "refs";
	    $_[0]->{U};
	};
    }

    # $tr->tostr()
    unless ($rectype->can('tostr')) {
	$method = "${rectype}::tostr";
	*$method = sub {
	    use strict "refs";
	    my($self) = @_;
	    if (ASSERT) {
		my $id = $self->id();
		defined($id) or die "NO ID: ".Dumper($self)."\n";
		my $flag_str = $self->flagstr();
		my @tostr = (qq{Record: $rectype "$id" Flags:$flag_str});
		foreach my $tsr (@{$self->{SL}}) {
		    my $tsr_str = $tsr->tostr();
		    next unless defined $tsr_str;
		    my $subtype = $tsr->subtype();
		    push(@tostr, qq{$subtype: $tsr_str});
		}
		return(join("\n${MARGIN}", @tostr));
	    }
	    qq{Record: $rectype "@{[$self->id()]}" Flags: @{[$self->flagstr()]}\n} . $MARGIN .
		join("\n${MARGIN}", map { $_->subtype().": ".($_->tostr() or return('')) } (@{$self->{SL}}));
	}; # PERF 4
    }
    # $tr->set()
    $method = "${rectype}::set";
    *$method = sub {
	use strict "refs";
	my($self, $selector, $newval) = @_; # opt is hashref with keys: "i", "t", "f"
	unless (defined $newval) {
	    warn qq{Usage: set(\$selector_hash, \$newvalue)
selector_hash can have the keys: "i", "t", or "f"\n};
	    return;
	}
	my $r = $self->{SL};
	my $modified = 0;
	my @indices = defined($selector->{i}) ? @{$selector->{i}} : (0 .. $#$r);
	foreach my $i (@indices) {
	    my $type = $r->[$i]->[0];
	    next if (defined($selector->{t}) and ($selector->{t} ne $type));
	    if (defined($selector->{f})) {
		my $key = lc($selector->{f});
		if (defined($r->[$i]->[1]->{$key})) {
		    if ($r->[$i]->[1]->{$key} ne $newval) {
			$r->[$i]->[1]->{$key} = $newval;
			$modified++;
		    }
		    #print qq{$i: $type  $key = $r->[$i]->[1]->{$key}\n};
		} else {
		    next;
		}
	    } else {
		# set all fields
		my @ordered_fields = ();
		my @unordered_fields = ();
		while (my($key, $val) = each %{$r->[$i]->[1]}) {
		    if ($val ne $newval) {
			$r->[$i]->[1]->{$key} = $newval;
			$modified++;
		    }
		    if (defined $r->[$i]->[2]->{$key}) {
			$ordered_fields[$r->[$i]->[2]->{$key}] = "$key = $val";
		    } else {
			push(@unordered_fields, "$key = $val");
		    }
		}
		#print "$i: $type ", join(", ", @ordered_fields, @unordered_fields), "\n";
	    }
	}
	return($modified);
    };

    # $tr->get_type()
    $method = "${rectype}::get_type";
    *$method = sub {
	use strict "refs";
	my($self, $subtype, $field, $index) = @_;
	$index ||= 0;
	if (defined $field) {
	    # return a field
	    return($self->{SH}->{$subtype}->[$index]->{$field});
	} else {
	    # return entire subrec
	    return($self->{SH}->{$subtype}->[$index]);
	}
    };

    # $tr->get(), return first field that matches selector
    $method = "${rectype}::get";
    *$method = sub {
	use strict "refs";
	my($self, $selector) = @_;	# opt is hashref with keys: "i", "t", "f"
	abort qq{get: you must use at least the selector "f" (fieldname)}
	    unless (defined $selector->{f});
	my @indices = defined($selector->{i}) ? ($selector->{i}) : (0 .. $#{$self->{SL}});
	my $key = lc($selector->{f});
	foreach my $i (@indices) {
	    my $tsr = $self->{SL}->[$i];
	    next if (defined($selector->{t}) and ($tsr->subtype() !~ /^$selector->{t}/i));
	    return($tsr->{$key}) if (defined($tsr->{$key}));
	}
	my @opts; push(@opts, "$_ = $selector->{$_}") foreach (keys %$selector);
	die "get: no match for (@opts)\n";
    };

    # $tr->dump()
    $method = "${rectype}::dump";
    *$method = sub {
	use strict "refs";
	my($self, $selector) = @_;	# opt is hashref with keys: "i", "t", "f"
	abort qq{get: you must use at least the selector "f" (fieldname)}
	    unless (defined $selector->{f});
	my $r = $self->{SL};
	my @indices = defined($selector->{i}) ? @{$selector->{i}} : (0 .. $#$r);
	foreach my $i (@indices) {
	    my $type = $r->[$i]->[0];
	    next if (defined($selector->{t}) and ($type !~ /^$selector->{t}/i));
	    if (defined($selector->{f})) {
		my $key = lc($selector->{f});
		if (defined($r->[$i]->[1]->{$key})) {
		    print qq{$i: $type  $key = $r->[$i]->[1]->{$key}\n};
		} else {
		    next;
		}
	    } else {
		# TBD - where is my ordering info?
		# dump all fields
		my @ordered_fields = ();
		my @unordered_fields = ();
		while (my($key, $val) = each %{$r->[$i]->[1]}) {
		    $val = qq{"$val"} if ($val =~ /[^\d.]/);
		    my $print_key = lcfirst($key);
		    if (defined $r->[$i]->[2]->{$key}) {
			$ordered_fields[$r->[$i]->[2]->{$key}] = "$key = $val";
		    } else {
			push(@unordered_fields, "$key = $val");
		    }
		}
		print " $i: $type ", join(", ", @ordered_fields, @unordered_fields), "\n";
	    }
	}
	return(0);
    };
} # gen_class

sub generate_classes {
    gen_class($_) foreach (@RECDEFS);
}

### end of TES3::Record package

package main;

BEGIN {
    use constant DBG => grep(/^(?:-d|-?-debug)$/, @ARGV);
    use constant ASSERT => scalar(grep(/^-?-assert$/, @ARGV));
    use constant VERBOSE => (DBG or grep(/^(?:-v|-?-verbose)$/, @ARGV)); # debug turns on verbosity
    Util->import(qw(err dbg prn abort));
}

TES3::Record::generate_classes();

### CONSTANTS

use constant {
    QUIET => 1,
    MIN_TES3_PLUGIN_SIZE => 324,
};

###GLOBALS (Miscellaneous)

my $T3 = new TES3::Util;
my $R = {};			# current decoded record (for modify) # TBD - nuke
my $MASTER_ID;			# data loaded from masters
my $GLOBCHARS = '*?';		# for filename matching
my $RECTYPE_LEN = 4;

# common Options
our @STDOPT = (qw(debug assert verbose));
our $opt_cell_object_match;
our $opt_cell_object_no_match;
our $opt_exterior;
our $opt_interior;
our $opt_list;
our $opt_match;
our $opt_no_banner;
our $opt_no_cache;
our $opt_no_match;
our $opt_output_dir;
our $opt_overwrite;
our $opt_report_only;
our $opt_separator;
our $opt_sub_match;
our $opt_sub_no_match;
our @opt_flag;
our @opt_id = ();
our @opt_type = ();

my %CLEAN_PLUGIN =
    (
     "bloodmoon.esm"             => "Bethesda Master",
     "fogpatch.esp"              => "does not need cleaning",
     "gmst fix.esp"              => "intentionally contain Evil GMSTs",
     "gmst vaccine.esp"          => "intentionally contain Evil GMSTs",
     "mashed lists.esp"          => "does not need cleaning",
     "merged_dialogs.esp"        => "does not need cleaning, but you should delete it anyway",
     "merged_leveled_lists.esp"  => "does not need cleaning, but you should use multipatch instead",
     "merged_objects.esp"        => "does not need cleaning",
     "morrowind.esm"             => "Bethesda Master",
     "multipatch.esp"            => "does not need cleaning",
     "tribunal.esm"              => "Bethesda Master",
    );


###USAGES

my $FIXIT_USAGE = q{Usage: tes3cmd fixit

DESCRIPTION:

The fixit command does the following operations:
- Cleans all your plugins ("tes3cmd clean")
- Synchronizes plugin headers to your masters ("tes3cmd header --synchronize")
- Generates a patch for merged leveled lists and more ("tes3cmd multipatch")
};

sub opts_fixit {
    $_[0] && do { die $FIXIT_USAGE; };
    GetOptions(@STDOPT) or die $FIXIT_USAGE;
}

my $RECOVER_USAGE = q{Usage: tes3cmd recover OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

DESCRIPTION:

Attempts to recover readable records from a damaged plugin. You should only
use this when Morrowind gives the following type of error on your plugin:

"Trying to load a bad form in TES3File::NextForm"

The main reason you would get this error is if the file has been physically
corrupted, where records have been overwritten with random binary junk, or
if the file has been truncated, or otherwise damaged.

This is not for fixing what is commonly referred to as "savegame corruption",
which is not actually corruption but bad data.

In any case, you will get detailed output on what tes3cmd finds damaged.

EXAMPLE(S):

# fix my damaged plugin:
tes3cmd recover "my plugin.esp"
};

sub opts_recover {
    $_[0] && do { die $RECOVER_USAGE; };
    GetOptions(@STDOPT) or die $RECOVER_USAGE;
}

my $CLEAN_USAGE = q{Usage: tes3cmd clean OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --cell-objects
	clean objects from cells when duped from masters

 --cell-params
	clean cell subrecords AMBI,WHGT duped from masters
 --dups
	clean other complete records duped from masters

 --gmsts
	clean Evil GMSTs

 --junk-cells
	clean junk cells (no new info from definition in masters)

 --no-cache
	do not create cache files (used for speedier cleaning)

 --output-dir <dir>
	set output directory to <dir> (default is where input plugin is)

 --replace
	replace original plugin with clean version (original is backed up)

DESCRIPTION:

Cleans plugins of various junk. If no cleaning options are selected, the
default is to assume the options:

  --cell-objects --cell-params --dups --gmsts --junk-cells

The goal of the "clean" command is that it should always be safe to use it
with no options to get the default cleaning behavior. The different cleaning
operations are explained below:

Cell Objects (--cell-objects)

  The clean command will clean objects in the plugin that match objects in any
  of its masters. Objects in cells are defined as byte sequences starting in
  the subrecord following a FRMR subrecord, and match only if this is the same
  byte sequence as in the master, along with the same Object-Index from the
  FRMR. NAM0 subrecords are not part of cell objects, and if objects are
  deleted from a cell, the NAM0 subrecord for the cell is updated to reflect
  any changing object count.

Cell Params (--cell-params)

  The subrecords for AMBI (ambient lighting) and WHGT (water height) for
  interior cells are often duplicated from the master of a plugin when the
  plugin is saved in the Construction Set.

Duplicate Records (--dups)

  Object definitions for various record types defined in a master are
  sometimes unnecessarily duplicated in dependent plugins, and this option
  will safely clean them. Only objects that have identical flags and byte
  sequences will be cleaned.

Evil GMSTs (--gmsts)

  An Evil GMST is defined as a GMST from the list of 11 Tribunal GMSTs or 61
  Bloodmoon GMSTs that are inadvertently introduced to a plugin by the
  Construction Set with specific values. Other GMSTs or GMSTs from those lists
  that do not have the specific Evil Values are NOT cleaned by this function.
  For details on Evil GMSTs, see: http://www.wikihost.org/w/mlox/evil_gmsts/

  To clean GMSTs that are not Evil, you can use the command:
    "tes3cmd delete --type gmst"

Junk Cells (--junk-cells)

  Junk cells are bogus external CELL records that crop up in many plugins due
  to a Construction Set bug. They contain only NAME, DATA and sometimes RGNN
  subrecords with data identical to the master. (In addition, interior cells
  will also be removed if they do not introduce any new information).

Cache Files Feature

  tes3cmd will normally create cached data files for your masters in the
  subdirectory: "Data Files/tes3cmd". If you do not wish tes3cmd to create
  cache files, you can use the --no-cache option. (But it is recommended you
  do use them for speedier cleaning).

EXAMPLES:

# clean my plugin of only Evil GMSTs:
tes3cmd clean --gmsts "my plugin.esp"

# clean 2 plugins and put the cleaned versions in a subdirectory "Clean":
tes3cmd clean --output-dir Clean "my plugin1.esp" "my plugin2.esp"

# clean all plugins in the current directory, replacing the originals with
# the cleaned versions and save the diagnostic output to a file (clean.txt):
tes3cmd clean --replace *.esm *.esp > clean.txt
};

our $opt_clean_all = 0;
our $opt_clean_cell_objects = 0;
our $opt_clean_cell_params = 0;
our $opt_clean_dups = 0;
our $opt_clean_gmsts = 0;
our $opt_clean_junk_cells = 0;
our $opt_clean_replace = 0;
sub opts_clean {
    $_[0] && do { die $CLEAN_USAGE; };
    GetOptions(@STDOPT,
	       'all'           => \$opt_clean_all,
	       'cell-objects'  => \$opt_clean_cell_objects,
	       'cell-params'   => \$opt_clean_cell_params,
	       'dups'          => \$opt_clean_dups,
	       'gmsts'         => \$opt_clean_gmsts,
	       'junk-cells'    => \$opt_clean_junk_cells,
	       'no-cache',
	       'output-dir',
	       'replace'       => \$opt_clean_replace)
	or die $CLEAN_USAGE;
    unless ($opt_clean_cell_objects or $opt_clean_cell_params or $opt_clean_dups or $opt_clean_gmsts or $opt_clean_junk_cells) {
	# turn on all safe cleaning options if none are selected.
	$opt_clean_cell_objects = $opt_clean_cell_params = $opt_clean_dups = $opt_clean_gmsts = $opt_clean_junk_cells = 1;
    }
    if ($opt_clean_all) {
	# turn on all cleaning options (in future we may add some that are possibly unsafe)
	$opt_clean_cell_objects = $opt_clean_cell_params = $opt_clean_dups = $opt_clean_gmsts = $opt_clean_junk_cells = 1;
    }
}

my $ESP_USAGE = q{Usage: tes3cmd esp OPTIONS master...

OPTIONS:
 --debug
	turn on debug messages

 --overwrite
	overwrite output if it exists

DESCRIPTION:

Copies input master (.esm) to a plugin (.esp). If the output file already
exists, you must add the --overwrite option to overwrite it.

EXAMPLES:

# output is: "my plugin.esp"
tes3cmd esp "my plugin.esm"
};

sub opts_esp {
    $_[0] && do { die $ESP_USAGE; };
    GetOptions(@STDOPT, 'overwrite') or die $ESP_USAGE;
}

my $ESM_USAGE = q{Usage: tes3cmd esm OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --overwrite
	overwrite output if it exists

DESCRIPTION:

Copies input plugin (.esp) to a master (.esm). If the output file already
exists, you must add the --overwrite option to overwrite it.

EXAMPLES:

# output is: "my plugin.esm"
tes3cmd esm "my plugin.esp"
};

sub opts_esm {
    $_[0] && do { die $ESM_USAGE; };
    GetOptions(@STDOPT, 'overwrite') or die $ESM_USAGE;
}

my $MODIFY_USAGE = q{Usage: tes3cmd modify OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --exterior
	if record is CELL, only match if it is an Exterior

 --flag* <flag>
	only modify records with given flag. Flags may be given symbolically
	as: (deleted, persistent, ignored, blocked), or via their numeric
	values (i.e. persistent is 0x400).

 --id* <id-regex>
	only process records whose ids match regular expression pattern
	<id-regex>

 --interior
	if record is CELL, only match if it is an Interior

 --match <regex>
	only process records that match given regular expression <regex>

 --no-match <regex>
	only process records that do not match given regular expression
	<regex>

 --program-file <file>
	load Perl code to run on each matched record from file named: <file>

 --replace /a/b/
	replace regex a with b. you can use any character instead of the slash

 --run "<code>"
	specify a string of Perl <code> to run on each matched record

 --sub-match <regex>
	only modify the subrecords that match <regex>

 --sub-no-match <regex>
	only modify the subrecords that do not match <regex>

 --type* <record-type>
	only modify records with the given <record-type>

 Note: starred (*) options can be repeated.

Modifies records/subrecords from the plugin. You can really damage things with
this command, so be careful!

Helper Functions: dumprec() and setrec()

tes3cmd includes 2 builtin helper functions to help you make your
modifications: dumprec() and setrec(). Use dumprec() to print out a view of
the records. If you just use: "-e 'dumprec()'", you will get an idea of the
record structure. Both functions take the same 2 arguments. The first is a
reference to a Perl hash containing any or all of these keys: "i" (subrecord
Index), "t" (subrecord Type), "f" (subrecord Field). "i" will constrain
matching of subrecords to subrecords by index. "t" specifies a subrecord type
match, and "f" specifies a field name to match. The final argument to setrec()
is the value to assign to matching fields.

Note: documentation for regular expressions:
  http://www.perl.com/doc/manual/html/pod/perlre.html

Example(s):

# print the first 4 subrecords of the cell "Ashmelech" from Morrowind.esm
tes3cmd modify --type cell --id ashmelech --run 'dumprec({i=>[0..3]})' Morrowind.esm

# Problem: Aleanne's clothing mods do not have restocking inventory
# Solution: create a small patch to change the counts for inventory containers
#   to negative numbers so they will be restocking.
# Step 0: confirm the problem, showing the non-negative counts:
tes3cmd print --type cont ale_clothing_v?.esp
# Step 1: Create the patch file ale_patch.esp containing just the container records:
tes3cmd dump --raw-with-header ale_patch.esp --type cont ale_clothing_v?.esp
# Step 2: Change all the count fields for the containers in Aleanne's Clothing to -3 (for restocking wares)
tes3cmd modify --type cont --run "setrec({f=>'Count'}, -3)" ale_patch.esp
# Note: on Linux, the quoting would be a little different:
tes3cmd modify --type cont --run 'setrec({f=>"Count"}, -3)' ale_patch.esp
};

our $opt_modify_program_file = '';
our $opt_modify_replace = '';
our $opt_modify_run = '';
sub opts_modify {
    $_[0] && do { die $MODIFY_USAGE; };
    GetOptions(@STDOPT,
	       'exterior',
	       'flag=s@',
	       'id=s@',
	       'interior',
	       'match=s',
	       'no-match|M=s',
	       'program-file=s' => \$opt_modify_program_file,
	       'replace=s' => \$opt_modify_replace,
	       'run=s' => \$opt_modify_run,
	       'sub-match=s',
	       'sub-no-match|M=s',
	       'type=s@')
	or die $MODIFY_USAGE;
}

my $MULTIPATCH_USAGE = q{Usage: tes3cmd multipatch

OPTIONS:
 --debug
	turn on debug messages

 --cellnames
	resolve conflicts with renamed external cells

 --fogbug
	fix interior cells with the fog bug

 --merge-lists
	merges leveled lists used in your active plugins

 --no-cache
	do not create cache files (used for speedier operation)

 --summons-persist
	fixes summoned creatures crash by making them persistent

DESCRIPTION:

The multipatch produces a patch file based on your current load order to
solve various problems. You should regenerate your multipatch whenever you
change your load order. After you have generated the multipatch.esp plugin,
you should enable it in your active plugins. The goal of the "multipatch"
command is that it should always be safe to use it with no options to get the
default patching behavior. If no options are specified, the following options
are assumed:

  --cellnames --fogbug --merge-lists --summons-persist

The different patching operations are explained below:

Cell Name Patch (--cellnames)

  Creates a patch plugin to ensure renamed cells are not accidentally reverted
  to their original name.

  This command solves the following plugin conflict that causes bugs:
  * Master A names external CELL (1, 1) as: "".
  * Plugin B renames CELL (1, 1) to: "My City".
  * Plugin C modifies CELL (1, 1), using the original name "", reverting
    plugin B's renaming.
  * References in plugin B (such as in scripts) that refer to "My City" break.

  This command scans your currently active plugin load order for cell name
  reversions, and ensures whenever possible that cell renaming is properly
  maintained. You should regenerate your cellnamepatch whenever you change your
  load order.

Fog Bug Patch (--fogbug)

  Some video cards are affected by how Morrowind handles a fog density setting
  of zero in interior cells with the result that the interior is pitch black,
  except for some light sources, and no amount of light, night-eye, or gamma
  setting will make the interior visible. This is known as the "fog bug".

  This command creates a patch plugin that fixes all fogbugged cells in your
  active plugins by setting the fog density of those cells to a non-zero
  value.

Summoned creatures persists (--summons-persist)

  There's a bug in Morrowind that can cause the game to crash if you leave a
  cell where an NPC has summoned a creature. The simple workaround is to flag
  summoned creatures as persistent. The Morrowind Patch Project implements
  this fix, however other mods coming later in the load order often revert it.
  This multipatch option ensures that known summoned creatures are flagged as
  persistent.

EXAMPLES:

# Create the patch plugin "multipatch.esp"
tes3cmd multipatch
};

our $opt_multipatch_cellnames;
our $opt_multipatch_fogbug;
our $opt_multipatch_merge_lists;
our $opt_multipatch_summons_persist;
sub opts_multipatch {
    $_[0] && do { die $MULTIPATCH_USAGE; };
    GetOptions(@STDOPT,
	       'cellnames'    => \$opt_multipatch_cellnames,
	       'fogbug'       => \$opt_multipatch_fogbug,
	       'merge-lists'  => \$opt_multipatch_merge_lists,
	       'no-cache',
	       'summons-persist' => \$opt_multipatch_summons_persist)
	or die $MULTIPATCH_USAGE;

    unless ($opt_multipatch_cellnames or $opt_multipatch_fogbug or
	    $opt_multipatch_merge_lists or $opt_multipatch_summons_persist) {
	# by default turn on all options if none are selected
	$opt_multipatch_cellnames = $opt_multipatch_fogbug = $opt_multipatch_merge_lists = $opt_multipatch_summons_persist = 1;
    }
}


my $DELETE_USAGE = q{Usage: tes3cmd delete OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --cell-object-match <regex>
	when printing cells, only print the matching objects in the cell

 --cell-object-no-match <regex>
	when printing cells, only print the non-matching objects in the cell

 --exterior
	if record is CELL, only match if it is an Exterior

 --flag* <flag>
	only modify records with given flag. Flags may be given symbolically
	as: (deleted, persistent, ignored, blocked), or via their numeric
	values (i.e. persistent is 0x400).

 --id* <id-regex>
	only process records whose ids match regular expression pattern
	<id-regex>

 --interior
	if record is CELL, only match if it is an Interior

 --match <regex>
	only process records that match given regular expression <regex>

 --no-match <regex>
	only process records that do not match given regular expression
	<regex>

 --sub-match <regex>
	only modify the subrecords that match <regex>

 --sub-no-match <regex>
	only modify the subrecords that do not match <regex>

 --type* <record-type>
	only modify records with the given <record-type>

 Note: starred (*) options can be repeated.

DESCRIPTION:

Deletes records/subrecords from the plugin. You can really damage things with
this command, so be careful!

Note: documentation for regular expressions:
  http://www.perl.com/doc/manual/html/pod/perlre.html

EXAMPLES:

# Delete all records with IDs matching "foo":
# Note that this doesn't also delete records that may depend on "foo".
tes3cmd delete --id foo "my plugin.esp"
};

sub opts_delete {
    $_[0] && do { die $DELETE_USAGE; };
    GetOptions(@STDOPT,
	       'cell-object-match=s',
	       'cell-object-no-match=s',
	       'exterior',
	       'flag=s@',
	       'id=s@',
	       'interior',
	       'match=s',
	       'no-match|M=s',
	       'sub-match=s',
	       'sub-no-match|M=s',
	       'type=s@')
	or die $DELETE_USAGE;
}

my $OVERDIAL_USAGE = q{Usage: tes3cmd overdial OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --single
	only test to see if dialog in the first plugin is overlapped. (by
	default all plugins are checked against all other plugins, which is an
	n-squared operation, meaning "possibly very slow").

DESCRIPTION:

Prints the IDs of dialog records that overlap from the set of given plugins.

An overlap is defined as a dialog (DIAL) Topic from one plugin that entirely
contains a dialog Topic from another plugin as a substring. For example, the
mod "White Wolf of Lokken" has a dialog topic "to rescue me" which overlaps
with the dialog topic "rescue me" from "Suran Underworld", which causes the
"Special Guest" quest from SU to get stuck because Ylarra won't offer the
topic "rescue me" when you find her in her cell.

Note that overlap is only a potential problem if the plugins are loaded in the
order they are listed in the output.

Example(s):

# Show dialog overlaps between Lokken and SU:
tes3cmd overdial "BT_Whitewolf_2_0.esm" "Suran_Underworld_2.5.esp"
};

our $opt_overdial_single;
sub opts_overdial {
    $_[0] && do { die $OVERDIAL_USAGE; };
    GetOptions(@STDOPT,
	       'single' => \$opt_overdial_single)
	or die $OVERDIAL_USAGE;
}

my $COMMON_USAGE = q{Usage: tes3cmd common OPTIONS plugin1 plugin2

OPTIONS:
 --debug
	turn on debug messages

DESCRIPTION:

Prints the IDs of records that the 2 given plugins have in common.

EXAMPLES:

# Show the records in common between my plugin and Morrowind.esm:
tes3cmd common "my plugin.esp" "Morrowind.esm"
};

sub opts_common {
    $_[0] && do { die $COMMON_USAGE; };
    GetOptions(@STDOPT) or die $COMMON_USAGE;
}


my $DIFF_USAGE = q{Usage: tes3cmd diff OPTIONS plugin1 plugin2

OPTIONS:
 --debug
	turn on debug messages

 --ignore-type* <record-type>
	ignore given type(s)

 --1-not-2|--e1
	report objects in plugin1 that do not exist in plugin2

 --2-not-1|--e2
	report objects in plugin2 that do not exist in plugin1

 --equal|--eq
	report objects in plugin1 that are equal in plugin2

 --not-equal|--ne
	report objects in plugin1 that are different in plugin2

 Note: starred (*) options can be repeated.

DESCRIPTION:

Prints a report on the differences between the two TES3 files.
A summary report with up to four sections is printed to standard output
that gives an overview of differences, as lists of record IDs.
(Report sections that would have no items are not printed).

When objects in plugin1 are different in plugin2, each of these objects
is printed in detail to a file "plugin1.diff" and "plugin2.diff", which
can then be compared textually using a tool such as WinMerge or Emacs'
ediff function.

To reduce a great deal of "uninteresting" differences when diffing savegames,
CELL.FRMR records are automatically ignored when the ModIndex is zero. (Note
that in this case, the ObjIndex appears to only be incremented by one).

EXAMPLES:

# Print report on differences between 2 savegames (output to diff.out):
tes3cmd diff "save1000.ess" "save2000.ess" > diff.out

# You can also use the --ignore-type switch to ignore further subfields in
# order to help reduce the amount of differences as in the following example.
# Report on differences, but ignore the subfields CREA.AIDT and CELL.ND3D:
tes3cmd diff --ignore-type crea.aidt --ignore-type cell.nd3d testa0000.ess testb0000.ess > diff.out

# Just print the records that differ
tes3cmd diff --not-equal "my plugin1.esp" plugin2.esp
};

our @opt_diff_ignore_type = ();
our $opt_diff_1_not_2;
our $opt_diff_2_not_1;
our $opt_diff_equal;
our $opt_diff_not_equal;
sub opts_diff {
    $_[0] && do { die $DIFF_USAGE; };
    GetOptions(@STDOPT,
	       'ignore-type=s@' => \@opt_diff_ignore_type,
	       '1-not-2|e1'       => \$opt_diff_1_not_2,
	       '2-not-1|e2'       => \$opt_diff_2_not_1,
	       'equal|eq'         => \$opt_diff_equal,
	       'not-equal|ne'     => \$opt_diff_not_equal)
	or die $DIFF_USAGE;

    unless ($opt_diff_1_not_2 or $opt_diff_2_not_1 or $opt_diff_equal or $opt_diff_not_equal) {
	$opt_diff_1_not_2 = $opt_diff_2_not_1 = $opt_diff_equal = $opt_diff_not_equal = 1;
    }
}

my $DUMP_USAGE = q{Usage: tes3cmd dump OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --canon
	dump in canonical format

 --cell-object-match <regex>
	when printing cells, only print the matching objects in the cell

 --cell-object-no-match <regex>
	when printing cells, only print the non-matching objects in the cell

 --exterior
	if record is CELL, only match if it is an Exterior

 --flag* <flag>
	only modify records with given flag. Flags may be given symbolically
	as: (deleted, persistent, ignored, blocked), or via their numeric
	values (i.e. persistent is 0x400).

 --id* <id-regex>
	only process records whose ids match regular expression pattern
	<id-regex>

 --interior
	if record is CELL, only match if it is an Interior

 --list
	only list the ids of the records to be dumped, instead of the entire record

 --match <regex>
	only process records that match given regular expression <regex>

 --no-banner
	do not print banner identifying the current plugin

 --no-match <regex>
	only process records that do not match given regular expression
	<regex>

 --raw <file>
	dump raw records to <file>, instead of as text

 --raw-with-header <file>
	dump raw records with an initial TES3 header record to <file>

 --separator <string>
	separate subrecords with given <string>. Normally subrecords are
	separated by line-breaks. You can use this option to change that so
	they are all printed on one line.

 --type* <record-type>
	only modify records with the given <record-type>

DESCRIPTION:

Dumps the plugin to stdout in text form for easy perusal. For large plugins,
the output can be voluminous.

Note: documentation for regular expressions:
  http://www.perl.com/doc/manual/html/pod/perlre.html

EXAMPLES:

# Dump all records from a plugin (this could generate a lot of output):
tes3cmd dump "my plugin.esp"

# Dump all records with IDs matching "foo":
tes3cmd dump --id foo "plugin.esp"

# Dump all the DIAL and INFO records from a plugin:
tes3cmd dump --type dial --type info "plugin.esp"

# Dump all cells from bradhia_v1_4.esp containing NPC named: "Maeve Jaste"
tes3cmd dump --type cell --match "NAME:.*maeve.jaste" "bradhia_v1_4.esp"
# Dump all records flagged as persistent and blocked (by flag value)
tes3cmd dump --flag persistent --flag 0x2000 "my plugin.esp"
};

our $opt_dump_raw;
our $opt_dump_raw_with_header;
our $opt_dump_canon = 0;
my $RAWOUT;
sub opts_dump {
    $_[0] && do { die $DUMP_USAGE; };
    GetOptions(@STDOPT,
	       'canon' => \$opt_dump_canon,
	       'cell-object-match=s',
	       'cell-object-no-match=s',
	       'exterior',
	       'flag=s@',
	       'id=s@',
	       'interior',
	       'list',
	       'match=s',
	       'no-banner|B',
	       'no-match|M=s',
	       'raw-with-header=s' => \$opt_dump_raw_with_header,
	       'raw=s' => \$opt_dump_raw,
	       'separator=s',
	       'type=s@')
	or die $DUMP_USAGE;

    $opt_dump_raw = $opt_dump_raw_with_header
	if ($opt_dump_raw_with_header);
    $RAWOUT = open_for_write($opt_dump_raw)
	if ($opt_dump_raw);
    print $RAWOUT make_header()
	if ($opt_dump_raw_with_header);
}

my $HEADER_USAGE = qq{Usage: tes3cmd header OPTIONS plugin...

OPTIONS:
 --debug
	turn on debug messages

 --author <author>
	set the Author field to <author>

 --description <desc>
	set the Description field to <desc>

 --multiline
	multi-line output for listing field contents

 --synchronize
	same as: --update-masters --update-record-count

 --update-masters
	updates master list to reflect new versions

 --update-record-count
	update record count in header

DESCRIPTION:

When no options are given, the author and description are printed.

Author and Description field values are normally replaced by the given string.
But if the string begins with a "+", the existing value is appended with the
new given value.

If a given value contains the string "\\n", it will be replaced by a CRLF.

Note:
 - the Author value should fit in $TES3::Record::HDR_AUTH_LENGTH bytes.
 - the Description value should fit in $TES3::Record::HDR_DESC_LENGTH bytes.

If the value supplied won't fit into the plugin header field, you will be
warned.

The --update-masters (or --synchronize) option will clear any warnings
Morrowind gives when it starts up that say: "One or more plugins could not
find the correct versions of the master files they depend on..."

EXAMPLES:

# Show the Author/Description fields for a plugin:
tes3cmd header "my plugin.esp"

# Set the Author field to "john.moonsugar":
tes3cmd header --author john.moonsugar "plugin.esp"

# Append " and friends" to the Author field:
tes3cmd header --author "+ and friends" "plugin.esp"

# Append a Version number to a plugin Description field:
tes3cmd header --description "+\\nVersion: 1.0" "plugin.esp"

# update header field for the number of records in the plugin (if incorrect)
# and sync the list of masters to the masters installed in "Data Files"
tes3cmd header --synchronize "my plugin.esp"
};

our $opt_header_author = '';
our $opt_header_description = '';
our $opt_header_multiline = 0;
our $opt_header_synchronize;
our $opt_header_update_masters;
our $opt_header_update_record_count = 0;
sub opts_header {
    $_[0] && do { die $HEADER_USAGE; };
    GetOptions(@STDOPT,
	       'author=s' => \$opt_header_author,
	       'description=s' => \$opt_header_description,
	       'multiline' => \$opt_header_multiline,
	       'synchronize' => \$opt_header_synchronize,
	       'update-masters' => \$opt_header_update_masters,
	       'update-record-count' => \$opt_header_update_record_count)
	or die $HEADER_USAGE;

    $opt_header_update_masters = $opt_header_update_record_count = 1
	if ($opt_header_synchronize);
}

my $RENAME_USAGE = q{Usage: tes3cmd rename OPTIONS RECTYPE.SUBTYPE FROM TO plugin...

OPTIONS:
 --debug
	turn on debug messages

 --exterior
	only rename if the record is an exterior CELL

 --interior
	only rename if the record is an interior CELL

 --report-only
	just list the records, do not rename them

 --window-size <size>
	set size of printable window for record contents printed with
	--report-only switch to <size>

DESCRIPTION:

This first form of the command renames all records of type RECTYPE, replacing
the Perl regular expression FROM with the value of TO (which may contain
backreferences). The rename only happens if the CELL.NAME subrecord matches
the given FROM regular expression.

tes3cmd rename --report-only RECTYPE.SUBTYPE plugin...

When the --report-only switch is given, records of the given type are only
listed. (You do not give a FROM or TO when using the --report-only option).

The original input file is renamed to a backup, and changes are output to the
original filename.

Note that when renaming scripts, you can use either SCPT.SCTX or SCPT.SCHD as
the RECTYPE.SUBTYPE parameter, and the script name is changed in both
subrecords.

Note: documentation for regular expressions:
  http://www.perl.com/doc/manual/html/pod/perlre.html

EXAMPLES:

# rename all exterior cells to the null string:
tes3cmd rename --exterior CELL.NAME ".*" "" "my plugin.esp"

# do a caseless comparison with the FROM pattern:
tes3cmd rename cell.name "(?i)pelagaid" "Pelagiad" "plugin.esp"
(This would rename any name that has the string "pelagaid" in it with any form
of capitalization, to "Pelagiad").

# The following command will swap the first and last name of all NPCs using
# substitution backreferences (a very powerful feature of regular expressions):
tes3cmd rename npc_.fnam "^(\S+)\s(\S+)$" "$2 $1" "plugin.esp"
(Note that on Linux you may need to use single-quotes instead of double-quotes).
};

my($RENAME_FROM, $RENAME_TO, $RENAME_TYPE, $RENAME_SUBTYPE);
my @ren_valid_types =
    qw(GMST.NAME CLAS.NAME CLAS.FNAM FACT.NAME FACT.FNAM RACE.NAME RACE.FNAM
       SOUN.NAME SOUN.FNAM REGN.NAME REGN.FNAM BSGN.NAME BSGN.FNAM STAT.NAME
       DOOR.NAME DOOR.FNAM MISC.NAME MISC.FNAM WEAP.NAME WEAP.FNAM CONT.NAME
       CONT.FNAM SPEL.NAME SPEL.FNAM CREA.NAME CREA.FNAM LIGH.NAME LIGH.FNAM
       ENCH.NAME NPC_.NAME NPC_.FNAM ARMO.NAME ARMO.FNAM CLOT.NAME CLOT.FNAM
       REPA.NAME REPA.FNAM ACTI.NAME ACTI.FNAM APPA.NAME APPA.FNAM LOCK.NAME
       LOCK.FNAM PROB.NAME PROB.FNAM INGR.NAME INGR.FNAM BOOK.NAME BOOK.FNAM
       ALCH.NAME ALCH.FNAM LEVI.NAME CELL.NAME DIAL.NAME SCPT.SCHD SCPT.SCTX);
my %VALID_TYPE = map { ($_,1) } @ren_valid_types;

our $opt_rename_interior = 0;
our $opt_rename_exterior = 0;
our $opt_rename_window_size = 38;
sub opts_rename {
    $_[0] && do { die $RENAME_USAGE; };
    GetOptions(@STDOPT,
	       'interior' => \$opt_rename_interior,
	       'exterior' => \$opt_rename_exterior,
	       'report-only',
	       'window-size=i' => \$opt_rename_window_size)
	or die $RENAME_USAGE;

    my $type = uc(shift(@ARGV)) or die "Missing required RECTYPE.SUBTYPE\n$RENAME_USAGE";
    die "Error: Invalid record type.subtype requested: $type\n\nI only know these:\n@ren_valid_types\n" unless ($VALID_TYPE{$type});
    ($RENAME_TYPE, $RENAME_SUBTYPE) = split(/\./, $type);

    unless ($opt_report_only) {
	defined($RENAME_FROM = shift(@ARGV)) or die "Missing required FROM\n$RENAME_USAGE";
	defined($RENAME_TO = shift(@ARGV)) or die "Missing required TO\n$RENAME_USAGE";
    }
}

sub opts_shell {
    GetOptions(@STDOPT) or
	die "Usage: tes3cmd -shell\n";
}

sub opts_wikiout {
    GetOptions(@STDOPT) or
	die "Usage: tes3cmd -wikiout\n";
}

our $opt_codectest_continue;
our @opt_codectest_excluded_type = ();
sub opts_codectest {
    GetOptions(@STDOPT,
	       'continue|c' => \$opt_codectest_continue,
	       'excluded-type|ignored-type|x=s@' => \@opt_codectest_excluded_type)
	or die "Usage: tes3cmd -codectest [--excluded-type|-x excluded_type]\n";
}

###UTILITIES

sub make_header {
    my($opt) = @_;
    my $hedr = pack("a4L/a*", 'HEDR',
		    pack("fLZ${TES3::Record::HDR_AUTH_LENGTH}Z${TES3::Record::HDR_DESC_LENGTH}L",
			 ($opt->{version} || 1.3),
			 ($opt->{ismaster} || 0),
			 ($opt->{author} || "tes3cmd"),
			 ($opt->{description} || "(generated)"),
			 ($opt->{nrecords} || 0)));
    my $tes3 = pack("a4LLLa*", 'TES3', length($hedr), (my $unk = 0), (my $flags = 0), $hedr);
    die("Invalid TES3 header definition has incorrect size.")
	unless (length($tes3) == MIN_TES3_PLUGIN_SIZE);
    return($tes3);
}

sub celldata {
    my($srh) = @_;
    my $data = $srh->{DATA}[0];
    my($flags, $fog_data) = unpack("Lx[L]f", $data);
    return(($flags & 1), $flags, $fog_data);
}

# is_interior($srh);
sub is_interior { unpack("L", $_[0]->{DATA}[0]) & 1 }

sub chop_nulls { unpack("Z*", $_[0]); }

sub allowed_cell_type {
    my($srl) = @_;
    return 1 unless ($opt_interior or $opt_exterior);
    my $data;
    foreach my $pair (@$srl) {
	my($type, $val) = @$pair;
	if ($type eq "DATA") {
	    $data = $val;
	    last;
	}
    }
    my($flags) = unpack("L", $data);
    if ($opt_interior) {
	return($flags & 1);	# is interior
    } else {
	return(not($flags & 1)); # is exterior
    }
}

###DATA DEFINITIONS

# these types are for records to be cleaned from plugins when duped from a master:
my @CLEAN_DUP_TYPES =
    qw(ACTI ALCH APPA ARMO BODY BOOK BSGN CELL CLAS CLOT CONT CREA DOOR ENCH
       FACT GLOB GMST INFO INGR LAND LEVC LEVI LIGH LOCK MGEF MISC NPC_
       PGRD PROB RACE REGN REPA SCPT SKIL SNDG SOUN SPEL SSCR STAT WEAP);

my %SUMMONED_CREATURES = map { $_, 1 }
    ('centurion_fire_dead',
     'wraith_sul_senipul',
     'ancestor_ghost_summon',
     'atronach_flame_summon',
     'atronach_frost_summon',
     'atronach_storm_summon',
     'bonelord_summon',
     'bonewalker_summon',
     'bonewalker_greater_summ',
     'centurion_sphere_summon',
     'clannfear_summon',
     'daedroth_summon',
     'dremora_summon',
     'golden saint_summon',
     'hunger_summon',
     'scamp_summon',
     'skeleton_summon',
     'ancestor_ghost_variner',
     'fabricant_summon',
     'bm_bear_black_summon',
     'bm_wolf_grey_summon',
     'bm_wolf_bone_summon');

# Evil GMSTs for Tribunal (values are hexencoded)
my %EVIL_TB =
    (scompanionshare => '5354525620436f6d70616e696f6e205368617265',
     scompanionwarningbuttonone => '53545256204c657420746865206d657263656e61727920717569742e',
     scompanionwarningbuttontwo => '535452562052657475726e20746f20436f6d70616e696f6e20536861726520646973706c61792e',
     scompanionwarningmessage => '5354525620596f7572206d657263656e61727920697320706f6f726572206e6f77207468616e207768656e20686520636f6e74726163746564207769746820796f752e2020596f7572206d657263656e6172792077696c6c207175697420696620796f7520646f206e6f7420676976652068696d20676f6c64206f7220676f6f647320746f206272696e67206869732050726f6669742056616c756520746f206120706f7369746976652076616c75652e',
     sdeletenote => '535452562044656c657465204e6f74653f',
     seffectsummonfabricant => '53545256207345666665637453756d6d6f6e466162726963616e74',
     slevitatedisabled => '53545256204c657669746174696f6e206d6167696320646f6573206e6f7420776f726b20686572652e',
     smagicfabricantid => '5354525620466162726963616e74',
     smaxsale => '53545256204d61782053616c65',
     sprofitvalue => '535452562050726f6669742056616c7565',
     steleportdisabled => '535452562054656c65706f72746174696f6e206d6167696320646f6573206e6f7420776f726b20686572652e',
     );

# Evil GMSTs for Bloodmoon (values are hexencoded)
my %EVIL_BM =
    (fcombatdistancewerewolfmod => '464c5456209a99993e',
     ffleedistance => '464c54562000803b45',
     fwerewolfacrobatics => '464c54562000001643',
     fwerewolfagility => '464c54562000001643',
     fwerewolfalchemy => '464c5456200000803f',
     fwerewolfalteration => '464c5456200000803f',
     fwerewolfarmorer => '464c5456200000803f',
     fwerewolfathletics => '464c54562000001643',
     fwerewolfaxe => '464c5456200000803f',
     fwerewolfblock => '464c5456200000803f',
     fwerewolfbluntweapon => '464c5456200000803f',
     fwerewolfconjuration => '464c5456200000803f',
     fwerewolfdestruction => '464c5456200000803f',
     fwerewolfenchant => '464c5456200000803f',
     fwerewolfendurance => '464c54562000001643',
     fwerewolffatigue => '464c5456200000c843',
     fwerewolfhandtohand => '464c5456200000c842',
     fwerewolfhealth => '464c54562000000040',
     fwerewolfheavyarmor => '464c5456200000803f',
     fwerewolfillusion => '464c5456200000803f',
     fwerewolfintellegence => '464c5456200000803f',
     fwerewolflightarmor => '464c5456200000803f',
     fwerewolflongblade => '464c5456200000803f',
     fwerewolfluck => '464c5456200000803f',
     fwerewolfmagicka => '464c5456200000c842',
     fwerewolfmarksman => '464c5456200000803f',
     fwerewolfmediumarmor => '464c5456200000803f',
     fwerewolfmerchantile => '464c5456200000803f',
     fwerewolfmysticism => '464c5456200000803f',
     fwerewolfpersonality => '464c5456200000803f',
     fwerewolfrestoration => '464c5456200000803f',
     fwerewolfrunmult => '464c5456200000c03f',
     fwerewolfsecurity => '464c5456200000803f',
     fwerewolfshortblade => '464c5456200000803f',
     fwerewolfsilverweapondamagemult => '464c5456200000c03f',
     fwerewolfsneak => '464c5456200000803f',
     fwerewolfspear => '464c5456200000803f',
     fwerewolfspeechcraft => '464c5456200000803f',
     fwerewolfspeed => '464c54562000001643',
     fwerewolfstrength => '464c54562000001643',
     fwerewolfunarmored => '464c5456200000c842',
     fwerewolfwillpower => '464c5456200000803f',
     iwerewolfbounty => '494e54562010270000',
     iwerewolffightmod => '494e54562064000000',
     iwerewolffleemod => '494e54562064000000',
     iwerewolfleveltoattack => '494e54562014000000',
     seditnote => '535452562045646974204e6f7465',
     seffectsummoncreature01 => '53545256207345666665637453756d6d6f6e43726561747572653031',
     seffectsummoncreature02 => '53545256207345666665637453756d6d6f6e43726561747572653032',
     seffectsummoncreature03 => '53545256207345666665637453756d6d6f6e43726561747572653033',
     seffectsummoncreature04 => '53545256207345666665637453756d6d6f6e43726561747572653034',
     seffectsummoncreature05 => '53545256207345666665637453756d6d6f6e43726561747572653035',
     smagiccreature01id => '5354525620734d61676963437265617475726530314944',
     smagiccreature02id => '5354525620734d61676963437265617475726530324944',
     smagiccreature03id => '5354525620734d61676963437265617475726530334944',
     smagiccreature04id => '5354525620734d61676963437265617475726530344944',
     smagiccreature05id => '5354525620734d61676963437265617475726530354944',
     swerewolfalarmmessage => '5354525620596f752068617665206265656e206465746563746564206368616e67696e672066726f6d20612077657265776f6c662073746174652e',
     swerewolfpopup => '535452562057657265776f6c66',
     swerewolfrefusal => '5354525620596f752063616e6e6f7420646f207468697320617320612077657265776f6c662e',
     swerewolfrestmessage => '5354525620596f752063616e6e6f74207265737420696e2077657265776f6c6620666f726d2e',
    );

my %INFO_SCVR_type =
    ('0' => "Nothing",
     '1' => "Function",
     '2' => "Global",
     '3' => "Local",
     '4' => "Journal",
     '5' => "Item",
     '6' => "Dead",
     '7' => "Not_ID",
     '8' => "Not_Faction",
     '9' => "Not_Class",
     'A' => "Not_Race",
     'B' => "Not_Cell",
     'C' => "Not_Local");

my %INFO_SCVR_cmp =
    ('0' => '=',
     '1' => '!=',
     '2' => '>',
     '3' => '>=',
     '4' => '<',
     '5' => '<=');

my %MAGIC_SCHOOL = (0 => "Alteration",
		    1 => "Conjuration",
		    2 => "Destruction",
		    3 => "Illusion",
		    4 => "Mysticism",
		    5 => "Restoration");

my %FACT_FLAGS = ("hidden_from_player" => 0x0001);

my @CREA_TYPE = qw(Creature Daedra Undead Humanoid);

my @SNDG_DATA = ("Left_Foot", "Right_Foot", "Swim_Left", "Swim_Right", "Moan", "Roar", "Scream", "Land");


# All record sub-types found in .esm/.esp/.ess
my @SUBRECTYPES =
    qw(AADT ACDT ACSC ACSL ACTN AIDT AI_E AI_F AI_T AI_W ALDT AMBI ANAM ANIS
       AODT APUD ASND AVFX BKDT BNAM BSND BVFX BYDT CHRD CLDT CNAM CNDT CRED
       CSHN CSND CSTN CTDT CVFX DATA DELE DESC DNAM DODT ENAM ENDT FADT FGTN
       FLAG FLTV FNAM FRMR GMDT HEDR HSND HVFX INAM INDX INTV IRDT ITEX KNAM
       LHDT LKDT LNAM LSHN LSTN LVCR MAPD MAPH MAST MCDT MEDT MNAM MODL MVRF
       NAM0 NAM1 NAM2 NAM3 NAM5 NAM8 NAM9 NAME ND3D NNAM NPCO NPCS NPDT ONAM
       PBDT PGRC PGRP PNAM PTEX QSTF QSTN QSTR RADT RGNN RIDT RNAM SCDT SCHD
       SCRD SCRI SCRS SCTX SCVR SKDT SLCS SLFD SLLD SLSD SNAM SPDT STPR STRV
       TEXT TGTN TNAM UNAM VCLR VHGT VNAM VNML VTEX WEAT WHGT WIDX WNAM WPDT
       XCHG XHLT XIDX XNAM XSCL XSOL YNAM ZNAM);

my %JUNKCELL_SUBTYPE = (NAME => 1, DATA => 1, RGNN => 1);

sub indent_result {
    my($str) = @_;
    $str =~ tr/\r//d;
    $str =~ s/\n/\n\t\t/g;
    return("\t\t$str");
}

sub dbg_word {
    my($longstr) = @_;
    my $len = length($longstr);
    if ($len != 4) {
	warn "dbg_word: expected length of 4, got $len\n";
	return;
    }
    sprintf(qq{[UNKNOWN_WORD: 0x%s (f:%0.2f) (L:%d) (S:%d S:%d) (C:%d C:%d C:%d C:%d)]},
	unpack("H*", $longstr), unpack("f", $longstr), unpack("L", $longstr), unpack("S2", $longstr), unpack("C4", $longstr));
}

sub decode_flags {
    my($flags, $flagdefs) = @_;
    my @list = ();
    while (my($name, $val) = each %$flagdefs) {
	next if (length($name) == 1);
	if ($flags & $val) {
	    $name =~ s/([[:alnum:]]+)/ucfirst($1)/ge;
	    push(@list, $name);
	}
    }
    my $flagstr = sprintf "0x%04x", $flags;
    return("$flagstr (" . join(", ", @list) . ")");
}

sub print_lookup {
    my($key, $hashref) = @_;
    return($hashref->{$key} || $key . "???");
}

###CODECS
# TBD - nuke all the old decoder/encoder stuff
my $DECODER_UNKNOWN = sub { return({ unknown => unpack("H*", $_[0])}, {}); };
my $ENCODER_UNKNOWN = sub { return(pack("H*", $_[0]->{unknown})); };
my %DECODE = ();
my %ENCODE = ();
my %RD = ();

sub flatten {
    my @newlist;
    push(@newlist, (ref eq 'ARRAY') ? flatten(@$_) : $_) foreach (@_);
    return(@newlist);
}

sub compile_def {
    my($purpose, @def) = @_;
    my $format = "";
    my @keys;
    my %key_n;
    my %idx;
    my $index = 0;
    foreach my $ref (@def) {
	my($key, $fmt) = @$ref;
	if (ref($fmt) eq 'ARRAY') {
	    $format .= ($purpose eq 'decode') ? $fmt->[0] : $fmt->[1];
	} else {
	    $format .= $fmt;
	}
	foreach my $key (map { lc } flatten($key)) {
	    while (exists $idx{$key}) {
		$key =~ s/_\d+$//;
		$key .= '_' . $key_n{$key}++;
	    }
	    push(@keys, $key);
	    $idx{$key} = $index++;
	}
    }
    return($format, scalar(@keys), \@keys, \%idx);
}
sub default_decoder {
    my($type, @def) = @_;
    my($cdef, $nkeys, $keys) = compile_def('decode', @def);
    $RD{$type} = $cdef; # for transitional code
    my $decoder = sub {
	my($buff) = @_;
	my %hr;
	my @vals = unpack($cdef, $buff);
	my $nvals = scalar(@vals);
	die "Error in codec: nvals($nvals) != nkeys($nkeys)\n"
	    if ($nvals > $nkeys);
	foreach my $key (@$keys) {
	    my $val = shift(@vals);
	    $hr{$key} = $val;
	    last unless (@vals);
	}
	return(\%hr);
    };
    return($decoder);
};
sub default_encoder {
    my(@def) = @_;
    my($cdef, $nkeys, $keys, $idx) = compile_def('encode', @def);
    my $encoder = sub {
	my($hr) = @_;
	my @rec = ();
	while (my($key, $val) = each %$hr) {
	    $rec[$idx->{lc($key)}] = $val;
	}
	return(pack($cdef, @rec));
    };
    return($encoder);
};
sub default_codec {
    my($type, @def) = @_;
    $DECODE{$type} = default_decoder($type, @def);
    $ENCODE{$type} = default_encoder(@def);
}
default_codec('TES3.HEDR', (["Version", "f"],
			    ["Is_Master", "L"],
			    ["Author", ["Z32", "a32"]],
			    ["Description", ["Z256", "a256"]],
			    ["NRecords", "L"]));
default_codec('TES3.MAST', (["Master", "Z*"]));

# custom codec for TES3.DATA
$RD{'TES3.DATA'} = "L2";
$DECODE{'TES3.DATA'} = sub {
    my($buff) = @_;
    my($l1, $l2) = unpack("L2", $buff);
    return({ length => $l1 + ($l2 << 32) });
};
$ENCODE{'TES3.DATA'} = sub {
    my($hr) = @_;
    my $len = $hr->{length};
    my $l1 = $len & 0xffffffff;
    my $l2 = $len >> 32;
    return(pack("L2", $l1, $l2));
};

default_codec('ALCH.ALDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Autocalc", "L"]));
default_codec('ALCH.ENAM', (["Spell_Effect", "S"],
			    ["Skill", "c"],
			    ["Attribute", "C"],
			    ["Range", "L"],
			    ["Area", "L"],
			    ["Duration", "L"],
			    ["MagMin", "L"],
			    ["MagMax", "L"]));
default_codec('ALCH.TEXT', (["Text", ["Z*", "Z*"]]));
default_codec('APPA.AADT', (["Type", "L"],
			    ["Quality", "f"],
			    ["Weight", "f"],
			    ["Value", "L"]));
default_codec('ARMO.AODT', (["Type", "L"],
			    ["Weight", "f"],
			    ["Value", "L"],
			    ["Health", "L"],
			    ["Enchant_Points", "L"],
			    ["Armor_Rating", "L"]));
default_codec('ARMO.BNAM', (["Index", "Z*"]));
default_codec('ARMO.CNAM', (["Index", "Z*"]));
default_codec('ARMO.INDX', (["Index", "C"]));
default_codec('BODY.BYDT', (["Body_Part", "C"],
			    ["Vampire", "C"],
			    ["Flags", "C"],
			    ["Part_Type", "C"]));
default_codec('BOOK.BKDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Scroll", "L"],
			    ["Skill", "L"],
			    ["Enchant_Points", "L"]));
default_codec('CELL.AMBI', (["Ambient_Color", "L"],
			    ["Sunlight_Color", "L"],
			    ["Fog_Color", "L"],
			    ["Fog_Density", "f"]));
default_codec('CELL.CSTN', (["Target", "Z*"])); # guessing this is: "Cast/Current Spell Target Name"

# custom codec for CELL_DATA
$DECODE{'CELL.DATA'} = sub {
    my($buff) = @_;
    my $dlen = length($buff);
    if ($dlen == 24) {
	my($x, $y, $z, $xrot, $yrot, $zrot) = unpack("f6", $buff);
	return({ x => $x, y => $y, z => $z,
		 x_angle => $xrot, y_angle => $yrot, z_angle => $zrot });
    } elsif ($dlen == 12) {
	my($flags, $unk, $fog) = unpack("LLf", $buff);
	if ($flags & 0x01) { 	# Interior
	    return({ flags => $flags, unknown => $unk, fog_density => $fog });
	} else {		# Exterior
	    my($x, $y) = unpack("x[L]ll", $buff);
	    return({ flags => $flags, x => $x, y => $y });
	}
    } else {
	die "DECODER ERROR on CELL.DATA, Invalid length: $dlen\n";
    }
};
$ENCODE{'CELL.DATA'} = sub {
    my($hr) = @_;
    if (exists $hr->{flags}) {
	if ($hr->{flags} & 0x01) { # Interior
	    return(pack("LLf", $hr->{flags}, $hr->{unknown}, $hr->{fog_density}));
	} else {		     # Exterior
	    return(pack("Lll", $hr->{flags}, $hr->{x}, $hr->{y}));
	}
    } else {
	return(pack("f6", $hr->{x}, $hr->{y}, $hr->{z},
		    $hr->{x_angle}, $hr->{y_angle}, $hr->{z_angle}));
    }
};

default_codec('CELL.FRMR', (["ObjIdx", "S"],
			    ["Unknown_1", "C"],
			    ["ModIdx", "C"]));
default_codec('CELL.NAM5', (["R", "C"], # Map Color
			    ["G", "C"],
			    ["B", "C"],
			    ["Unused", "C"]));
default_codec('CELL.NAM9', (["Owner", "L"]));
default_codec('CLAS.CLDT', (["Primary_Attribute", "L"],
			    ["Secondary_Attribute", "L"],
			    ["Specialization", "L"],
			    [[("Minor_Skill_1", "Major_Skill_1") x 5], "(L2)5"],
			    ["Flags", "L"],
			    ["AutoCalc", "L"]));
default_codec('CLOT.BNAM', (["Index", "Z*"]));
default_codec('CLOT.CNAM', (["Index", "Z*"]));
default_codec('CLOT.CTDT', (["Type", "L"],
			    ["Weight", "f"],
			    ["Value", "S"],
			    ["Enchant_Points", "S"]));
default_codec('CLOT.INDX', (["Index", "C"]));
default_codec('CONT.CNDT', (["Weight", "f"]));
default_codec('CONT.FLAG', (["Container_Flags", "L"]));
default_codec('CREA.AI_W', (["Distance", "S"],
			    ["Duration", "C"],
			    ["Time_of_day", "C"],
			    [[("Idle_1") x 10], "C10"]));
#default_codec('CREA.AIDT', ([[("AI_1") x 12], "C12"]));
default_codec('CREA.AIDT', (["Hello", "C"],
			    ["Unknown_1", "C"],
			    ["Fight", "C"],
			    ["Flee", "C"],
			    ["Alarm", "C"],
			    ["Unknown_1", "a3"],
			    ["Flags", "L"]));
default_codec('CREA.FLAG', (["Flags", "L"]));
default_codec('CREA.NPDT', (["Type", "L"],
			    ["Lev", "L"],
			    ["Str", "L"],
			    ["Int", "L"],
			    ["Wil", "L"],
			    ["Agi", "L"],
			    ["Spd", "L"],
			    ["End", "L"],
			    ["Per", "L"],
			    ["Lck", "L"],
			    ["Health", "L"],
			    ["Spell_Points", "L"],
			    ["Fatigue", "L"],
			    ["Soul", "L"],
			    ["Combat", "L"],
			    ["Magic", "L"],
			    ["Stealth", "L"],
			    ["Attack_1_Min", "L"],
			    ["Attack_1_Max", "L"],
			    ["Attack_2_Min", "L"],
			    ["Attack_2_Max", "L"],
			    ["Attack_3_Min", "L"],
			    ["Attack_3_Max", "L"],
			    ["Gold", "L"]));
default_codec('DIAL.DATA', (["Type", "C"],
			   # ["Unused", "a3"]
			   ));
default_codec('ENCH.ENDT', (["Type", "L"],
			    ["Cost", "L"],
			    ["Charge", "L"],
			    ["Autocalc", "L"]));
default_codec('ENCH.ENAM', (["Spell_Effect", "S"],
			    ["Skill", "C"],
			    ["Attribute", "C"],
			    ["Range", "L"],
			    ["Area", "L"],
			    ["Duration", "L"],
			    ["MagMin", "L"],
			    ["MagMax", "L"]));
default_codec('FACT.ANAM', (["Contra_Faction", "Z*"]));
default_codec('FACT.RNAM', (["Rank", "a*"]));
default_codec('FACT.FADT', (["Primary_Attribute", "L"],
			    ["Secondary_Attribute", "L"],
			    [[("At1_1", "At2_1", "Sk1_1", "Sk2_1", "Fact_1") x 10], "(L5)10"],
			    [[("Sk_1") x 6], "L6"],
			    ["Unknown_1", "L"],
			    ["Flags", "L"]));
default_codec('GLOB.FNAM', (["VarType", "a"]));
default_codec('GMST.NAME', (["ID", "a*"]));
default_codec('GMST.STRV', (["string", "Z*"]));
default_codec('INFO.ACDT', (["Actor_Data", "Z*"])); # (only in .ess)
default_codec('INFO.INAM', (["ID", "Z*"]));
default_codec('INFO.DATA', (["Unknown_1", "L"],
			    ["Disposition", "L"],
			    ["Rank", "C"],
			    ["Sex", "C"],
			    ["PCRank", "C"],
			    ["Unknown_1", "C"]));
default_codec('INFO.ANAM', (["Cell", "Z*"]));
default_codec('INFO.BNAM', (["Result", "a*"]));
default_codec('INFO.CNAM', (["Class", "Z*"]));
default_codec('INFO.DNAM', (["PC_Faction", "Z*"]));
default_codec('INFO.FNAM', (["Faction", "Z*"]));
default_codec('INFO.NAME', (["Response", "a*"]));
default_codec('INFO.NNAM', (["Next_ID", "Z*"]));
default_codec('INFO.ONAM', (["Actor", "Z*"]));
default_codec('INFO.PNAM', (["Prev_ID", "Z*"]));
default_codec('INFO.RNAM', (["Race", "Z*"]));
default_codec('INFO.QSTN', (["Quest_Name", "C"]));
default_codec('INFO.QSTF', (["Quest_Finished", "C"]));
default_codec('INFO.QSTR', (["Quest_Restart", "C"]));
default_codec('INFO.SCVR', (["Index", "a"],
			    ["Type", "a"],
			    ["Function", "a2"],
			    ["Comparison", "a"],
			    ["Name", "a*"]));
default_codec('INGR.IRDT', (["Weight", "f"],
			    ["Value", "L"],
			    [[("Effect_1") x 4], "l4"],
			    [[("Skill_1") x 4], "l4"],
			    [[("Attribute_1") x 4], "l4"]));
default_codec('LAND.INTV', (["X", "l"],
			    ["Y", "l"]));
default_codec('LEVC.DATA', (["List_Flags", "L"]));
default_codec('LEVC.INDX', (["Item_Count", "L"]));
default_codec('LEVC.INTV', (["Level", "S"]));
default_codec('LEVC.CNAM', (["Creature_ID", "Z*"]));
default_codec('LEVC.NNAM', (["Chance_None", "C"]));
default_codec('LEVI.DATA', (["List_Flags", "L"]));
default_codec('LEVI.INDX', (["Item_Count", "L"]));
default_codec('LEVI.INTV', (["Level", "S"]));
default_codec('LEVI.INAM', (["Item_ID", "Z*"]));
default_codec('LEVI.NNAM', (["Chance_None", "C"]));
default_codec('LIGH.LHDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Time", "L"],
			    ["Radius", "L"],
			    ["Red", "C"],
			    ["Green", "C"],
			    ["Blue", "C"],
			    ["Unknown_1", "C"],
			    ["Flags", "L"]));
default_codec('LOCK.LKDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Quality", "f"],
			    ["Uses", "L"]));
default_codec('LTEX.DATA', (["Data", "Z*"]));
default_codec('MGEF.MEDT', (["School", "L"],
			    ["Base_Cost", "f"],
			    ["Flags", "L"],
			    ["Red", "L"],
			    ["Green", "L"],
			    ["Blue", "L"],
			    ["Speed", "f"],
			    ["Size", "f"],
			    ["SizeCap", "f"]));
default_codec('MISC.MCDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Unknown_1", "L"]));
default_codec('NPC_.CNDT', (["Data", "Z*"]));
default_codec('NPC_.FLAG', (["Flags", "L"]));
default_codec('NPC_.AIDT', (["Hello", "C"],
			    ["Unknown_1", "C"],
			    ["Fight", "C"],
			    ["Flee", "C"],
			    ["Alarm", "C"],
			    ["Unknown_1", "a3"],
			    ["Flags", "L"]));
default_codec('NPC_.AI_W', (["Distance", "S"],
			    ["Duration", "S"],
			    ["Time_of_day", "C"],
			    [[("Idle_1") x 8], "C8"],
			    ["Unknown_1", "C"]));

$DECODE{'NPC_.NPDT'} = sub {
    my($buff) = @_;
    my %hr;
    my $len = length($buff);
    if ($len == 12) {
	my($lev, $disp, $fact, $rank, $unk1, $unk2, $unk3, $gold) = unpack("SC6L", $_[0]);
	return({ level => $lev, disposition => $disp, faction => $fact, rank => $rank, unk1 => $unk1, unk2 => $unk2, unk3 => $unk3, gold => $gold });
    } elsif ($len == 52) {
	my $i = 0;
	my %hr;
	foreach my $skill_level (unpack("x[SC8]C27", $buff)) {
	    $hr{lc($SKILL{$i++})} = $skill_level;
	}
	($hr{level}, $hr{str}, $hr{int}, $hr{wil}, $hr{agi}, $hr{spd}, $hr{end},
	 $hr{per}, $hr{lck}, $hr{rep}, $hr{health}, $hr{magicka}, $hr{fatigue},
	 $hr{disposition}, $hr{faction}, $hr{rank}, $hr{gold}) = unpack("SC8x[C27]CSSSCCCxL", $buff);
	return(\%hr);
    } else {
	warn "BAD NPC_.NPDT length ($len) is not 12 or 52!\n";
    }
};
$ENCODE{'NPC_.NPDT'} = sub {
    my($hr) = @_;
    if (exists $hr->{magicka}) {
	return(pack("SC8C27CSSSCCCxL",
		    $hr->{level}, $hr->{str}, $hr->{int}, $hr->{wil}, $hr->{agi},
		    $hr->{spd}, $hr->{end}, $hr->{per}, $hr->{lck},
		    $hr->{"block"}, $hr->{"armorer"}, $hr->{"mediumarmor"}, $hr->{"heavyarmor"},
		    $hr->{"bluntweapon"}, $hr->{"longblade"}, $hr->{"axe"}, $hr->{"spear"},
		    $hr->{"athletics"}, $hr->{"enchant"}, $hr->{"destruction"}, $hr->{"alteration"},
		    $hr->{"illusion"}, $hr->{"conjuration"}, $hr->{"mysticism"}, $hr->{"restoration"},
		    $hr->{"alchemy"}, $hr->{"unarmored"}, $hr->{"security"}, $hr->{"sneak"},
		    $hr->{"acrobatics"}, $hr->{"lightarmor"}, $hr->{"shortblade"}, $hr->{"marksman"},
		    $hr->{"mercantile"}, $hr->{"speechcraft"}, $hr->{"handtohand"},
		    $hr->{rep}, $hr->{health}, $hr->{magicka}, $hr->{fatigue},
		    $hr->{disposition}, $hr->{faction}, $hr->{rank}, $hr->{gold}));
    } else {
	return(pack("SC6L", $hr->{level}, $hr->{disposition}, $hr->{faction}, $hr->{rank}, $hr->{unk1}, $hr->{unk2}, $hr->{unk3},  $hr->{gold}));
    }
};

#     "PCDT.SNAM" => $TOSTR_UNKNOWN, # .ess
#     "PCDT.ENAM" => $TOSTR_UNKNOWN, # .ess
#     "PCDT.FNAM" => $TOSTR_UNKNOWN, # .ess

default_codec('PROB.PBDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Quality", "f"],
			    ["Uses", "L"]));
default_codec('QUES.DATA', (["Info_ID", "Z*"])); # only in .ess (relates back to Actor in INFO)
default_codec('RACE.RADT', ([[("Skill_1", "Bonus_1") x 7], "(L2)7"],
			    [[("Attr_Male_1", "Attr_Female_1") x 8], "(L2)8"],
			    ["Male_Height", "f"],
			    ["Female_Height", "f"],
			    ["Male_Weight", "f"],
			    ["Female_Weight", "f"],
			    ["Flags", "L"]));
# REFR.ACDT (player Actor Data)
##(Not present???: Burden, Detect Animal, Detect Ench., Light, Night Eye, Slowfall, Telekinesis)
#----------------------------------------------------------- Offset
default_codec('REFR.ACDT', ([[("Unknown_1") x 10], "L10"],   #   0
			    ["Health", "f"],		     #  40
			    ["Max_Health", "f"],	     #  44
			    ["Fatigue", "f"],		     #  48
			    ["Max_Fatigue", "f"],	     #  52
			    ["Unknown_1", "f"],		     #  56
			    ["Unknown_1", "f"],		     #  60
			    ["Unknown_1", "f"],		     #  64
			    ["Unknown_1", "f"],		     #  68
			    ["Unknown_1", "f"],		     #  72
			    ["Encumbrance", "f"],	     #  76
			    ["STR", "f"],		     #  80
			    ["STR_Base", "f"],		     #  84
			    ["INT", "f"],		     #  88
			    ["INT_Base", "f"],		     #  92
			    ["WIL", "f"],		     #  96
			    ["WIL_Base", "f"],		     # 100
			    ["AGI", "f"],		     # 104
			    ["AGI_Base", "f"],		     # 108
			    ["SPD", "f"],		     # 112
			    ["SPD_Base", "f"],		     # 116
			    ["END", "f"],		     # 120
			    ["END_Base", "f"],		     # 124
			    ["PER", "f"],		     # 128
			    ["PER_Base", "f"],		     # 132
			    ["LUC", "f"],		     # 136
			    ["LUC_Base", "f"],		     # 140
			    ["Fortify_Attack", "L"],	     # 144
			    ["Sanctuary", "L"],		     # 148
			    ["Resist_Magicka", "C"],	     # 152
			    ["Unknown_1", "a3"],
			    ["Resist_Fire", "C"],            # 156 (+ Fire Shield)
			    ["Unknown_1", "a3"],
			    ["Resist_Frost", "C"],           # 160 (+ Frost Shield)
			    ["Unknown_1", "a3"],
			    ["Resist_Shock", "C"],	     # 164 (+ Lightning Shield)
			    ["Unknown_1", "a3"],
			    ["Resist_Common_Disease", "L"],  # 168
			    ["Unknown_1", "L"],		     # 172
			    ["Unknown_1", "L"],		     # 176
			    ["Resist_Poison", "L"],	     # 180
			    ["Resist_Paralysis", "L"],	     # 184
			    ["Chameleon", "L"],		     # 188
			    ["Resist_Normal_Weapons", "L"],  # 192
			    ["Water_Breathing", "L"],	     # 196
			    ["Water_Walking", "L"],	     # 200
			    ["Swift_Swim", "L"],	     # 204
			    ["Unknown_1", "L"],		     # 208
			    ["Levitate", "L"],		     # 212
			    ["Shield", "L"],		     # 216
			    ["Unknown_1", "L"],		     # 220
			    ["Unknown_1", "L"],		     # 224
			    ["Blind", "L"],		     # 228
			    ["Unknown_1", "L"],		     # 232
			    ["Invisibility", "L"],	     # 236
			    ["unknown", "L"],		     # 240
			    ["Unknown_1", "L"],		     # 244
			    ["Unknown_1", "L"],		     # 248
			    ["Unknown_1", "L"],		     # 252
			    ["Unknown_1", "L"],		     # 256
			    ["Unknown_1", "L"]));	     # 260
default_codec("REFR.WNAM", (["Readied_Spell", "Z*"]));
default_codec('REGN.WEAT', (["Clear", "C"],
			    ["Cloudy", "C"],
			    ["Foggy", "C"],
			    ["Overcast", "C"],
			    ["Rain", "C"],
			    ["Thunder", "C"],
			    ["Ash", "C"],
			    ["Blight", "C"],
			    ["Snow", "C"], # Bloodmoon
			    ["blizzard", "C"])); # Bloodmoon
default_codec('REGN.CNAM', (["Red", "C"],
			    ["Green", "C"],
			    ["Blue", "C"],
			    ["Unused", "C"]));
default_codec('REGN.SNAM', (["Sound_Name", ["Z32", "a32"]],
			    ["Chance", "C"]));
default_codec('REGN.WNAM', (["Name", "L"]));
default_codec('REPA.RIDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Uses", "L"],
			    ["Quality", "f"]));
default_codec('SCPT.RNAM', (["Unknown_1", "L"]));
default_codec('SCPT.SCDT', (["Bytecode", "H*"]));
default_codec('SCPT.SCHD', (["ID", ["Z32", "a32"]],
			    ["Num_Shorts", "L"],
			    ["Num_Longs", "L"],
			    ["Num_Floats", "L"],
			    ["Data_Size", "L"],
			    ["Local_Var_Size", "L"]));
default_codec('SCPT.SCVR', (["Variables", "a*"]));
default_codec('SCPT.SCTX', (["Script", "a*"]));
default_codec('SKIL.SKDT', (["Attribute", "L"],
			    ["Specialization", "L"],
			    [[("Use_Values_1") x 4], "f4"]));
default_codec('SNDG.DATA', (["Data", "L"]));
default_codec('SPEL.SPDT', (["Type", "L"],
			    ["Cost", "L"],
			    ["Flags", "L"]));
default_codec('SPLM.NAME', (["ID", "L"]));
default_codec('SPLM.SPDT', (["Type", "L"],
			    ["Name", ["Z40", "a40"]],
			    [[("Long_1") x 2], "L2"],
			    ["Caster", ["Z32", "a32"]],
			    ["Item", "Z*"]));
default_codec('SPLM.NPDT', (["Name", ["Z40", "a40"]],
			    ["Magnitude", "l"],
			    ["Seconds_Active", "f"],
			    [[("Long_1") x 2], "l2"]));
default_codec('SPLM.XNAM', (["Name", "L"]));
default_codec('SPLM.TNAM', (["Target", "Z*"]));
default_codec('SOUN.DATA', (["Volume", "C"],
			    ["MinRange", "C"],
			    ["MaxRange", "C"]));
default_codec('SSCR.DATA', (["Name", "a*"]));
default_codec('SSCR.NAME', (["Name", "Z*"]));
default_codec('STLN.ONAM', (["Name", "Z*"]));
default_codec('WEAP.WPDT', (["Weight", "f"],
			    ["Value", "L"],
			    ["Type", "S"],
			    ["Health", "S"],
			    ["Speed", "f"],
			    ["Reach", "f"],
			    ["Enchant_Points", "S"],
			    ["Chop_Min", "C"],
			    ["Chop_Max", "C"],
			    ["Slash_Min", "C"],
			    ["Slash_Max", "C"],
			    ["Thrust_Min", "C"],
			    ["Thrust_Max", "C"],
			    ["Flags", "L"]));
default_codec('VFXM.VNAM', ([[("Long_1") x 6], "(a4)6"],
			    ["Short", "S"],
			    ["Unknown_1", "a22"],
			    ["Name_2", ["Z36", "a36"]],
			    ["Name_3", ["Z68", "a68"]]));
default_codec('DELE', (["Unknown_1", "L"]));
default_codec('DODT', (["X", "f"],
		       ["Y", "f"],
		       ["Z", "f"],
		       ["Angle_X", "f"],
		       ["Angle_Y", "f"],
		       ["Angle_Z", "f"]));
default_codec('FLAG', (["Flags", "L"]));
default_codec('NPCO', (["Count", "l"],
		       ["Name", ["Z32", "a32"]]));
default_codec('NPCS', (["String", ["Z32", "a32"]]));
default_codec('XCHG', (["Enchant_Charge", "L"]));
default_codec('XHLT', (["Health", "L"]));
default_codec('XSCL', (["Scale", "f"]));
default_codec('XSOL', (["Soul", "Z*"]));
default_codec('WIDX', (["Equipped_Index", "l"],
		       ["Ammo_Flag", "l"]));
default_codec('SLCS', (["Shorts", "L"],
		       ["Longs", "L"],
		       ["Floats", "L"]));

$DECODE{'SLSD'} = \&unpack_short_array;
$ENCODE{'SLSD'} = \&pack_short_array;
$DECODE{'SLLD'} = \&unpack_long_array;
$ENCODE{'SLLD'} = \&pack_long_array;
$DECODE{'SLFD'} = \&unpack_float_array;
$ENCODE{'SLFD'} = \&pack_float_array;

$DECODE{"SPEL.ENAM"} = $DECODE{"ENCH.ENAM"};
$ENCODE{"SPEL.ENAM"} = $ENCODE{"ENCH.ENAM"};

# subrecords that decode as signed 32-bit longs:
foreach (qw(INTV)) {
    $DECODE{$_} = sub{ { long => unpack("l", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("l", $_[0]->{long} );
    };
}

# subrecords that decode as unsigned 32-bit longs:
foreach (qw(INDX NAM0 XIDX)) {
    $DECODE{$_} = sub{ { long => unpack("L", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("L", $_[0]->{long} ); };
}

# subrecords that decode as 32-bit floats:
foreach (qw(FLTV WHGT)) {
    $DECODE{$_} = sub{ { float => unpack("f", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("f", $_[0]->{float} ); };
}

# for the standard "NAME == ID" objects:
$DECODE{NAME} = sub{ { id => unpack("Z*", $_[0]) }; };
$ENCODE{NAME} = sub{ pack("Z*", $_[0]->{id} ); };

# subrecords that decode as variable length Z strings:
foreach (qw(ANAM ASND AVFX BNAM BSND BVFX CNAM CSND CVFX DNAM ENAM FNAM HSND HVFX ITEX KNAM MODL PTEX RGNN RNAM SNAM SCRI TNAM)) {
    $DECODE{$_} = sub{ { string => unpack("Z*", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("Z*", $_[0]->{string} ); };
}

# subrecords that decode as variable length Z strings, encode as a:
foreach (qw(FGTN LSHN LSTN MNAM SCIP SCPT STRV
TEXT TGTN)) {
    $DECODE{$_} = sub{ { string => unpack("Z*", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("a*", $_[0]->{string} ); };
}

# subrecords that decode as variable length a strings, encode as a:
foreach (qw(DESC WNAM)) {
    $DECODE{$_} = sub{ { string => unpack("a*", $_[0]) }; };
    $ENCODE{$_} = sub{ pack("a*", $_[0]->{string} ); };
}



###PRETTY PRINTER

# TBD - nuke all the old TOSTR stuff
my $TOSTR_UNK =
    sub { my $buff = $_[0];
	  sprintf qq{len:%d  hex:%s  str:"%s"}, length($buff),
	      unpack("H*", $buff), substr((($_ = $buff) =~ tr/\000-\037\177-\377//d, $_), 0, 60) };
my $TOSTR_DEBUG = sub { sprintf qq{DEBUG %s}, $TOSTR_UNK->($_[0]); };

my $NREC;

# TBD - nuke
my %TOSTR =
    ("TES3.HEDR" => sub { my($ver, $is_master, $auth, $desc, $nrec) = unpack($RD{'TES3.HEDR'}, $_[0]);
			  $NREC = $nrec; # save it for later.
			  ($ver = sprintf("%0.2f", $ver)) =~ s/0+$//;
			  sprintf qq{\tVersion:$ver  Is_Master:%s\tAuthor:"$auth"\n\tDescription:"$desc"\n\tNRecords:$NREC},
			      ($is_master) ? "True" : "False"; },
     "TES3.MAST" => sub { unpack($RD{'TES3.MAST'}, $_[0]) },
     "TES3.DATA" => sub { my($l1, $l2) = unpack($RD{'TES3.DATA'}, $_[0]);
			  my $size = $l1 + ($l2 << 32);
			  "Length:     $size"; },
     "ALCH.ALDT" => sub { sprintf "Weight: %0.2f  Value: %d  Autocalc: %d", unpack($RD{'ALCH.ALDT'}, $_[0]) },
     "APPA.AADT" => sub { my($type, $qual, $wght, $val) = unpack($RD{'APPA.AADT'}, $_[0]);
			  sprintf "Type: %s  Quality: %0.2f  Weight: %0.2f  Value: %d",
			      $APPARATUS_TYPE{$type}, $qual, $wght, $val },
     "ARMO.AODT" => sub { my($type, $wght, $value, $health, $epts, $armor) = unpack($RD{'ARMO.AODT'}, $_[0]);
			  sprintf "Type: %s  Weight: %0.2f  Value: %d  Health %d  Enchant_Points: %d  ArmorRating: %d",
			      $ARMOR_TYPE{$type}, $wght, $value, $health, $epts, $armor},
     "ARMO.INDX" => sub { $ARMOR_INDEX{unpack($RD{'ARMO.INDX'}, $_[0])} },
     "BODY.BYDT" => sub { my($part, $vamp, $flags, $ptype) = unpack($RD{'BODY.BYDT'}, $_[0]);
			  sprintf "Bodypart: %s  Vampire: %d  Flag: %s  PartType: %s",
			      $BYDT_PART{$part}, $vamp, print_lookup($flags, \%BYDT_FLAGS), $BYDT_PTYP{$ptype}
		      },
     "BOOK.BKDT" => sub { my($wght, $val, $scrl, $skil, $epts) = unpack($RD{'BOOK.BKDT'}, $_[0]);
			  sprintf "Weight: %0.2f  Value: %d  Scroll: %s  Skill: %d  Enchant_Points: %d",
			      $wght, $val, (1 == $scrl) ? "Yes" : "No", $skil, $epts },
     "CELL.AMBI" => sub { sprintf("Ambient Color: 0x%08x  Sunlight Color: 0x%08x  Fog Color: 0x%08x  Fog Density: %0.2f",
				unpack($RD{'CELL.AMBI'}, $_[0])); },
     "CELL.CSTN" => sub { sprintf "Target: %s", unpack($RD{'CELL.CSTN'}, $_[0]); },
     "CELL.DATA" => sub {
	 if (length($_[0]) == 24) {
	     sprintf("Position x: %0.2f y: %0.2f z: %0.2f   Angle x: %0.2f y: %0.2f z: %0.2f", unpack("f6", $_[0]));
	 } else {
	     my($flags, $unkbuf, $fog_den_data) = unpack("La4f", $_[0]);
	     my @flags = ();
	     my $coord = '';
	     my $data_fog_str = '';
	     my $unk_str = '';
	     if ($flags & 0x01) {
		 push(@flags, "Interior");
		 $data_fog_str = sprintf "FogDensity: %0.2f ", $fog_den_data;
		 $unk_str = sprintf "Unk:0x%s ", unpack("H*", $unkbuf);
	     } else {
		 push(@flags, "Exterior");
		 my($x, $y) = unpack("x[L]ll", $_[0]);
		 $coord = "Coordinates: ($x, $y) ";
	     }
	     my $flags_str = "Flags: " . decode_flags($flags, \%CELL_FLAGS);
	     $coord . $data_fog_str . $unk_str . $flags_str;
	 }
     },
     "CELL.FRMR" => sub { sprintf "ObjIdx: %d Unk: %d ModIdx: %d", unpack($RD{'CELL.FRMR'}, $_[0]); },
     "CELL.NAM5" => sub { sprintf "Map_Color_RGB: (%x, %x, %x)", unpack($RD{'CELL.NAM5'}, $_[0]) },
     "CELL.NAM9" => sub { my $val = unpack($RD{'CELL.NAM9'}, $_[0]); (1 == $val) ? "Owner" : "Unk:$val"; },
     "CLAS.CLDT" => sub { my($attr1, $attr2, $spec, $min1, $maj1, $min2, $maj2, $min3, $maj3, $min4, $maj4, $min5, $maj5, $flags, $autoflags) =
			      unpack($RD{'CLAS.CLDT'}, $_[0]);
			  "  " . join("\n\t\t",
				      "Primary Attribute:   $ATTRIBUTE{$attr1}",
				      "Secondary Attribute: $ATTRIBUTE{$attr2}",
				      "Specialization: $SPECIALIZATION{$spec}",
				      "Major-Skill-1: $SKILL{$maj1}",
				      "Major-Skill-2: $SKILL{$maj2}",
				      "Major-Skill-3: $SKILL{$maj3}",
				      "Major-Skill-4: $SKILL{$maj4}",
				      "Major-Skill-5: $SKILL{$maj5}",
				      "Minor-Skill-1: $SKILL{$min1}",
				      "Minor-Skill-2: $SKILL{$min2}",
				      "Minor-Skill-3: $SKILL{$min3}",
				      "Minor-Skill-4: $SKILL{$min4}",
				      "Minor-Skill-5: $SKILL{$min5}",
				      "Flags: " . (($flags) ? "Playable" : "Non-playable"),
				      "AutoCalc Flags: " . decode_flags($autoflags, \%AUTOCALC_FLAGS));
		      },
     "CLOT.CTDT" => sub { my($type, $wght, $value, $epts) = unpack($RD{'CLOT.CTDT'}, $_[0]);
			  sprintf "Type: %s  Weight: %0.2f  Value: %d  Enchant_Points: %d",
			      $CTDT_TYPE{$type}, $wght, $value, $epts },
     "CLOT.INDX" => sub { unpack($RD{'CLOT.INDX'}, $_[0]) },
     "CONT.CNDT" => sub { sprintf "Weight: %0.2f", unpack($RD{'CONT.CNDT'}, $_[0]) },
     "CONT.FLAG" => sub { decode_flags(unpack($RD{'CONT.FLAG'}, $_[0]), \%CONTAINER_FLAGS) },
     "CREA.AI_W" => sub { my($hr) = $DECODE{'CREA.AI_W'}->($_[0]);
			  my $idle = join(", ", map { $hr->{"idle_$_"} } 1..10);
			  sprintf "Distance: %d  Duration: %d  Time_of_day: %d, Idles: $idle",
			      $hr->{distance}, $hr->{duration}, $hr->{time_of_day} },
#     "CREA.AIDT" => sub { join(", ", unpack($RD{'CREA.AIDT'}, $_[0])) },
     "CREA.AIDT" => sub { my($hello, $unk1, $fight, $flee, $alarm, $unk2, $unk3, $unk4, $flags) = unpack($RD{'NPC_.AIDT'}, $_[0]);
			  sprintf "Hello: %d  Fight: %d  Flee: %d  Alarm: %d  Flags: %s",
			      $hello, $fight, $flee, $alarm, decode_flags($flags, \%AIDT_FLAGS); },
     "CREA.FLAG" => sub { decode_flags(unpack($RD{'CREA.FLAG'}, $_[0]), \%CREATURE_FLAGS) },
     "CREA.NPDT" => sub { my($typ_i, $lev, $str, $int, $wil, $agi, $spd, $end, $per, $lck,
			     $hlth, $spelpts, $fat, $soul, $comb, $mag, $stlth,
			     $atkmin1, $atkmax1, $atkmin2, $atkmax2, $atkmin3, $atkmax3, $gold) = unpack($RD{'CREA.NPDT'}, $_[0]);
			  sprintf "Type: %s  Lev: %d  Str: %d  Int: %d  Wil: %d  Agi: %d  Spd: %d  End: %d  Per: %d  Lck: %d\n\t\tHealth: %d  Magicka: %d  Fatigue: %d  Soul: %d  Combat: %d  Magic: %d  Stealth: %d\n\t\tAttack-1 (%d, %d)  Attack-2: (%d, %d)  Attack-3 (%d, %d)  Gold: %d",
			      $CREA_TYPE[$typ_i], $lev, $str, $int, $wil, $agi, $spd, $end, $per, $lck,
				  $hlth, $spelpts, $fat, $soul, $comb, $mag, $stlth,
				      $atkmin1, $atkmax1, $atkmin2, $atkmax2, $atkmin3, $atkmax3, $gold;
		      },
     "DIAL.DATA" => sub { $DIALTYPE = $DIAL_TYPE{unpack($RD{'DIAL.DATA'}, $_[0])}; },
     "ENCH.ENDT" => sub { my($type, $cost, $chrg, $auto) = unpack($RD{'ENCH.ENDT'}, $_[0]);
		      sprintf "Type: %s  Cost: %d  Charge: %d  Autocalc: %d", $ENCHANT_TYPE{$type}, $cost, $chrg, $auto },
     "ENCH.ENAM" => sub { my($effect, $skill, $attr, $range, $area, $dur, $mmin, $mmax) = unpack($RD{'ENCH.ENAM'}, $_[0]);
			  my $spell = $SPELL_EFFECT{$effect};
			  if ($spell =~ /_attribute$/i) {
			      $spell .= "/$ATTRIBUTE{$attr}";
			  } elsif ($spell =~ /_skill$/i) {
			      $spell .= "/$SKILL{$skill}";
			  }
			  sprintf "%-28s  Range: %s  Area: %3d  Duration: %3d  MagMin: %4d  MagMax: %4d",
			      $spell, $RANGE_TYPE{$range}, $area, $dur, $mmin, $mmax },
     "FACT.FADT" => sub { my($attr1, $attr2, $rankdata, $skills, $unk, $flags) = unpack("LLa200a24LL", $_[0]);
			  my(@results) = sprintf "Attribute_1: %s  Attribute_2: %s  Unk:0x%x  Flags: %s",
			      $ATTRIBUTE{$attr1}, $ATTRIBUTE{$attr2}, $unk, decode_flags($flags, \%FACT_FLAGS);
			  push(@results, "\t\tFavored_Skills: " . join(", ", map { $SKILL{$_} } unpack("L6", $skills)));
			  foreach my $rd (unpack("(a20)10", $rankdata)) {
			      my($at1, $at2, $sk1, $sk2, $fact) = unpack("L5", $rd);
			      push(@results, sprintf "\t\tAttr_1: %3d  Attr_2: %3d  Skill_1: %3d  Skill_2: %3d  Fact: %3d",
				  $at1, $at2, $sk1, $sk2, $fact);
			  }
			  join("\n", @results);
		      },
     "INFO.ACDT" => sub { unpack($RD{'INFO.ACDT'}, $_[0]) }, # Actor Data? (only in .ess)
     "INFO.INAM" => sub { unpack($RD{'INFO.INAM'}, $_[0]) },
     "INFO.DATA" => sub { my($disp, $rank, $sex, $pcrank) = unpack($RD{'INFO.DATA'}, $_[0]);
			  $rank = "None" if $rank == 255;
			  $pcrank = "None" if $pcrank == 255;
			  if ($DIALTYPE eq "Journal") {
			      "JournalIndex: $disp";
			  } else {
			      "Disp:$disp  Rank:$rank  Sex:$SEX{$sex}  PCRank:$pcrank";
			  }},
     "INFO.ANAM" => sub { sprintf qq{Cell:       "%s"}, unpack($RD{'INFO.ANAM'}, $_[0]) },
     "INFO.BNAM" => sub { sprintf qq{Result:\n%s}, indent_result(unpack($RD{'INFO.BNAM'}, $_[0])) },
     "INFO.CNAM" => sub { sprintf qq{Class:      "%s"}, unpack($RD{'INFO.CNAM'}, $_[0]) },
     "INFO.DNAM" => sub { sprintf qq{PC Faction: "%s"}, unpack($RD{'INFO.DNAM'}, $_[0]) },
     "INFO.FNAM" => sub { sprintf qq{Faction:    "%s"}, unpack($RD{'INFO.FNAM'}, $_[0]) },
     "INFO.NAME" => sub { my $str = unpack($RD{'INFO.NAME'}, $_[0]); $str =~ tr/\r//d; sprintf qq{Response:   "%s"}, $str },
     "INFO.NNAM" => sub { sprintf qq{Next ID:    "%s"}, unpack($RD{'INFO.NNAM'}, $_[0]) },
     "INFO.ONAM" => sub { sprintf qq{Actor:      "%s"}, unpack($RD{'INFO.ONAM'}, $_[0]) },
     "INFO.PNAM" => sub { sprintf qq{Prev ID:    "%s"}, unpack($RD{'INFO.PNAM'}, $_[0]) },
     "INFO.RNAM" => sub { sprintf qq{Race:       "%s"}, unpack($RD{'INFO.RNAM'}, $_[0]) },
     "INFO.QSTN" => sub { my $val = unpack($RD{'INFO.QSTN'}, $_[0]);
			  (1 == $val) ? "Quest_Name" : "Unknown($val)" },
     "INFO.QSTF" => sub { my $val = unpack($RD{'INFO.QSTF'}, $_[0]);
			  (1 == $val) ? "Quest_Finished" : "Unknown($val)" },
     "INFO.QSTR" => sub { my $val = unpack($RD{'INFO.QSTR'}, $_[0]);
			  (1 == $val) ? "Quest_Restart" : "Unknown($val)" },
     "INFO.SCVR" => sub { my($idx, $typ, $fun, $cmp, $nam) = unpack($RD{'INFO.SCVR'}, $_[0]);
			  my $name = ($typ == 1) ? "" : "  Name:$nam";
			  sprintf "Index:$idx  Type:%s  Fun:%s  Cmp:%s$name",
			      print_lookup($typ, \%INFO_SCVR_type), print_lookup($fun, \%INFO_FUN), print_lookup($cmp, \%INFO_SCVR_cmp); },
     "INGR.IRDT" => sub { my($hr) = $DECODE{'INGR.IRDT'}->($_[0]);
			  my $result = sprintf "Weight: %0.2f  Value: %d  Effects: ",
			      $hr->{weight}, $hr->{value};
			  my @results;
			  foreach my $i (1..4) {
			      if ($hr->{"effect_$i"} != -1) {
				  my $eix = $hr->{"effect_$i"};
				  my $effect = $SPELL_EFFECT{$eix} || "${eix}???";
				  if ($effect =~ /_attribute$/i) {
				      push(@results, qq{$effect/$ATTRIBUTE{$hr->{"attribute_$i"}}}); # $attrs[$i]
				  } elsif ($effect =~ /_skill$/i) {
				      push(@results, qq{$effect/$SKILL{$hr->{"skill_$i"}}}); # $skills[$i]
				  } else {
				      push(@results, "$effect");
				  }
			      }
			  }
			  $result . join(", ", @results);
		      },
     "LAND.INTV" => sub { sprintf qq{Coordinates: (%d, %d)}, unpack($RD{'LAND.INTV'}, $_[0]) },
     "LEVC.DATA" => sub { "List_Flags: %d (1 = Calc from all levels <= PC level)", unpack($RD{'LEVC.DATA'}, $_[0]) },
     "LEVC.INTV" => sub { sprintf "Level: %d", unpack($RD{'LEVC.INTV'}, $_[0]) },
     "LEVC.NNAM" => sub { sprintf "ChanceNone: %d", unpack($RD{'LEVC.NNAM'}, $_[0]) },
     "LEVI.DATA" => sub { "List_Flags: " . decode_flags(unpack($RD{'LEVI.DATA'}, $_[0]), \%LEVI_FLAGS) },
     "LEVI.INTV" => sub { sprintf "Level: %d", unpack($RD{'LEVI.INTV'}, $_[0]) },
     "LEVI.INAM" => sub { unpack($RD{'LEVI.INAM'}, $_[0]) },
     "LEVI.NNAM" => sub { sprintf "ChanceNone: %d", unpack($RD{'LEVI.NNAM'}, $_[0]) },
     "LIGH.LHDT" => sub { my($wght, $value, $time, $radius, $red, $green, $blue, $null, $flags) = unpack($RD{'LIGH.LHDT'}, $_[0]);
			  sprintf "Weight: %0.2f  Value: %d  Time: %d  Radius: %d  RGB: (%x, %x, %x)  Flags: %s",
			      $wght, $value, $time, $radius, $red, $green, $blue, decode_flags($flags, \%LHDT_FLAGS) },
     "LOCK.LKDT" => sub { sprintf "Weight: %0.2f  Value: %d  Quality: %0.2f  Uses: %d", unpack($RD{'LOCK.LKDT'}, $_[0]) },
     "LTEX.DATA" => sub { unpack($RD{'LTEX.DATA'}, $_[0]) },
     "MGEF.MEDT" => sub { my($school, $base, $flags, $red, $blue, $green, $speed, $size, $sizecap) = unpack($RD{'MGEF.MEDT'}, $_[0]);
			  sprintf "School: %s  BaseCost: %0.2f  Flags: %s  RGB: (%x, %x, %x)  SizeX: %0.2f  SizeCap: %0.2f",
			      $MAGIC_SCHOOL{$school}, $base, decode_flags($flags, \%MGEF_FLAGS), $red, $blue, $green, $size, $sizecap },
     "MISC.MCDT" => sub { sprintf "Weight: %0.2f  Value: %d  Unk:%0x", unpack($RD{'MISC.MCDT'}, $_[0]) },
#     "NPC_.ANAM" => $TOSTR_UNK,
#     "NPC_.KNAM" => $TOSTR_UNK,
     "NPC_.CNDT" => sub { unpack($RD{'NPC_.CNDT'}, $_[0]) },
     "NPC_.FLAG" => sub { decode_flags(unpack($RD{'NPC_.FLAG'}, $_[0]), \%NPC_FLAGS) },
     "NPC_.AIDT" => sub { my($hello, $unk1, $fight, $flee, $alarm, $unk2, $unk3, $unk4, $flags) = unpack($RD{'NPC_.AIDT'}, $_[0]);
			  sprintf "Hello: %d  Fight: %d  Flee: %d  Alarm: %d  Flags: %s",
			      $hello, $fight, $flee, $alarm, decode_flags($flags, \%AIDT_FLAGS); },
     "NPC_.AI_W" => sub { my($hr) = $DECODE{'NPC_.AI_W'}->($_[0]);
			  my $idle = join(", ", map { $hr->{"idle_$_"} } 1..8);
			  sprintf "Distance: %d  Duration: %d  Time_of_day: %d, Idles: $idle",
			      $hr->{distance}, $hr->{duration}, $hr->{time_of_day} },
     "NPC_.NPDT" => sub { my($hr) = $DECODE{'NPC_.NPDT'}->($_[0]);
			  if (exists $hr->{str}) { # long form
			      my $skills = "";
			      my $n = 0;
			      foreach my $skill (sort values %SKILL) {
				  next if ($skill eq 'None');
				  $skills .= "\n\t\t" if (($n++ % 7) == 0);
				  $skills .= " $skill: $hr->{$skill}";# if (defined $hr->{$skill});
			      }
			      sprintf "  Level: %d  Str: %d  Int: %d  Wil: %d  Agi: %d  Spd: %d  End: %d  Per: %d  Lck: %d\n\t\tRep: %d  Health: %d Magicka: %d  Fatigue: %d  Disp: %d  Faction: %d  Rank: %d  Gold: %d\n\t\tSkills:$skills",
				  $hr->{level}, $hr->{str}, $hr->{int}, $hr->{wil}, $hr->{agi}, $hr->{spd},
				      $hr->{end}, $hr->{per}, $hr->{lck}, $hr->{rep}, $hr->{health}, $hr->{magicka},
					  $hr->{fatigue}, $hr->{disposition}, $hr->{faction}, $hr->{rank}, $hr->{gold};
			  } else {		   # short form (autocalced)
			      sprintf "Level: %d  Disposition: %d  Faction: %d  Rank: %d  Gold: %d",
				  $hr->{level}, $hr->{disposition}, $hr->{faction}, $hr->{rank}, $hr->{gold};
			  }
		      },
     "PCDT.SNAM" => $TOSTR_UNK, # .ess
     "PCDT.ENAM" => $TOSTR_UNK, # .ess
     "PCDT.FNAM" => $TOSTR_UNK, # .ess
     "PROB.PBDT" => sub { sprintf "Weight: %0.2f  Value: %d  Quality: %0.2f  Uses: %d", unpack($RD{'PROB.PBDT'}, $_[0]) },
     "QUES.DATA" => sub { sprintf "INFO_ID: %s", unpack($RD{'QUES.DATA'}, $_[0]) }, # only in .ess (relates back to Actor in INFO)
     "RACE.RADT" => sub { my($hr) = $DECODE{'RACE.RADT'}->($_[0]);
			  my $result = sprintf "Flags: %s  Male_Height: %0.2f  Male_Weight: %0.2f  Female_Height: %0.2f  Female_Weight: %0.2f",
			      decode_flags($hr->{flags}, \%RADT_FLAGS), $hr->{male_height}, $hr->{male_weight},
				  $hr->{female_height}, $hr->{female_weight};
			  $result .= "\n\t\tSkill Bonuses:";
			  foreach my $i (1..7) {
			      my($skill_id, $bonus) = ($hr->{"skill_$i"}, $hr->{"bonus_$i"});
			      $result .= sprintf("\n\t\t%-12s %3d", $SKILL{$skill_id}, $bonus);
			  }
			  my @attr_names = qw(Strength Intelligence Willpower Agility Speed Endurance Personality Luck);
			  $result .= "\n\t\tBase Attributes: Male/Female";
			  foreach my $i (1..8) {
			      my($male, $female) = ($hr->{"attr_male_$i"}, $hr->{"attr_female_$i"});
			      $result .= sprintf("\n\t\t%-12s    %3d  %3d", shift(@attr_names), $male, $female);
			  }
			  $result;
		      },
     "REFR.ACDT" => sub { sprintf "%s", unpack("H*", $_[0]) },
     "REFR.WNAM" => sub { my $spell = unpack($RD{'REFR.WNAM'}, $_[0]);
		      sprintf "Readied_Spell: %s", $spell },
     "REGN.WEAT" => sub { sprintf "Clear: %d  Cloudy: %d  Foggy: %d  Overcast: %d  Rain: %d  Thunder: %d  Ash: %d  Blight: %d  Snow: %d  Blizzard: %d",
			      unpack($RD{'REGN.WEAT'}, $_[0]) },
     "REGN.CNAM" => sub { "Map_Color_RGB: (%x, %x, %x)", unpack($RD{'REGN.CNAM'}, $_[0]) },
     "REGN.SNAM" => sub { "Chance: %3d  SoundName: %s", unpack($RD{'REGN.SNAM'}, $_[0]) },
     "REGN.WNAM" => sub { unpack($RD{'REGN.WNAM'}, $_[0]); },
     "REPA.RIDT" => sub { sprintf "Weight: %0.2f  Value: %d  Uses: %d  Quality: %0.2f", unpack($RD{'REPA.RIDT'}, $_[0]); },
     "SCPT.RNAM" => sub { sprintf "Unk:%x", unpack($RD{'SCPT.RNAM'}, $_[0]) },
     "SCPT.SCDT" => sub { if (DBG) { unpack($RD{'SCPT.SCDT'}, $_[0]) } else { "(Compiled script data)" }; },
     "SCPT.SCHD" => sub { sprintf "Name: %s  NumShorts: %d  NumLongs: %d  NumFloats: %d  ScriptDataSize: %d  LongVarSize: %d",
			      unpack($RD{'SCPT.SCHD'}, $_[0]); },
     "SCPT.SCVR" => sub { "Script Variables: " . join(',', split(/\000/, unpack($RD{'SCPT.SCVR'}, $_[0]))) },
     "SCPT.SCTX" => sub { my $sctx = unpack($RD{'SCPT.SCTX'}, $_[0]);
			  $sctx =~ s/\r$//gm if ($^O eq 'linux');
			  "Script:\n$sctx"  },
     "SKIL.INDX" => sub { my $skill = unpack("L", $_[0]) ;
			  sprintf("%d (%s)", $skill, $SKILL{$skill});  },
     "SKIL.SKDT" => sub { my($attr, $spec, @usevals) = unpack($RD{'SKIL.SKDT'}, $_[0]);
			  sprintf "Attribute: %s  Specialization: %s  UseValues: %0.2f %0.2f %0.2f %0.2f",
			      $ATTRIBUTE{$attr}, $SPECIALIZATION{$spec}, @usevals},
     "SNDG.DATA" => sub { qq{"$SNDG_DATA[unpack($RD{'SNDG.DATA'}, $_[0])]"}; },
     "SPEL.SPDT" => sub { my($type, $cost, $flags) = unpack($RD{'SPEL.SPDT'}, $_[0]);
		      sprintf "Type: %s  Cost: %d  Flags: %s", $SPEL_TYPE{$type}, $cost, decode_flags($flags, \%SPEL_FLAGS) },
     "SPLM.NAME" => sub { unpack($RD{'SPLM.NAME'}, $_[0]); },
     "SPLM.SPDT" => sub {
	 # SPDT is 160 bytes long
	 my($type, $name, $long1, $long2, $caster, $item) = unpack($RD{'SPLM.SPDT'}, $_[0]);
	 sprintf qq{Type: %s  Name: "%s"  long1:%s  long2: %d  caster: "%s"  Item: "%s"},
	     $SPLM_TYPE{$type}, $name, dbg_word(pack("L", $long1)), $long2, $caster, $item;
     },
     "SPLM.NPDT" => sub {
	 # NPDT is 56 bytes long
	 my($name, $mag, $active, $long3, $long4) = unpack($RD{'SPLM.NPDT'}, $_[0]);
	 sprintf qq{Name: "%s"  Magnitude: %d  Seconds_Active: %0.1f  Long3: %d  Long4: %d},
	     $name, $mag, $active, $long3, $long4;
     },
     "SPLM.XNAM" => sub { sprintf "%d", unpack($RD{'SPLM.XNAM'}, $_[0]); },
     "SPLM.TNAM" => sub { sprintf "Target: %s", unpack($RD{'SPLM.TNAM'}, $_[0]); },
     "SOUN.DATA" => sub { sprintf "Volume: %d  MinRange: %d  MaxRange: %d", unpack($RD{'SOUN.DATA'}, $_[0]) },
     "SSCR.DATA" => sub { unpack($RD{'SSCR.DATA'}, $_[0]) },
     "STLN.ONAM" => sub { unpack($RD{'STLN.ONAM'}, $_[0]) },
     "WEAP.WPDT" => sub { my($wght, $value, $type, $health, $speed, $reach, $epts, $chopmin, $chopmax, $slashmin, $slashmax, $pokemin, $pokemax, $flags) = unpack($RD{'WEAP.WPDT'}, $_[0]);
		      sprintf " Wght: %0.2f  Val: %d  Typ: %s  Hlth: %d  Spd: %0.2f  Rch: %0.2f\n\t\tEnchant_Points: %d  Chop: %d-%d  Slash: %d-%d Thrust: %d-%d  Flags: %s",
			  $wght, $value, $WEAPON_TYPE{$type}, $health, $speed, $reach, $epts, $chopmin, $chopmax, $slashmin, $slashmax, $pokemin, $pokemax, $WEAPON_FLAGS{$flags}},
     "VFXM.VNAM" => sub {
	 my($long1, $long2, $long3, $long4, $long5, $long6, $short1, $hex1, $name2, $name3) =
	     unpack($RD{'VFXM.VNAM'}, $_[0]);
	 sprintf "\n  long1:%s\n  long2:%s\n  long3:%s\n  long4:%s\n  long5:%s\n  long6:%s\n  short1:%d\n  unk1:[%s]\n  name2: %s\n  name3: %s\n",
	     dbg_word($long1), dbg_word($long2), dbg_word($long3), dbg_word($long4), dbg_word($long5), dbg_word($long6), $short1, $TOSTR_UNK->($hex1), $name2, $name3;
     },

     # The following are common subrecord formats
     DELE => sub { sprintf "DELETED: Unk:0x%s", unpack($RD{'DELE'}, $_[0]) },
     DODT => sub { sprintf "Position x: %0.2f y: %0.2f z: %0.2f   Angle x: %0.2f y: %0.2f z: %0.2f", unpack($RD{'DODT'}, $_[0]) },
     FLAG => sub { sprintf "hexflags:0x%04x", unpack($RD{'FLAG'}, $_[0]) },
     NPCO => sub { sprintf 'Count=%d  Name="%s"', unpack("lZ*", $_[0]) }, # codec must use a32 for NAME
     XCHG => sub { sprintf "Enchant_Charge: %0.2f", unpack($RD{'XCHG'}, $_[0]) },
     XHLT => sub { sprintf "Health: %d", unpack($RD{'XHLT'}, $_[0]) },
     XSCL => sub { sprintf "Scale: %0.2f", unpack($RD{'XSCL'}, $_[0]) },
     XSOL => sub { sprintf "Soul: %s", unpack($RD{'XSOL'}, $_[0]) },
     WIDX => sub { my($idx, $ammo) = unpack($RD{'WIDX'}, $_[0]);
		   $ammo = ($ammo == 0) ? "" : " (Ammo)";
		   sprintf "Equipped_Idx:%3d$ammo",  $idx }, # JMS index into NPCO inventory items of those that are equipped
     SLCS => sub { sprintf "Shorts: %d  Longs: %d  Floats: %d", unpack($RD{'SLCS'}, $_[0]) }, # .ess
     SLSD => sub { sprintf "Short_Vals: " . join(", ", unpack($RD{'SLSD'}, $_[0])) }, # .ess
     SLLD => sub { sprintf "Long_Vals: " . join(", ", unpack($RD{'SLLD'}, $_[0])) }, # .ess
     SLFD => sub { sprintf "Float_Vals: " . join(", ", map { sprintf "%0.2f", $_ } join(", ", unpack($RD{'SLFD'}, $_[0]))) }, # .ess
    );

$TOSTR{"SPEL.ENAM"} = $TOSTR{"ENCH.ENAM"};

# subrecords that decode as signed 32-bit longs:
foreach (qw(INTV)) {
    $TOSTR{$_} = sub { unpack("l", $_[0]) }; }

# subrecords that decode as unsigned 32-bit longs:
foreach (qw(INDX NAM0 XIDX))
    { $TOSTR{$_} = sub { unpack("L", $_[0]) }; }

# subrecords that decode as 32-bit floats:
foreach (qw(FLTV WHGT))
    { $TOSTR{$_} = sub { sprintf "%0.2f", unpack("f", $_[0]) }; }

# subrecords that decode as variable length Z-strings:
foreach (qw(ANAM ASND AVFX BNAM BSND BVFX CNAM CSND CVFX DESC DNAM ENAM FGTN FNAM
HSND HVFX ITEX KNAM LSHN LSTN MNAM MODL NAME NPCS PTEX RGNN RNAM SCIP SCPT SCRI SNAM STRV
TEXT TGTN TNAM WNAM))
    { $TOSTR{$_} = sub { unpack("Z*", $_[0]) }; }

###DISPATCHER

my %CMDS =
    (
     # Type is 's' for commands that operate on one plugin at a time,
     # 'm' for multiple plugins at a time.
     #                    Options_fn         Command_fn        Type Description
     "clean"       => [ \&opts_clean,       \&cmd_clean,       's', "Clean plugins of Evil GMSTs, junk cells, and more"],
     "common"      => [ \&opts_common,      \&cmd_common,      'm', "Find record IDs common between two plugins"],
     "delete"      => [ \&opts_delete,      \&cmd_delete,      's', "Delete records from plugin"],
     "diff"        => [ \&opts_diff,        \&cmd_diff,        'm', "Report differences between two plugins"],
     "dump"        => [ \&opts_dump,        \&cmd_dump,        's', "Dump records as text"],
     "esm"         => [ \&opts_esm,         \&cmd_esm,         's', "Convert plugin (esp) to master (esm)"],
     "esp"         => [ \&opts_esp,         \&cmd_esp,         's', "Convert master (esm) to plugin (esp)"],
     "fixit"       => [ \&opts_fixit,       \&cmd_fixit,       'm', "Fixes everything it knows how to fix"],
     "header"      => [ \&opts_header,      \&cmd_header,      's', "Read/Write plugin header fields (author, description)"],
     "help"        => [ \&opts_help ],
     "modify"      => [ \&opts_modify,      \&cmd_modify,      's', "Powerful batch record modification via user code extensions"],
     "multipatch"  => [ \&opts_multipatch,  \&cmd_multipatch,  'm', "Patches problems in your active plugins"],
     "overdial"    => [ \&opts_overdial,    \&cmd_overdial,    'm', "Identify overlapping dialog (a source of missing topic bugs)"],
     "recover"     => [ \&opts_recover,     \&cmd_recover,     's', "Recover usable records from plugin with 'bad form' errors"],
     "rename"      => [ \&opts_rename,      \&cmd_rename,      's', "Rename objects"],
     "-codectest"  => [ \&opts_codectest,   \&cmd_codectest,   's', "Test TES3 codec"],
     "-shell"      => [ \&opts_shell,       \&cmd_shell,       'm', "run a TES3 REPL"],
     "-wikiout"    => [ \&opts_wikiout,     \&cmd_wikiout,     'm', "Output wiki formatted help"],
    );

my $command_list;
foreach (sort keys %CMDS) {
    $command_list .= "  $_\n    $CMDS{$_}->[3].\n"
	unless (($_ eq 'help') or ($_ =~ /^-/));
}
my $USAGE_ALL = qq{Usage: tes3cmd COMMAND OPTIONS plugins...

VERSION: $::VERSION

tes3cmd is a low-level command line tool that can examine, edit, and delete
records from a TES3 plugin for Morrowind. It can also generate various patches
and clean plugins too.

COMMANDS
$command_list

FOR HELP ON INDIVIDUAL COMMANDS:

  tes3cmd help <command>

GENERAL HELP:

OPTIONS given to commands may be abbreviated, as long as the abbreviations are
unique.

Normal users will likely only be interested in the "clean" and "multipatch"
commands. The other commands will mostly appeal to modders.

tes3cmd uses Perl regular expressions for string matching, the full
documentation can be found here:
   http://www.perl.com/doc/manual/html/pod/perlre.html
You should at least be aware that the characters "\\.?*+|^\$()[]{}" have
special meaning in a regular expression and that they are unlike characters
used for matching on a Windows command line.
};

sub opts_help {
    if (my $cmd_name = shift(@ARGV)) {
	if (my $cmd_ref = $CMDS{$cmd_name}) {
	    $cmd_ref->[0]->(1);	# exits
	} else {
	    die $USAGE_ALL;
	}
    }
    die $USAGE_ALL;
}

###IO

sub update_header {
    my($plugin, $quiet) = @_;
    if (($opt_header_update_record_count or $opt_header_update_masters) and
	($plugin =~ /~\D+\.es[mp]$/i)) {
	warn "Skipping Backup: $plugin\n";
	return;
    }
    my $master;
    my($atime, $mtime) = (stat($plugin))[8,9];
    my $fh = open_for_update($plugin);
    my($rectype, $rec, $flags, $unk) = read_rec($fh, 'TES3', $plugin);
    my $tr = TES3::Record->new($plugin, $rectype, $rec, $flags, $unk);
    my $tes3len = length($rec);
    my $update_msg = '';
    my $modified = 0;
    foreach my $tsr ($tr->subrecs()) {
	my $subtype = $tsr->subtype();
	if ($subtype eq 'HEDR') {
	    if ($opt_header_author) {
		$modified++;
		if ($opt_header_author =~ /^\+(.*)/) {
		    $tsr->{author} .= $1;
		} else {
		    $tsr->{author} = $opt_header_author;
		}
	    }
	    if ($opt_header_description) {
		$modified++;
		if ($opt_header_description =~ /^\+(.*)/) {
		    $tsr->{description} .= $1;
		} else {
		    $tsr->{description} = $opt_header_description;
		}
	    }
	    if ($opt_header_update_record_count) {
		my $count = get_record_count($plugin);
		if ($tsr->{nrecords} != $count) {
		    $modified++;
		    $update_msg .= qq{  Updated Record Count: $tsr->{nrecords} --> $count\n};
		    $tsr->{nrecords} = $count;
		}
	    }
	}
	if ($opt_header_update_masters) {
	    if ($subtype eq 'MAST') {
		$master = $tsr->{master};
	    } elsif ($subtype eq 'DATA') {
		my $length = $tsr->{length};
		if ((my $newlen = -s ($T3->datapath($master))) != $length) {
		    $modified++;
		    $update_msg .= qq{  Synchronized master "$master" length: $length --> $newlen\n};
		    $tsr->{length} = $newlen;
		}
	    }
	}
    }
    unless ($quiet) {
	my $banner = "$plugin:\n";
	if (VERBOSE) {
	    print $banner . $tr->tostr() . "\n";
	} else {
	    if (not($opt_header_author or $opt_header_description or $opt_header_update_record_count or
		    $opt_header_update_masters or $opt_header_update_record_count) or
		$opt_header_author or $opt_header_description) {
		foreach my $tsr ($tr->subrecs()) {
		    my $subtype = $tsr->subtype();
		    if ($subtype eq 'HEDR') {
			if ($opt_header_multiline) {
			    print qq{$plugin:\n  AUTH=$tsr->{author}\n  DESC=$tsr->{description}\n};
			} else {
			    my $msg = qq{$plugin:  AUTH=$tsr->{author}  DESC=$tsr->{description}};
			    $msg =~ s/(\r)?\n/\\r\\n/gm;
			    print "$msg\n";
			}
			$banner = '';
			last;
		    }
		}
	    }
	}
	if ($update_msg) {
	    print $update_msg;
	} else {
	    print "$plugin not modified\n" if (VERBOSE);
	}
    }
    if ($modified) {
	# make backup of plugin before making changes only if updating
	my $backup = unique_backup_name($plugin);
	copy($plugin, $backup) or die "Error, copy failed $plugin -> $backup ($!)\n";
    }
    $rec = $tr->encode();
    if (length($rec) == $tes3len) {
	seek($fh, 0, SEEK_SET);
	write_rec($fh, 'TES3', $rec, $flags, $unk);
    } else {
	die "update_header(): output header size incorrect\n";
    }
    close($fh);
    utime($atime, $mtime, $plugin);
}				# update_header

my $hdr_size = 16;
sub read_rec {
    my($fh, $expected_type, $plugin) = @_;
    my $rec_hdr = "";
    my $n_read = sysread($fh, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef);
    }
    if ($n_read != $hdr_size) {
	my $inp_offset = sysseek($fh, 0, SEEK_CUR) - $n_read - $hdr_size;
	die qq{read_rec(): Read Error ($plugin header at byte: $inp_offset): asked for $hdr_size bytes, got $n_read\n};
    }
    my($rectype, $rec_len, $unk, $flags) = unpack("a4LLL", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rectype) {
	my $inp_offset = sysseek($fh, 0, SEEK_CUR) - $n_read - $hdr_size;
	die qq{read_rec(): Error ($plugin at byte: $inp_offset): Expected: $expected_type, got: $rectype\n};
    }
    my $rec = "";
    $n_read = sysread($fh, $rec, $rec_len);
    if ($n_read != $rec_len) {
	my $inp_offset = sysseek($fh, 0, SEEK_CUR) - $n_read - $hdr_size;
	die qq{read_rec(): Read Error ($plugin record at byte: $inp_offset, rec_type="$rectype"): asked for $rec_len bytes, got $n_read\n};
    }
    return($rectype, $rec, $flags, $unk, $rec_hdr);
}

sub write_rec {
    my($fh, $rectype, $rec, $flags, $unk) = @_;
    print $fh pack("a4LLLa*", $rectype, length($rec), $unk, $flags, $rec);
}

sub subrec {
    my($type, $val) = @_;
    return(pack("a4La*", $type, length($val), $val));
}

sub ext_cell_name {
    my($srh, $name) = @_;
    $name = $name || (defined $srh->{RGNN}[0]) ? chop_nulls($srh->{RGNN}[0]) : "Wilderness";
    if (length($srh->{DATA}[0]) < 12) { # size of "x[L]ll"
	warn "Error, CELL: ($name) does not have a valid DATA subrecord\n";
	return($name);
    } else {
	return(sprintf("$name (%d, %d)", unpack("x[L]ll", $srh->{DATA}[0])));
    }
}

sub rec_id {
    my($srh, $rectype) = @_;
    if ($rectype eq "INFO") {
	return(chop_nulls($srh->{INAM}[0]));
    } elsif ($rectype eq "CELL") {
	my $name = chop_nulls($srh->{NAME}[0]);
	my $data = $srh->{DATA}[0];
	my($flags) = unpack("L", $data);
	if ($flags & 1) {	# interior
	    return($name);
	} else {		# exterior
	    return(ext_cell_name($srh, $name));
	}
    } elsif ($rectype eq "SCPT") {
	return(lc(unpack("Z32", $srh->{SCHD}[0])));
    } elsif (defined $srh->{NAME}) {
	return(lc(chop_nulls($srh->{NAME}[0])));
    } elsif (defined $srh->{INDX}) {
	return(unpack("L", $srh->{INDX}[0]));
    } elsif ($rectype eq "LAND") {
	my($x, $y) = unpack("ll", $srh->{INTV}[0]);
	return("($x, $y)");
    } elsif ($rectype eq "TES3") {
	return('');
    }
    return(undef);
}

# given a reference to object returned by a decoder, return printable name
# operates on current record: $R
sub get_id {
    my($rectype, $r) = @_;
    $r ||= $R;
    if ($rectype eq "INFO") {
	foreach my $subr (@$r) {
	    if ($subr->[0] eq 'INAM') {
		return($subr->[1]->{id});
	    }
	}
    } elsif ($rectype eq "CELL") {
	my($name, $rgnn, $coord);
	foreach my $subr (@$r) {
	    if ($subr->[0] eq 'NAME') {
		$name = $subr->[1]->{id} unless (defined $name);
	    } elsif ($subr->[0] eq 'RGNN') {
		$rgnn = $subr->[1]->{string} unless (defined $rgnn);
	    } elsif ($subr->[0] eq 'DATA') {
		if (defined $subr->[1]->{x}) {
		    $coord = "$subr->[1]->{x}, $subr->[1]->{y}"; # External Cell
		}
	    }
	    last if ($subr->[0] eq 'FRMR');
	}
	if (defined $coord) {	# this is an external cell
	    my $where = $name || $rgnn || 'Wilderness';
	    return("$where ($coord)");
	} else {		# this is an internal cell
	    return($name);
	}
    } elsif ($rectype eq "SCPT") {
	foreach my $subr (@$r) {
	    return(lc(chop_nulls($subr->[1]->{id})))
		if ($subr->[0] eq 'SCHD');
	}
    } elsif ($rectype eq "LAND") {
	foreach my $subr (@$r) {
	    if ($subr->[0] eq 'INTV') {
		my $x = $subr->[1]->{x};
		my $y = $subr->[1]->{y};
		return("($x, $y)");
	    }
	}
    } elsif (($rectype eq "MGEF") or ($rectype eq "SKIL")) {
	foreach my $subr (@$r) {
	    if ($subr->[0] eq 'INDX') {
		return($subr->[1]->{long});
	    }
	}
    } elsif ($rectype eq "TES3") {
	return('');
    } else {
	foreach my $subr (@$r) {
	    if ($subr->[0] eq 'NAME') {
		return($subr->[1]->{id});
	    }
	}
    }
    warn "get_id(): don't know how to make ID for: $rectype\n";
    return(undef);
}

sub parse_subrec_list {
    my($rec) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @subrecs = ();
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	push(@subrecs, [$subrec_type, $subrec]) if (defined $subrec);
	$p += $subrec_len;
    }
    return(\@subrecs);
}

# this version takes a little longer to execute
sub parse_subrec_hash_long {
    my($rec) = @_;
    warn "DBG: calling parse_subrec_hash_long for rec=$rec\n" if (DBG);
    my %r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	push(@{$r{$subrec_type}}, $subrec) if (defined $subrec);
	$p += $subrec_len;
    }
    return(\%r);
}

sub parse_subrec_hash {
    my($rec) = @_;
    my %r = ();
    eval {
	my @parts = unpack("(a4L/a*)*", $rec);
	while (my($key, $buff) = splice(@parts, 0, 2)) {
	    push(@{$r{$key}}, $buff);
	}
    };
    if ($@) {
	warn qq{DBG: parse_subrec_hash failed on "$rec", retrying with safer parser\n} if (DBG);
	return(parse_subrec_hash_long($rec));
    }
    return(\%r);
}

sub parse_cell_objects {
    my($rec) = @_;
    my($hdr, $obj, @objs, %objidx);
    my $srl = parse_subrec_list($rec);
    foreach my $subr (@$srl) {
	my($subtype, $subrec) = @$subr;
	if ($subtype eq 'NAM0') {
	    if ($obj) {
		my @newobj = @$obj;
		push(@objs, \@newobj);
		$objidx{$newobj[1]} = $newobj[0];
		undef $obj;
	    }
	    push(@objs, 'NAM0');
	} elsif ($subtype eq 'FRMR') {
	    if ($obj) {
		my @newobj = @$obj;
		push(@objs, \@newobj);
		$objidx{$newobj[1]} = $newobj[0];
	    }
	    # start new object
	    $obj->[0] = [unpack($RD{'CELL.FRMR'}, $subrec)];
	    $obj->[1] = '';
	} else {
	    if ($obj) {		# collecting object
		$obj->[1] .= pack("a4L/a*", $subtype, $subrec);
	    } else {		# still collecting header
		$hdr .= pack("a4L/a*", $subtype, $subrec);
	    }
	}
    }
    if ($obj) {
	my @newobj = @$obj;
	push(@objs, \@newobj);
	$objidx{$newobj[1]} = $newobj[0];
    }
    return($hdr, \@objs, \%objidx);
}

sub assemble_cell_objects {
    my($hdr, $objs) = @_;
    my $rec = $hdr;
    my $idx = 1;
    foreach my $obj (@$objs) {
	if ($obj eq 'NAM0') {
	    my $nam0 = scalar(@$objs) - $idx;
	    $rec .= pack("a4LL", 'NAM0', 4, $nam0) if ($nam0 > 0);
	} else {
	    my $frmr = pack($RD{'CELL.FRMR'}, @{$obj->[0]});
	    $rec .=  pack("a4L/a*", 'FRMR', $frmr) . $obj->[1];
	}
	$idx++;
    }
    return($rec);
}

sub new_rec {
    my($sub_recs) = @_;
    my @rec;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	my $len = length($val);
	push(@rec, pack("a4La*", $type, $len, $val));
    }
    return(join("", @rec));
}

sub pprec {
    my($rec, $subtype) = @_;
    warn "DBG: pprec($rec)\n" if (DBG);
    my $recstr = join(":", grep(!/[^[:print:]]/, map { s/[\000]+$//gm; tr/\r\n/ /; $_; } split(/\000?([A-Z][A-Z_][A-Z_][A-Z_\d])...\000/, $rec)));
    $recstr =~ s/^:$subtype:.*?:// if ($subtype);
    $recstr =~ s/:([A-Z][A-Z_][A-Z_][A-Z_\d])/|$1/g;
    return(substr($recstr, 0, $opt_rename_window_size));
}

sub open_for_read {
    my($plugin) = @_;
    my $fh = IO::Handle->new();
    unless (open($fh, "<$plugin")) {
	die qq{Error opening "$plugin" for input ($!)\n};
    }
    unless (binmode($fh, ':raw')) {
	die "Error setting binmode on $plugin ($!)\n";
    }
    return($fh);
}

sub open_for_write {
    my($plugin) = @_;
    my $fh = IO::Handle->new();
    unless (open($fh, ">$plugin")) {
	die qq{Error opening "$plugin" for output ($!)\n};
    }
    unless (binmode($fh, ':raw')) {
	die qq{Error setting binmode on "$plugin" ($!)\n};
    }
    return($fh);
}

sub open_for_update {
    my($plugin) = @_;
    my $fh = IO::Handle->new();
    unless (open($fh, "+<$plugin")) {
	die qq{Error opening "$plugin" for read/write ($!)\n};
    }
    unless (binmode($fh, ':raw')) {
	die qq{Error setting binmode on "$plugin" ($!)\n};
    }
    return($fh);
}

sub make_temp {
    my($plugin) = @_;
    die qq{Error, "$plugin" name does not end in .esm/.esp/.ess\n}
	if ($plugin !~ /\.(es[mps])$/i);
    my $plugtmp = "$plugin.tmp";
    my $inp = open_for_read($plugin);
    my $out = open_for_write($plugtmp);
    return($inp, $out);
}

sub unique_backup_name {
    my($plugbak) = @_;
    my($ext) = ($plugbak =~ /\.(es[mps])$/i);
    while (-f $plugbak) {
	$plugbak =~ s/(?:~(\d+))?\.$ext$/'~' . (($1||0) + 1) . ".$ext"/e;
    }
    return($plugbak);
}

sub fix_output {
    my($inp, $out, $plugin, $modified, $newname) = @_;
    close($inp);
    close($out);
    my $plugtmp = "$plugin.tmp";
    unless ($modified) {
	print "$plugin was not modified\n";
	unlink($plugtmp);
	return;
    }
    if ($opt_output_dir) {
	$newname = $plugin unless ($newname);
	# prepend given output directory
	$newname = "$opt_output_dir/" . (fileparse($newname))[0];
    }
    if (my($ext) = ($plugin =~ /\.(es[mps])$/i)) {
	my($atime, $mtime) = (stat($plugin))[8,9];
	if (File::Spec->rel2abs($newname) eq File::Spec->rel2abs($plugin)) {
	    warn "fix_output(): newname ($newname) same as plugin ($plugin)\n";
	    undef $newname;
	}
	if (defined($newname)) {
	    unless ($newname =~ /\.(es[mps])$/i) {
		abort(qq{"$newname" name does not end in .esm/.esp/.ess});
	    }
	    unless (rename($plugtmp, $newname)) {
		abort(qq{Renaming "$plugtmp" to "$newname" ($!)});;
	    }
	    $opt_header_update_record_count = 1;
	    update_header($newname, QUIET);
	    utime($atime, $mtime, $newname);
	    print qq{Output saved in: "$newname"\nOriginal unaltered: "$plugin"\n};
	} else {
	    my $plugbak = unique_backup_name($plugin);
	    unless (rename($plugin, $plugbak)) {
		abort(qq{Renaming "$plugin" to "$plugbak" ($!)});
	    }
	    unless (rename($plugtmp, $plugin)) {
		abort(qq{Renaming "$plugtmp" to "$plugin" ($!)});
	    }
	    $opt_header_update_record_count = 1;
	    update_header($plugin, QUIET);
	    utime($atime, $mtime, $plugin);
	    print qq{Output saved in: "$plugin"\nOriginal backed up to: "$plugbak"\n};
	}
    } else {
	die qq{Error, "$plugin" name does not end in .esm/.esp/.ess\n};
    }
}

sub cleanup_temp {
    my($inp, $plugin) = @_;
    close($inp);
    my $plugtmp = "$plugin.tmp";
    unlink($plugtmp);
}

sub read_objects {
    my($plugin, $fun) = @_;
    my $inp = open_for_read($plugin);
    my %plugin_id = ();
    eval {
	while (my($rectype, $rec, $flags, $unk) = read_rec($inp, undef, $plugin)) {
	    last if (not defined $rectype);
	    next if ($flags & $REC_FLAGS{ignored});
	    my $id = rec_id(parse_subrec_hash($rec), $rectype);
	    if ($fun) {
		$fun->($rectype, $id);
	    } else {
		$plugin_id{$rectype}->{$id} = $rec if (defined $id);
	    }
	}
    };
    warn $@ if ($@);
    close($inp);
    return(\%plugin_id) unless ($fun);
}

sub read_dialogs {
    my($plugin, $dialref) = @_;
    my $inp = open_for_read($plugin);
    eval {
	while (my($rectype, $rec, $flags, $unk) = read_rec($inp, undef, $plugin)) {
	    last if (not defined $rectype);
	    next if ($flags & $REC_FLAGS{ignored});
	    next if ($rectype ne "DIAL");
	    my $srh = parse_subrec_hash($rec);
	    my $id = chop_nulls($srh->{NAME}[0]);
	    my $type = unpack("C", $srh->{DATA}[0]);
	    $dialref->{$plugin}->{$id}++ if ($type == 0 and $id);
	}
    };
    warn $@ if ($@);
    close($inp);
}


sub get_wanted {
    my $wanted_ids = (@opt_id) ? '(' . join('|', @opt_id) . ')' : '';
    my $wanted_flags;
    foreach my $flag (@opt_flag) {
	if ((my $n = eval $flag) > 0) {
	    $wanted_flags |= $n; # it's a numeric flag
	} else {
	    $wanted_flags |= $REC_FLAGS{lc($flag)};
	}
    }
    my $wanted_types;
    if (@opt_type) {
	foreach my $option (@opt_type) {
	    my($type, $subtype) = split(/\./, uc($option));
	    if (length($type) != 4) {
		warn qq{get_wanted_types: Invalid record type: "$type" (must be 4 characters long)\n};
		next;
	    }
	    $wanted_types->{$type}++;
	    if ($subtype) {
		if (length($subtype) == 4) {
		    $wanted_types->{"$type.$subtype"}++;
		} else {
		    warn qq{get_wanted_types: Invalid record subtype: "$subtype" (must be 4 characters long)\n};
		    next;
		}
	    }
	}
    }
    return($wanted_ids, $wanted_types, $wanted_flags);
}

my $CURRENT_DIAL;
sub rec_to_string {
    my($rec, $rectype, $id, $plugin, $flags, $unk) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @print_rec;
    my($prefix, $unkstr) = ('', '');
    unless ($opt_separator) {
	$prefix = "\n";
	$opt_separator = "\n ";
    }
    if (DBG) {
	$prefix = "$plugin ";
	$unkstr = sprintf "  Unk:%04x", $unk;
	$opt_separator = "\n ";
    }
    my $dial_str = ($rectype eq 'INFO') ? " $CURRENT_DIAL" : '';
    my $flagstr = decode_flags($flags, \%REC_FLAGS);
    warn "REC=$rectype $id flags=$flagstr\n" if (DBG);
    my $hdr = defined($flags) ? qq{${prefix}Record: $rectype "$id"$dial_str Flags: $flagstr${unkstr}} : '';
    my @frmr_data;
    my $first_frmr_seen = 0;
    my $frmr_match = 0;
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	$p += $subrec_len;
	if (defined $subrec) {
	    my $full_type = "${rectype}.${subrec_type}";
	    my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type} || $TOSTR_UNK;
	    my $subrec_str = $tostr->($subrec);
	    if ($opt_cell_object_match and ($rectype eq 'CELL')) {
		if ($first_frmr_seen) {
		    if ($subrec_type eq 'FRMR') {
			if (join(" ", @frmr_data) =~ /$opt_cell_object_match/i) {
			    $frmr_match++;
			    push(@print_rec, @frmr_data);
			}
			@frmr_data = (); # start a new group
		    }
		    push(@frmr_data, "$subrec_type: $subrec_str");
		} else {
		    if ($subrec_type eq 'FRMR') {
			# start the first FRMR group
			$first_frmr_seen = 1;
			push(@frmr_data, "$subrec_type: $subrec_str");
		    } else {
			# we push subrecs onto print_rec up until the first FRMR
			push(@print_rec, "$subrec_type: $subrec_str");
		    }
		}
	    } else {
		push(@print_rec, "$subrec_type: $subrec_str");
	    }
	} else {
	    warn "$plugin: Error, malformed subrec for ($rectype $id) type=$subrec_type pos=$p len=$subrec_len\n";
	}
    }
    # if -C, check the last FRMR group
    if ($opt_cell_object_match) {
	if (join(" ", @frmr_data) =~ /$opt_cell_object_match/i) {
	    $frmr_match++;
	    push(@print_rec, @frmr_data);
	}
	return("") unless ($frmr_match);
    }
    return(join($opt_separator, $hdr, @print_rec));
}

# decode record buffer into a list of [subtype, hr], where hr is a hash of the fields of the subrecord
sub decode_rec { # TBD - nuke
    my($plugin, $rectype, $rec) = @_;
    #warn "decode_rec($plugin, $rectype, $rec)\n";
    my $p = 0;
    my $rec_len = length($rec);
    # decode the subrecords for this record
    my @subrecs = ();
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $subrec = substr($rec, $p, $subrec_len);
	$p += $subrec_len;
	if (defined $subrec) {
	    my($hr) = decoder($rectype, $subrec_type)->($subrec);
	    push(@subrecs, [$subrec_type, $hr]);
	} else {
	    warn "$plugin: Error, malformed subrec for ($rectype) type=$subrec_type pos=$p len=$subrec_len\n";
	}
    }
    return($R = \@subrecs); # TBD - nuke
}

# encode and return a buffer for the subrecords that comprise the body of a full record.
sub encode_rec { # TBD - nuke
    my($rectype, $r) = @_;
    $r ||= $R;
    my $newrec = '';
    foreach my $subr (@$r) {
	my($subtype, $hr) = @$subr;
	my $full_type = "${rectype}.${subtype}";
	my $subrec = encoder($rectype, $subtype)->($hr);
	$newrec .= pack("a4L/a*", $subtype, $subrec);
    }
    return($newrec);
}

# return 1 if record matches selection criteria of command line switches
sub rec_match {
    my($plugin, $rectype, $rec, $flags, $unk, $wanted_ids, $wanted_types, $wanted_flags) = @_;
    return(0) if ($wanted_flags and not ($flags & $wanted_flags));
    if ($wanted_types) {
	unless ($wanted_types->{INFO} and ($rectype eq 'DIAL')) {
	    return(0) unless ($wanted_types->{$rectype});
	}
    }
    my $tr = TES3::Record->new($plugin, $rectype, $rec, $flags, $unk, TES3::Record::STASHBUF);
    my $id = $tr->id();
    if ($rectype eq 'DIAL') {
	my $type = $tr->get_type('DATA','type');
	if (ASSERT) {
	    die "No DATA(type): ".Dumper($tr)."\n" if not defined $type;
	    die "No DIAL TYPE for $type: ".Dumper(\%DIAL_TYPE)."\n" if not defined $DIAL_TYPE{$type};
	}
	$CURRENT_DIAL = "($DIAL_TYPE{$type}:$id)";
    }
    return(0, $tr) if ($wanted_types and not $wanted_types->{$rectype});
    return(0, $tr) if ($wanted_ids and $id !~ /$wanted_ids/i);
    if ($rectype eq 'CELL') {
	if ($tr->is_interior()) {
	    return(0, $tr) if ($opt_exterior);
	} else {
	    return(0, $tr) if ($opt_interior);
	}
    }
    if ($opt_match or $opt_no_match) {
	my $print_rec = $tr->tostr();
	if (((not $opt_match) or ($print_rec =~ /$opt_match/is)) and
	    ((not $opt_no_match) or ($print_rec !~ /$opt_no_match/is))) {
	    return(1, $tr, $print_rec);
	} else {
	    return(0, $tr, $print_rec);
	}
    } else {
	return(1, $tr);
    }
}

sub process_plugin_for_read {
    my($plugin, $fun, $stashbuf) = @_;
    my $inp = open_for_read($plugin);
    my $expected = "TES3";
    my($wanted_ids, $wanted_types, $wanted_flags) = get_wanted();
    # process each record in the plugin
    eval {
	while (my($rectype, $rec, $flags, $unk, $rec_hdr) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if (not defined $rectype);
	    $fun->($rectype, $rec, $flags, $unk, $rec_hdr, $wanted_ids, $wanted_types, $wanted_flags);
	}
    };
    warn $@ if ($@);
    close($inp);
}

# TBD - default to stashbuf for efficiency on passthru?
sub process_plugin_for_update {
    my($plugin, $fun, $stashbuf, $prefix) = @_;
    my($inp, $out) = make_temp($plugin);
    my $expected = "TES3";
    my($wanted_ids, $wanted_types, $wanted_flags) = get_wanted();
    my $modified;
    # process each record in the plugin
    eval {
	while (my($rectype, $rec, $flags, $unk, $rec_hdr) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if (not defined $rectype);
	    # function can delete, modify, or pass rec thru
	    my($newrec, $newflags) = $fun->($rectype, $rec, $flags, $unk, $rec_hdr, $wanted_ids, $wanted_types, $wanted_flags);
	    if (defined $newrec) { # rec was kept
		if ($newrec) {	   # rec was changed
		    write_rec($out, $rectype, $newrec, $newflags, $unk);
		    $modified++;
		} else {	# pass rec through unchanged
		    write_rec($out, $rectype, $rec, $flags, $unk);
		}
	    } else {		# rec was deleted
		$modified++;
	    }
	}
    };
    if ($@) {
	$modified = 0;
	warn $@;
    }
    if ($prefix) {
	my($file, $dir) = fileparse($plugin);
	my $newname = ($dir eq './') ? "${prefix}${file}" : "${dir}${prefix}${file}";
	fix_output($inp, $out, $plugin, $modified, $newname);
    } else {
	fix_output($inp, $out, $plugin, $modified);
    }
}

sub get_record_count {
    my($plugin) = @_;
    my $count = -1;		# we don't count the TES3 record
    process_plugin_for_read($plugin, sub { $count++; });
    return($count);
}

sub search_and_replace {
    my($x, $mref) = @_; # TBD - nuke $x ($R)
    my $type = ref($x);
    if ($type eq 'ARRAY') {
	foreach (@$x) {
	    if (ref($_) eq '') {
		${$mref} = 1 if eval qq{\$_ =~ s$opt_modify_replace;};
	    } else {
		search_and_replace($_, $mref);
	    }
	}
    } elsif ($type eq 'HASH') {
	while (my($k, $v) = each %$x) {
	    if (ref($x->{$k}) eq '') {
		${$mref} = 1 if eval qq{\$x->{\$k} =~ s$opt_modify_replace;};
	    } else {
		search_and_replace($x->{$k}, $mref);
	    }
	}
    } elsif ($type eq '') {
	my $x_before = $x;
	${$mref} = 1 if eval qq{\$_ =~ s$opt_modify_replace;};
    }
}

# by default operates on current record: $R
sub dumprec { # TBD - nuke
    my($opt, $r) = @_; 		# opt is hashref with keys: "i", "t", "f"
    $r ||= $R;
    my @indices = defined($opt->{i}) ? @{$opt->{i}} : (0 .. $#$r);
    foreach my $i (@indices) {
	my $type = $r->[$i]->[0];
	next if (defined($opt->{t}) and ($type !~ /^$opt->{t}/i));
	if (defined($opt->{f})) {
	    my $key = lc($opt->{f});
	    if (defined($r->[$i]->[1]->{$key})) {
		print qq{$i: $type  $key = $r->[$i]->[1]->{$key}\n};
	    } else {
		next;
	    }
	} else {
	    # dump all fields
	    my @ordered_fields = ();
	    my @unordered_fields = ();
	    while (my($key, $val) = each %{$r->[$i]->[1]}) {
		$val = qq{"$val"} if ($val =~ /[^\d.]/);
		my $print_key = lcfirst($key);
		if (defined $r->[$i]->[2]->{$key}) {
		    $ordered_fields[$r->[$i]->[2]->{$key}] = "$key = $val";
		} else {
		    push(@unordered_fields, "$key = $val");
		}
	    }
	    print " $i: $type ", join(", ", @ordered_fields, @unordered_fields), "\n";
	}
    }
    return(0);
}

sub remove_subrec {
    my($r, $subtype, $n) = @_;
    my @new_r = ();
    my $c = 0;
    foreach my $subr (@$r) {
	if ($subr->[0] eq $subtype) {
	    next unless ((defined $n) and ($c++ >= $n));
	}
	push(@new_r, $subr);
    }
    return(\@new_r);
}

sub run_code {
    my($rectype, $flags, $unk) = @_;
    my $mod = 0;
    search_and_replace($R, \$mod) if ($opt_modify_replace);
    if ($opt_modify_run) {
	$mod ||= eval($opt_modify_run);
	if ($@) {
	    warn qq{Error running "$opt_modify_run" on: $rectype ($@)\n};
	    $mod = 0;
	}
    }
    return(($mod) ? $R : undef)	# TBD -nuke
}

sub encoder {
    my($rectype, $subrec_type) = @_;
    return($ENCODE{"${rectype}.${subrec_type}"} || $ENCODE{$subrec_type} || $ENCODER_UNKNOWN);
}

sub decoder {
    my($rectype, $subrec_type) = @_;
    return($DECODE{"${rectype}.${subrec_type}"} || $DECODE{$subrec_type} || $DECODER_UNKNOWN);
}

sub master_cache_path {
    my($esm) = @_;
    my $cname = "$TES3::Util::TES3CMD_DIR/$esm";
    $cname =~ s/\.esm$/.dat/;
    #warn "DBG: master_cache_path($esm) -> $cname\n";
    return($cname);
}

sub load_master_cache {
    my($esm) = @_;
    my $mcache = master_cache_path($esm);
    if ($opt_no_cache) {
	unlink($mcache) if (-f $mcache);
	return(0);
    }
    warn "DBG: master cache name = $mcache\n" if (DBG);
    eval {
	if (my $listref = retrieve($mcache)) {
	    my($prev_size, $master_data) = @{$listref};
	    my $curr_size = (-s $T3->datapath($esm));
	    if ($curr_size == $prev_size) {
		$MASTER_ID->{$esm} = $master_data;
		print "Loaded cached Master: <DATADIR>/$esm\n";
	    } else {
		die "Cache Invalidated for: $esm (curr_size == $curr_size, prev_size == $prev_size)\n";
	    }
	} else {
	    die "Error retrieving master cache for: $esm\n";
	}
    };
    if ($@) {
	warn $@ unless ($@ =~ /can't open .*\.dat: No such file or directory/);
	return(0);
    } else {
	return(1);
    }
}

sub save_master_cache {
    my($esm) = @_;
    return(0) if ($opt_no_cache);
    my $size = (-s $T3->datapath($esm));
    warn "DBG: save_master_cache($esm) saving size: $size\n" if (DBG);
    store([ $size, $MASTER_ID->{$esm}], master_cache_path($esm));
}

# load all the records from a master .esm into a dictionary.
sub load_master {
    my($esm, $types) = @_;
    $esm = lc($esm);
    warn "DBG: load_master($esm, $types)\n" if (DBG);
    if (defined $MASTER_ID->{$esm}) {
	warn "DBG: re-using master data: $esm\n" if (DBG);
	return;
    }
    return if (load_master_cache($esm)); # load pre-parsed data
    print "Loading Master: $esm\n";
    my $inp = open_for_read($T3->datapath($esm));
    eval {
	while (my($rectype, $rec, $flags) = read_rec($inp, undef)) {
	    last if (not defined $rectype);
	    next if ($flags & $REC_FLAGS{ignored});
	    next if (defined $types and not $types->{$rectype});
	    print "DBG: rec_type = $rectype\n" if (DBG);
	    my $srh = parse_subrec_hash($rec);
	    my $id = rec_id($srh, $rectype);
	    $MASTER_ID->{$esm}->{$id}->{$rectype} = [$srh, $rec, $flags];
	}
    };
    warn $@ if ($@);
    close($inp);
    save_master_cache($esm);
}

sub dumpit {
    my($label, $it) = @_;
    $it =~ s/([[:cntrl:]])/"^".chr(ord($1)+64)/ge;
    warn("$label: [$it]\n" . ((DBG) ? unpack("H*", $it) . "\n" : ''));
}

sub load_leveled_lists {
    my $levdat = {};
    my $leveled_list_cache_file = "$TES3::Util::TES3CMD_DIR/leveled_lists_cache.dat";
    # load cache
    if ($opt_no_cache) {
	unlink($leveled_list_cache_file)
	    if (-f $leveled_list_cache_file);
    } else {
	if (-f $leveled_list_cache_file) {
	    eval { $levdat = retrieve($leveled_list_cache_file); };
	    if ($@) {
		warn "Invalid Leveled Lists Cache, will rebuild\n";
		$levdat = {};
	    }
	} else {
	    warn "Creating Leveled Lists Cache\n";
	}
    }
    # Invalidate entire cache when codec changes
    if (defined($levdat->{_codec_version_}) and $levdat->{_codec_version_} ne $TES3::Record::CODEC_VERSION) {
	err "Invalidating Leveled List Cache due to CODEC update.";
	$levdat = {_codec_version_ => $TES3::Record::CODEC_VERSION };
    }
    my @load_order = $T3->load_order();
    my %active = map { lc($_), 1 } @load_order;
    foreach my $plugin (@load_order) {
	my $lc_plugin = lc($plugin);
	# skip known merged leveled lists plugins
	next if ($lc_plugin eq "multipatch.esp");
	next if ($lc_plugin eq "mashed lists.esp");
	next if ($lc_plugin eq "merged_leveled_lists.esp");
	my $curr_size = -s $T3->datapath($plugin);
	my $invalid = 0;
	if (defined($levdat->{$lc_plugin})) {
	    # update plugins that have changed size
	    unless ($curr_size == $levdat->{$lc_plugin}->{_size_}) {
		err "Leveled List Cache UPDATING: $plugin";
		delete $levdat->{$lc_plugin};
		$invalid = 1;
	    }
	} else {
	    # add plugins added to load order
	    prn "Leveled List Cache ADDING: $plugin" if (VERBOSE);
	    $invalid = 1;
	}
	if ($invalid) {
	    my $inp = open_for_read($T3->datapath($plugin));
	    eval {
		while (my($rectype, $rec, $flags) = read_rec($inp, undef)) {
		    last if (not defined $rectype);
		    next unless ($rectype =~ /^LEV[CI]$/);
		    next if ($flags & $REC_FLAGS{ignored});
		    my $tr = TES3::Record->new($plugin, $rectype, $rec, $flags);
		    $levdat->{$lc_plugin}->{$rectype}->{$tr->id()} = $tr;
		}
	    };
	    close($inp);
	    if ($@) {
		warn $@;
		delete $levdat->{$lc_plugin};
	    } else {
		$levdat->{$lc_plugin}->{_size_} = $curr_size;
	    }
	}
    }
    # delete plugins no longer in load order
    foreach my $plugin (keys %$levdat) {
	delete $levdat->{$plugin} unless ($active{$plugin});
    }
    # save cache
    unless ($opt_no_cache) {
	store($levdat, $leveled_list_cache_file);
    }
    return($levdat);
} # load_leveled_lists

###COMMANDS

sub cmd_codectest {
    my($plugin) = @_;
    return if ($plugin =~ /^test_/);
    my %exclude;
    if (@opt_codectest_excluded_type) {
	# optional types to exclude
	foreach (@opt_codectest_excluded_type) { $exclude{uc($_)}++; }
    }
    print "\n", ("=" x 65), "\n";
    print "TESTING codec on: $plugin ...\n";
    my $fun = sub {
	my($rectype, $rec, $flags, $unk, $rec_hdr, $wanted_ids, $wanted_types, $wanted_flags) = @_;
	my $tr = TES3::Record->new($plugin, $rectype, $rec, $flags, $unk, TES3::Record::STASHBUF);
	my $newrec = '';
	my $newflags = $flags;
	foreach my $tsr ($tr->subrecs()) {
	    my $oldsubrec = $tsr->getbuf();
	    my $newsubrec = $tsr->encode();
	    my $fulltype = $tsr->fulltype();
	    unless ($exclude{$fulltype}) {
		if ($newsubrec ne $oldsubrec) {
		    my $id = $tr->id();
		    my $subtype = $tsr->subtype();
		    warn "CODEC FAILURE on ($rectype:$id) subrecord ${subtype}:\n";
		    if (length($newsubrec) != length($oldsubrec)) {
			warn "Encoded length mismatch: subrec: @{[length($oldsubrec)]}  newrec: @{[length($newsubrec)]}\n";
		    }
		    dumpit('original', $oldsubrec);
		    dumpit('re-coded', $newsubrec);
		    warn Dumper($tsr);
		    die "Test Halted\n" unless ($opt_codectest_continue);
		}
	    }
	    $newrec .= pack("a4L/a*", $tsr->subtype(), $newsubrec);
	}
	unless ($exclude{$rectype}) {
	    if ($rec ne $newrec) {
		warn "CODEC FAILURE on record ${rectype}:\n";
		dumpit('original', $rec);
		dumpit('re-coded', $newrec);
		my $print_rec = $tr->tostr();
		warn "Full Record:\n$print_rec\n";
	    }
	    if ((my $new_hdr = pack("a4LLL", $rectype, length($rec), $unk, $newflags)) ne $rec_hdr) {
		warn "CODEC FAILURE on ${rectype} RECORD HEADER:\n";
		dumpit('original', $rec_hdr);
		dumpit('re-coded', $new_hdr);
		my $print_rec = $tr->tostr();
		warn "Full Record:\n$print_rec\n";
	    }
	}
	return($newrec, $newflags);
    };
    process_plugin_for_update($plugin, $fun, TES3::Record::STASHBUF, "test_");
} # cmd_codectest

sub cmd_fixit {
    # clean everything and replace originals
    $opt_clean_replace = $opt_clean_cell_objects = $opt_clean_cell_params = $opt_clean_dups = $opt_clean_gmsts = $opt_clean_junk_cells = 1;
    cmd_clean($_) foreach ($T3->load_order());
    # generate all patches
    $opt_multipatch_cellnames = $opt_multipatch_fogbug = $opt_multipatch_merge_lists = $opt_multipatch_summons_persist = 1;
    cmd_multipatch();
    # synchronize plugin headers to masters
    $opt_header_update_masters = $opt_header_update_record_count = 1;
    cmd_header($_) foreach ($T3->load_order());
}

sub cmd_wikiout {
    foreach my $cmd (sort keys %CMDS) {
	next if (($cmd eq 'help') or ($cmd =~ /^-/));
	my $usage = eval "\$@{[uc $cmd]}_USAGE";
	my $desc = $CMDS{$cmd}->[3];
	$usage =~ s/'/''/g;
	print "==$cmd - _${desc}_==\n{{{\n$usage\n}}}\n\n";
    }
}

sub multipatch_check_fogbug {
    my($plugin, $tr, $fogcell) = @_;
    my $name = $tr->id();
    my $fog_den_data = $tr->get_type('DATA','fog_density');
    my $fog_den_ambi = $tr->get_type('AMBI','fog_density');
    return unless (defined($fog_den_ambi) and defined($fog_den_data));
    if ($fog_den_ambi != $fog_den_data) {
	print "$plugin: [CELL $name] Warning, Fog Density in DATA ($fog_den_data) != AMBI ($fog_den_ambi)\n";
	# TBD - check CS to see which is dominant and change the wrong guy if dominant guy is 0.0
    }
    if (0.0 == $fog_den_data) {
	print "  [FOGBUG] $plugin\t\tCELL: $name\n" if (VERBOSE);
	$fogcell->{$name} = [$tr, $plugin];
    } else {
	if (defined($fogcell->{$name})) {
	    print qq{  [FOGBUG] CORRECTED $plugin CELL: $name\n} if (VERBOSE);
	    delete $fogcell->{$name};
	}
    }
}

sub multipatch_check_cell_rename_reversions {
    my($plugin, $tr, $rencell) = @_;
    my $name = $tr->get_type('NAME','name');
    my $coord = $tr->get_type('DATA','x') . ", " . $tr->get_type('DATA','y');
    if (exists $rencell->{$coord}->{NAME}) {
	my $prevname = $rencell->{$coord}->{NAME};
	if ($prevname ne $name) {
	    if ($name eq $rencell->{$coord}->{ORIGNAME}) {
		print qq{  [REVNAME] CELL: ($coord) RENAME REVERTED by: [$plugin] from: "$prevname" to: "$name". Reversion will be undone.\n} if (VERBOSE);
		$rencell->{$coord}->{OUTPUTFLAG}++;
	    } elsif ($name) {
		print qq{  [REVNAME] CELL: ($coord) Renamed by: [$plugin] from: "$prevname" to: "$name"\n} if (VERBOSE);
		my $prevname = $rencell->{$coord}->{NAME};
		my $prevplug = $rencell->{$coord}->{PLUG};
		print qq{  [REVNAME] CELL: ($coord) Replacing: [$prevplug]:"$prevname" with: [$plugin]:"$name"\n} if (VERBOSE);
		my $newrec = CELL->new([$tr->get_type('NAME'), $tr->get_type('DATA')])->encode();
		$rencell->{$coord}->{NAME} = $name;
		$rencell->{$coord}->{PLUG} = $plugin;
		$rencell->{$coord}->{REC} = ['CELL', $newrec, $tr->flags(), $tr->unk()];
	    } else {
		print qq{  [REVNAME] CELL: ($coord) Skipping null name: [$plugin]:"$name"\n} if (VERBOSE);
	    }
	}
    } else {
	$rencell->{$coord}->{ORIGNAME} = $name;
	$rencell->{$coord}->{ORIGPLUG} = $plugin;
	$rencell->{$coord}->{NAME} = $name;
	$rencell->{$coord}->{PLUG} = $plugin;
    }
} # multipatch_check_cell_rename_reversions

sub merge_leveled_lists {
    my @merged_lists;
    my $levdat = load_leveled_lists();
    my $ll = {};
    foreach my $plugin ($T3->load_order()) {
	my $lc_plugin = lc($plugin);
	if (defined($levdat->{$lc_plugin})) {
	    foreach my $rectype (qw(LEVC LEVI)) {
		foreach my $id (keys %{$levdat->{$lc_plugin}->{$rectype}}) {
		    my $tr = $levdat->{$lc_plugin}->{$rectype}->{$id};
		    push(@{$ll->{$rectype}->{$id}}, [$plugin, $tr]);
		}
	    }
	}
    }
    foreach my $rectype (qw(LEVC LEVI)) {
	foreach my $id (sort keys %{$ll->{$rectype}}) {
	    warn qq{DBG: examining $rectype: "$id"\n} if (DBG);
	    if (scalar(@{$ll->{$rectype}->{$id}}) == 1) {
		print " [LEVLIST] skipping $rectype $id - defined only once: [$ll->{$rectype}->{$id}->[0]->[0]]\n" if (VERBOSE);
		next;
	    }
	    my $last_tr = $ll->{$rectype}->{$id}->[-1]->[1];
	    # strategy: last guy wins for List Flags
	    my $last_list_flags = $last_tr->get({f=>"list_flags"});
	    # strategy: last guy wins for "Chance_None"
	    my $last_chance = $last_tr->get({f=>"chance_none"});
	    my %levlist;
	    foreach my $lref (@{$ll->{$rectype}->{$id}}) {
		my($plugin, $tr) = @$lref;
		my $element_id;
		my %levtmp;
		#warn "DBG: tr=".Dumper($tr)."\n";
		foreach my $tsr ($tr->subrecs()) {
		    my $subtype = $tsr->subtype();
		    if ($subtype eq 'CNAM') {
			$element_id = $tsr->{creature_id};
			#warn "DBG: CNAM element id: $element_id\n";
		    } elsif ($subtype eq 'INAM') {
			$element_id = $tsr->{item_id};
			#warn "DBG: INAM element id: $element_id\n";
		    } elsif ($subtype eq 'INTV') {
			my $level = $tsr->{level};
			#warn "DBG: element_id=$element_id  level=$level\n";
			$levtmp{$element_id}->{$level}++;
		    }
		}
		# replace old with the new
		#warn "DBG: ($id) levtmp = " . Dumper(\%levtmp) . "\n";
		$levlist{$_} = $levtmp{$_} foreach (keys %levtmp);
	    }
	    print " [LEVLIST] Defining $rectype $id ->\n" if (VERBOSE);
	    my @unsorted_list;
	    #warn "DBG: ($id) levlist = " . Dumper(\%levlist) . "\n";
	    foreach my $element_id (keys %levlist) {
		foreach my $level (keys %{$levlist{$element_id}}) {
		    my $count = $levlist{$element_id}->{$level};
		    for (my $i=0; $i < $count; $i++) {
			push(@unsorted_list, [$level, $element_id]);
		    }
		}
	    }
	    #warn "DBG: unsorted_list: " . Dumper(\@unsorted_list) . "\n";
	    # sort the leveled list by level, then by crea/item id
	    my @sorted_list;
	    foreach my $lref (sort {$a->[0] <=> $b->[0] or $a->[1] cmp $b->[1]} @unsorted_list) {
		my($level, $element_id) = @$lref;
		print "\t[lev=$level cre=$element_id]\n" if (VERBOSE);
		push(@sorted_list, [$element_id, $level]);
	    }
	    my $indx = scalar(@sorted_list);
	    my $newrec = [[NAME => { id => $id }],
			  [DATA => { list_flags => $last_list_flags }],
			  [NNAM => { chance_none => $last_chance }],
			  [INDX => { item_count => $indx }]];
	    my $tr;
	    if ($rectype eq 'LEVC') {
		$tr = LEVC->new($newrec);
		foreach my $lref (@sorted_list) {
		    my($element_id, $level) = @$lref;
		    $tr->append(LEVC::CNAM->new($tr, { creature_id => $element_id }),
				LEVC::INTV->new($tr, { level => $level }));
		}
	    } else {
		$tr = LEVI->new($newrec);
		foreach my $lref (@sorted_list) {
		    my($element_id, $level) = @$lref;
		    $tr->append(LEVI::INAM->new($tr, { item_id => $element_id }),
				LEVI::INTV->new($tr, { level => $level }));
		}
	    }
	    push(@merged_lists, $tr);
	}
    }
    return(\@merged_lists);
} # merge_leveled_lists

sub cmd_multipatch {
    print "Miss Multipatch says:\n" if (DBG or VERBOSE);
    print "Scanning Active Plugins...\n";
    my $patch_file = "multipatch.esp";
    my $patch_path = "$TES3::Util::DATADIR/$patch_file";
    my %fogcell;		# fogbugged cells
    my %rencell;		# cells with reverted renamings
    my %sumcrea;		# critters needing persistent flag
    my $merged_lists = merge_leveled_lists() if ($opt_multipatch_merge_lists);
    foreach my $plugin ($T3->load_order()) {
	next if ($plugin eq $patch_file);
	next if (($plugin eq "fogpatch.esp") or ($plugin eq "cellnamepatch.esp"));
	print "Scanning plugin: $plugin\n" if (DBG);
	my $inp = open_for_read($T3->datapath($plugin));
	my $expected = "TES3";
	eval {
	    while (my($rectype, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
		$expected = undef;
		last if (not defined $rectype);
		next if ($flags & $REC_FLAGS{ignored});
		if ($opt_multipatch_fogbug or $opt_multipatch_cellnames) {
		    if ($rectype eq 'CELL') {
			my $tr = TES3::Record->new($plugin, $rectype, $rec, $flags, $unk);
			if ($tr->is_interior()) {
			    # only check interior cells for fogbug
			    if ($opt_multipatch_fogbug) {
				unless ($tr->get_type('DATA', 'flags') & 128) { # behave like exterior
				    multipatch_check_fogbug($plugin, $tr, \%fogcell);
				}
			    }
			} else {
			    # only check exterior cells for rename reversion problem
			    if ($opt_multipatch_cellnames) {
				multipatch_check_cell_rename_reversions($plugin, $tr, \%rencell);
			    }
			}
		    }
		}
		if ($opt_multipatch_summons_persist) {
		    if ($rectype eq 'CREA') {
			my $tr = TES3::Record->new($plugin, $rectype, $rec, $flags, $unk);
			my $id = $tr->id();
			if ($SUMMONED_CREATURES{$id}) {
			    if ($flags & $REC_FLAGS{persistent}) {
				# plugin has preserved persistent flag
				print "  [SUMMCREA] $plugin PRESERVES persistence for: $id\n" if (VERBOSE);
				delete $sumcrea{$id};
			    } else {
				# plugin has voided persistent flag, so reset it
				print "  [SUMMCREA] $plugin REVERTS persistence for: $id\n" if (VERBOSE);
				$sumcrea{$id} = [$rec, ($flags | $REC_FLAGS{persistent}), $unk];
			    }
			}
		    }
		}
	    }
	};
	print $@ if ($@);
	close($inp);
    }
    my $nfogbugs = scalar keys %fogcell;
    my $nrenrevs = scalar(grep {defined} map {$_->{OUTPUTFLAG}} values(%rencell));
    my $nsumcrea = scalar keys %sumcrea;
    if ($nfogbugs or $nrenrevs or $nsumcrea or $merged_lists) {
	print "\n".("="x75)."\n";
	print "A multipatch has been conjured for you to address the following issues:\n";
	my $out = open_for_write($patch_path);
	print $out make_header({description => "MultiPatch\n\nVersion: $::VERSION"});
	if ($nrenrevs) {
	    print "\nPreserving the following $nrenrevs CELL renamings:\n";
	    foreach my $coord (keys %rencell) {
		if ($rencell{$coord}->{OUTPUTFLAG}) {
		    my $recref = $rencell{$coord}->{REC};
		    if ($recref) {
			print qq{  CELL: ($coord) -> NAME: "$rencell{$coord}->{NAME}"\n};
			write_rec($out, @{$recref});
		    }
		}
	    }
	}
	if ($nfogbugs) {
	    print qq{\nPatching $nfogbugs fogbugged cells:\n};
	    foreach my $name (sort keys %fogcell) {
		my($tr, $plugin) = @{$fogcell{$name}};
		print "  CELL: $name\t\t[$plugin]\n";
		# put in a non-zero fog density
		my $name_tsr = $tr->get_type('NAME');
		my $data_tsr = $tr->get_type('DATA');
		my $ambi_tsr = $tr->get_type('AMBI');
		$data_tsr->{fog_density} = $ambi_tsr->{fog_density} = 0.01;
		# write NAME, DATA, AMBI
		write_rec($out, 'CELL', CELL->new([$name_tsr, $data_tsr, $ambi_tsr])->encode(), 0, 0);
	    }
	}
	if ($nsumcrea) {
	    print "\nResetting the following $nsumcrea Summoned Creatures persistence:\n";
	    foreach my $id (sort keys %sumcrea) {
		print "  CREA: $id\n";
		my($newrec, $newflags, $unk) = @{$sumcrea{$id}};
		write_rec($out, 'CREA', $newrec, $newflags, $unk);
	    }
	}
	if ($merged_lists) {
	    my %count;
	    foreach my $tr (@$merged_lists) {
		$count{$tr->rectype()}++;
		write_rec($out, $tr->rectype(), $tr->encode(), 0, 0);
	    }
	    print "\nMerged Leveled Lists ($count{LEVC} LEVC, $count{LEVI} LEVI)\n";
	}
	close($out);
	$opt_header_update_record_count = 1;
	update_header($patch_path, QUIET);
	print qq{\nOutput is: "$patch_file", don't forget to activate it!\n};
    } else {
	print qq{\nNo patching necessary. "multipatch.esp" not generated.\n};
    }
} # cmd_multipatch

sub cmd_overdial {
    my(@plugins) = @_;
    my %dialog;
    foreach my $plugin (@plugins) {
	read_dialogs($plugin, \%dialog);
    }
    my @testplugins = ($opt_overdial_single) ? ($plugins[0]) : sort keys %dialog;
    foreach my $plugin1 (sort keys %dialog) {
	foreach my $plugin2 (@testplugins) {
	    if ($plugin1 ne $plugin2) {
		foreach my $id1 (keys %{$dialog{$plugin1}}) {
		    foreach my $id2 (keys %{$dialog{$plugin2}}) {
			if (length($id1) > length($id2) and $id1 =~ /\b$id2\b/i) {
			    printf qq{%-40s "$id1"\n%-40s "$id2"\n\n}, "$plugin1:", "$plugin2:";
			}
		    }
		}
	    }
	}
    }
}

# find objects in common between 2 plugins
sub cmd_common {
    my($plugin1, $plugin2) = @_;
    # swap plugins if plugin1 is larger than plugin2
    ($plugin1, $plugin2) = ($plugin2, $plugin1)
	if (-s $plugin1 > -s $plugin2);
    # read objects from smaller plugin
    my $objects1 = read_objects($plugin1);
    # compare to objects second plugin
    my $compare_fun = sub {
	my($rectype, $id) = @_;
	if ($objects1->{$rectype}->{$id} and ($rectype ne 'TES3')) {
	    warn "  $rectype: $id\n";
	}
    };
    read_objects($plugin2, $compare_fun);
}

sub output_diff {
    my($diff_file, $diff) = @_;
    if (@{$diff}) {
	my $fh = IO::Handle->new();
	if (open($fh, ">$diff_file")) {
	    print $fh join("\n", @{$diff});
	    close($fh);
	} else {
	    warn "Error opening $diff_file for output ($!)\n";
	}
    }
}

sub cmd_diff {
    my($plugin1, $plugin2) = @_;
    my $ignore;
    if (@opt_diff_ignore_type) {
	$ignore = '^(\s+(?:' . join('|', @opt_diff_ignore_type) . '):)\s.*$';
    }
    warn "IGNORE = $ignore\n" if (DBG);
    my $obj1 = read_objects($plugin1);
    my $obj2 = read_objects($plugin2);
    if (VERBOSE) {
	print "Plugin1: $plugin1\n";
	print "Plugin2: $plugin2\n";
    }
    my @p1_not_p2;	     # objects in plugin1 that do not exist in plugin2
    my @p2_not_p1;	     # objects in plugin2 that do not exist in plugin1
    my @p1_equal_p2;	     # objects in plugin1 that are equal in plugin2
    my @p1_diff_p2;	     # objects in plugin1 that are different in plugin2
    my @diffs;		     # detailed diffs
    my(@diff1, @diff2);
    foreach my $rectype (sort keys %{$obj1}) {
	next if ($rectype eq 'TES3');
	foreach my $id (sort keys %{$obj1->{$rectype}}) {
	    if (defined(my $rec2 = $obj2->{$rectype}->{$id})) {
		my $rec1 = $obj1->{$rectype}->{$id};
		my $print_rec1 = rec_to_string($rec1, $rectype, $id, $plugin1);
		$print_rec1 =~ s/$ignore/$1 (IGNORED)/gmi if ($ignore);
		$print_rec1 =~ s/CELL.FRMR: ObjIdx: \d+ ModIdx: 0/CELL.FRMR: ObjIdx: (IGNORED) ModIdx: 0/gm;
		my $print_rec2 = rec_to_string($rec2, $rectype, $id, $plugin2);
		$print_rec2 =~ s/$ignore/$1 (IGNORED)/gmi if ($ignore);
		$print_rec2 =~ s/CELL.FRMR: ObjIdx: \d+ ModIdx: 0/CELL.FRMR: ObjIdx: (IGNORED) ModIdx: 0/gm;
		if ($print_rec1 eq $print_rec2) {
		    push(@p1_equal_p2, "$rectype: $id") if ($opt_diff_equal);
		} elsif ($opt_diff_not_equal) {
		    push(@p1_diff_p2, "$rectype: $id");
		    push(@diff1, "\n$rectype: $id");
		    push(@diff1, $print_rec1);
		    push(@diff2, "\n$rectype: $id");
		    push(@diff2, $print_rec2);
		}
	    } else {
		push(@p1_not_p2, "$rectype: $id") if ($opt_diff_1_not_2);
	    }
	}
    }
    foreach my $rectype (sort keys %{$obj2}) {
	foreach my $id (sort keys %{$obj2->{$rectype}}) {
	    unless (defined $obj1->{$rectype}->{$id}) {
		push(@p2_not_p1, "$rectype: $id") if ($opt_diff_2_not_1);
	    }
	}
    }
    # now print the diff report
    if ($opt_diff_1_not_2 and my $n = @p1_not_p2) {
	print qq{\nRecords in "$plugin1" not in "$plugin2" ($n):\n};
	foreach (@p1_not_p2) { print "$_\n"; }
    }
    if ($opt_diff_2_not_1 and my $n = @p2_not_p1) {
	print qq{\nRecords in "$plugin2" not in "$plugin1" ($n):\n};
	foreach (@p2_not_p1) { print "$_\n"; }
    }
    if ($opt_diff_equal and my $n  = @p1_equal_p2) {
	print qq{\nRecords that are equal in "$plugin1" and "$plugin2" ($n):\n};
	foreach (@p1_equal_p2) { print "$_\n"; }
    }
    if ($opt_diff_not_equal) {
	my $diff1_file = fileparse($plugin1) . ".diff"; # get file basename
	my $diff2_file = fileparse($plugin2) . ".diff"; # get file basename
	if (my $n = @p1_diff_p2) {
	    print qq{\nRecords that are different between "$plugin1" and "$plugin2" ($n):\n(Compare $diff1_file to $diff2_file)\n};
	    foreach (@p1_diff_p2) {
		print "$_\n";
	    }
	}
	output_diff($diff1_file, \@diff1);
	output_diff($diff2_file, \@diff2);
    }
} # cmd_diff

sub cmd_delete {
    my($plugin) = @_;
    my $delete_subrecords = ($opt_sub_match or $opt_sub_no_match);
    my $delete_cell_objects = ($opt_cell_object_match or $opt_cell_object_no_match);
    my $fun = sub {
	my($rec_match, $rectype, $id, $rec, $srh, $flags, $unk, $rec_hdr, $print_rec) = @_;
	# we pass through all records that did not match the standard record selection switches of rec_match()
	return($rec, $flags) unless ($rec_match);
	if ($delete_subrecords) {
	    # we are processing sub-records
	    my $newrec = '';
	    foreach my $subr (@{parse_subrec_list($rec)}) {
		my($subtype, $subrec) = @{$subr};
		my $subrec_str = ($TOSTR{"$rectype.$subtype"} || $TOSTR{$subtype} || $TOSTR_UNK)->($subrec);
		if ($opt_sub_match or $opt_sub_no_match) {
		    if (((not $opt_sub_match) or ($subrec_str =~ /$opt_sub_match/i)) and
			((not $opt_sub_no_match) or ($subrec_str !~ /$opt_sub_no_match/i))) {
			print "[$rectype $id] DELETED SUBRECORD: $subrec_str\n";
		    } else {
			$newrec .= pack("a4L/a*", $subtype, $subrec);
		    }
		}
	    }
	    return($newrec, $flags);
	} elsif ($delete_cell_objects) {
	    my $newrec = '';
	    if ($rectype eq 'CELL') {
		my($cellhdr, $objs, $objidx) = parse_cell_objects($rec);
		my @new_objs;
		warn "objs: " . Dumper($objs) . "\n";
		foreach my $obj (@$objs) {
		    if ($obj eq 'NAM0') { push(@new_objs, $obj); next; }
		    my $objstr;
		    foreach my $subr (@{parse_subrec_list($obj->[1])}) {
			my($subtype, $subrec) = @{$subr};
			my $tostr = ($TOSTR{"$rectype.$subtype"} || $TOSTR{$subtype} || $TOSTR_UNK)->($subrec);
			$objstr .= "$subtype: $tostr\n";
		    }
		    warn "objstr = $objstr\n";
		    if (((not $opt_cell_object_match) or ($objstr =~ /$opt_cell_object_match/i)) and
			((not $opt_cell_object_no_match) or ($objstr !~ /$opt_cell_object_no_match/i))) {
			my $obj_info = chop_nulls(parse_subrec_hash($obj->[1])->{NAME}[0]) . " FRMR:" . $obj->[0]->[0];
			print "[CELL: $id] DELETED CELL OBJECT: $obj_info\n";
		    } else {
			push(@new_objs, $obj);
		    }
		}
		$newrec = assemble_cell_objects($cellhdr, \@new_objs);
	    } else {
		return($newrec, $flags);
	    }
	} else {
	    # we are deleting whole records
	    $print_rec ||= rec_to_string($rec, $rectype, $id, $plugin, $flags, $unk);
	    print "\nDELETED RECORD:$print_rec\n";
	    return(undef);
	}
    };
    process_plugin_for_update($plugin, $fun);
} # cmd_delete

sub cmd_modify {
    my($plugin) = @_;
    # load Perl program if specified with --program-file
    if ($opt_modify_program_file) {
	unless (do $opt_modify_program_file) {	# execute perl file
	    die "Error processing $opt_modify_program_file ($@)\n" if ($@);
	}
	$opt_modify_run = 'main($rectype, $r, $flags, $unk);' unless ($opt_modify_run);
    }
    $opt_match ||= '.'; 		# default is to match any record.
    my($inp, $out) = make_temp($plugin);
    my $expected = "TES3";
    my($wanted_ids, $wanted_types, $wanted_flags) = get_wanted();
    my $modified = 0;
    eval {
	while (my($rectype, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if (not defined $rectype);
	    next if ($wanted_flags and not ($flags & $wanted_flags));
	    warn "REC=$rectype flags=$flags\n" if (DBG);
	    my $nomodify = 0;
	    my $recid;
	    my $srh;
	    if ($wanted_ids) {
		$srh ||= parse_subrec_hash($rec);
		$recid = rec_id($srh, $rectype);
		$nomodify = 1 if ($recid !~ /$wanted_ids/i);
	    }
	    $nomodify = 1 if ($wanted_types and not $wanted_types->{$rectype});
	    if ($nomodify) {
		write_rec($out, $rectype, $rec, $flags, $unk);
		next;
	    }
	    if ($rectype eq 'CELL') {
		$srh ||= parse_subrec_hash($rec);
		if (is_interior($srh)) {
		    next if ($opt_exterior);
		} else {
		    next if ($opt_interior);
		}
	    }
	    my $p = 0;
	    my $rec_len = length($rec);
	    my $first = 1;
	    my $print_rec = "";
	    my $newrec = "";
	    my @subrecs = ();
	    while ($p < $rec_len) {
		my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
		$p += 8;
		my $subrec = substr($rec, $p, $subrec_len);
		$p += $subrec_len;
		if (defined $subrec) {
		    my $full_type = "${rectype}.${subrec_type}";
		    unless ($wanted_types and not $wanted_types->{$rectype}) {
			my $tostr = $TOSTR{$full_type} || $TOSTR{$subrec_type} || $TOSTR_UNK;
			my($hr) = decoder($rectype, $subrec_type)->($subrec); # TBD - nuke
			my $subrec_str = $tostr->($subrec);
			if ($opt_sub_match or $opt_sub_no_match) {
			    if (((not $opt_sub_match) or ($subrec_str =~ /$opt_sub_match/i)) and
				((not $opt_sub_no_match) or ($subrec_str !~ /$opt_sub_no_match/i))) {
				# subrecord matches, so run our code on it ...
				warn "full_type=$full_type\n";
				if (my $newhr = run_code($full_type, $hr)) { # TBD - nuke
				    my $encoder = encoder($rectype, $subrec_type);
				    $subrec = $encoder->($newhr);
				    $modified++;
				    $subrec_str = $tostr->($subrec);
				    warn "MODIFIED SUBRECORD: $subrec_str\n";
				} else {
				    $subrec = undef;
				}
			    }
			}
			push(@subrecs, [$subrec_type, $hr]); # TBD - nuke
			$print_rec .= "   $full_type: $subrec_str\n";
		    }
		    $newrec .= pack("a4La*", $subrec_type, $subrec_len, $subrec);
		} else {
		    my $id = rec_id(parse_subrec_hash($rec), $rectype);
		    warn "$plugin: Error, malformed subrec for ($rectype $id) type=$subrec_type pos=$p len=$subrec_len\n";
		}
	    }
	    if ($opt_sub_match or $opt_sub_no_match) {
		write_rec($out, $rectype, $newrec, $flags, $unk);
	    } else {
		if (((not $opt_match) or ($print_rec =~ /$opt_match/i)) and
		    ((not $opt_no_match) or ($print_rec !~ /$opt_no_match/i))) {
		    $R = \@subrecs; # TBD - nuke
		    if (my $modrec = run_code($rectype, $flags, $unk)) {
			#warn "Record was modified, encoding modified record\n";
			my $newrec = '';
			$newrec = encode_rec($rectype, $modrec);
			if ($newrec ne $rec) {
			    $rec = $newrec;
			    my $id = rec_id(parse_subrec_hash($rec), $rectype);
			    warn "MODIFIED RECORD:\n" . rec_to_string($rec, $rectype, $id, $plugin, $flags, $unk) . "\n";
			    $modified++;
			}
		    }
		}
		write_rec($out, $rectype, $rec, $flags, $unk);
	    }
	}
    };
    if ($@) {
	warn $@;
	$modified = 0;
    }
    fix_output($inp, $out, $plugin, $modified);
} # cmd_modify

sub cmd_rename {
    my($plugin) = @_;
    my($inp, $out) = ($opt_report_only) ? open_for_read($plugin) : make_temp($plugin);
    my $modified = 0;
    unless ($opt_report_only) {
	warn "\n$plugin: RENAMING Records:\n";
    }
    my $expected = "TES3";
    eval {
	while (my($rectype, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin)) {
	    $expected = undef;
	    last if (not defined $rectype);
	    next if ($flags & $REC_FLAGS{ignored});
	    warn "REC=$rectype flags=$flags\n" if (DBG);
	    if ($rectype eq 'SCPT') {
		my $renamed_schd = 0;
		my $renamed_sctx = 0;
		my $srl = parse_subrec_list($rec);
		foreach my $subrec (@{$srl}) {
		    my $subtype = $subrec->[0];
		    if ($subtype eq "SCHD") {
			my($name, @schd_longs) = unpack("Z32L5", $subrec->[1]);
			if ($opt_report_only) { # only list records
			    printf qq{  $rectype.$subtype  %-30s\n}, $name;
			} else {
			    my $newname;
			    eval qq{(\$newname = \$name) =~ s!$RENAME_FROM!$RENAME_TO!g};
			    if (length($newname) < 32) {
				if ($name ne $newname) {
				    $subrec->[1] = pack("a32L5", $newname, @schd_longs);
				    $renamed_schd = 1;
				    printf qq{    Renaming: $rectype.$subtype %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
				}
			    } else {
				warn qq{New name for script: "$newname" is too long, must be less than 32 bytes\n};
			    }
			}
		    } elsif ($subtype eq "SCTX") {
			my $script = $subrec->[1];
			my $name = ($script =~ m!^[^;]*?\bbegin\s+(\S+)!im) ? $1 : "unknown";
			if ($opt_report_only) { # only list records
			    printf qq{  $rectype.$subtype  %-30s\n}, $name;
			} else {
			    my $newname;
			    eval qq{(\$newname = \$name) =~ s!$RENAME_FROM!$RENAME_TO!g};
			    if ($name ne $newname) {
				$script =~ s/^[^;]*?\bbegin\s+(\S+)/Begin $newname/im;
				$subrec->[1] = $script;
				$renamed_sctx = 1;
				printf qq{    Renaming: $rectype.$subtype %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			    }
			}
		    }
		}
		unless ($opt_report_only) {
		    if ($renamed_schd and $renamed_sctx) {
			$modified++;
			$rec = new_rec($srl);
		    } else {
			my $what = "";
			$what .= " SCHD" unless $renamed_schd;
			$what .= " SCTX" unless $renamed_sctx;
			warn "Error renaming$what, record NOT updated.\n";
		    }
		}
	    } elsif ($rectype eq $RENAME_TYPE) {
		my $renamed = 0;
		my $srl = parse_subrec_list($rec);
		my $name_idx = ($srl->[0]->[0] eq 'NAME') ? 0 : undef;
		if (defined($name_idx) and
		    my $name = chop_nulls($srl->[$name_idx]->[1])) {
		    if ($opt_report_only) { # only list records
			my $recstr = pprec($rec, $RENAME_SUBTYPE);
			printf qq{  $rectype  %-30s [%s]\n}, $name, $recstr;
		    } else {	# rename records
			my $do_rename = 1;
			$do_rename = 0 if ($rectype eq "CELL" and not allowed_cell_type($srl));
			if ($do_rename) {
			    my $newname;
			    eval qq{(\$newname = \$name) =~ s!$RENAME_FROM!$RENAME_TO!g};
			    if ($name ne $newname) {
				$srl->[$name_idx]->[1] = "$newname\000";
				$renamed = 1;
				$modified++;
				printf qq{    Renaming: $RENAME_TYPE %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			    }
			}
		    }
		} else {
		    warn "Error, Record has no $RENAME_SUBTYPE subrecord: $rec\n";
		}
		$rec = new_rec($srl) if $renamed;
	    }
	    write_rec($out, $rectype, $rec, $flags, $unk) unless ($opt_report_only);
	}
    };
    if ($@) {
	warn $@;
	$modified = 0;
    }
    if ($opt_report_only) {
	cleanup_temp($inp, $plugin);
    } else {
	fix_output($inp, $out, $plugin, $modified);
    }
} # cmd_rename

sub cmd_header {
    my($plugin) = @_;
    update_header($plugin);
}

sub convert_plugin {
    my($input) = @_;
    my $output;
    my $byte_expected;
    my $byte_new;
    if ($input =~ /\.esp$/i) {
	# convert plugin to master
	$byte_expected = "\000";
	$byte_new = "\001";
	($output = $input) =~ s/\.esp$/.esm/i;
    } else {
	# convert master to plugin
	$byte_expected = "\001";
	$byte_new = "\000";
	($output = $input) =~ s/\.esm$/.esp/i;
    }
    die qq{Error, $output already exists! (Use --overwrite to overwrite)\n}
	if (-f $output and not $opt_overwrite);
    copy($input, $output) or die "Error, copy failed $input -> $output ($!)\n";
    eval {
	open(OUT, "+<$output") or die qq{Error opening "$output" for read/write ($!)};
	binmode(OUT) or die "Error setting binmode on $output ($!)";
	my $magic;
	(sysread(OUT, $magic, 4) == 4) or die "$output: Error reading magic ($!)";
	if ($magic eq "TES3") {
	    sysseek(OUT, 28, SEEK_SET) or die "sysseek";
	    my $byte;
	    (sysread(OUT, $byte, 1) == 1) or die "$output: Error reading master byte ($!)\n";
	    my $val = unpack("C", $byte);
	    #warn "masterbyte = $val\n";
	    ($byte eq $byte_expected) or
		die qq{Error, expected master byte value of @{[unpack("C",$byte_expected)]}, got $val instead};
	    sysseek(OUT, 28, SEEK_SET) or die "sysseek";
	    (syswrite(OUT, $byte_new, 1) == 1) or die "$output: Error writing master byte ($!)\n";
	} elsif ($magic eq "TES4") {
	    die "This function is not yet implemented for TES4 files";
	} else {
	    die "$output: Error, this does not appear to be Morrowind plugin";
	}
	close(OUT);
    };
    if ($@) {
	warn "$@\n";
	close(OUT);
	unlink($output);
	return;
    }
    my($atime, $mtime) = (stat($input))[8,9];
    utime($atime, $mtime, $output);
    warn "$input copied to $output\n"
} # convert_plugin

# convert a master to a plugin
sub cmd_esp {
    my($master) = @_;
    die "Error, input must be a master (.esm)\n"
	unless ($master =~ /\.esm$/i);
    convert_plugin($master);
}

# convert a plugin to a master
sub cmd_esm {
    my($plugin) = @_;
    die "Error, input must be a plugin (.esp)\n"
	unless ($plugin =~ /\.esp$/i);
    convert_plugin($plugin);
}

my %gmst_type = ('i' => 'INTV', 'f' => 'FLTV', 's' => 'STRV');
sub cmd_clean {
    my($plugin) = @_;
    if ($plugin =~ /\.ess$/) {
	warn "Skipping $plugin: don't know how to clean savegames ... yet.\n";
	return;
    }
    if ($plugin =~ /~\d+\.es[mps]$/i) {
	warn "Skipping $plugin: because it's a backup.\n";
	return;
    }
    if (my $reason = $CLEAN_PLUGIN{lc($plugin)}) {
	warn "Skipping $plugin: ${reason}.\n";
	return;
    }
    print qq{\nCLEANING: "$plugin" ...\n};
    my %duptype = map { $_, 1 } @CLEAN_DUP_TYPES;
    my %my_master;
    my $fun = sub {
	my($rec_match, $rectype, $id, $rec, $srh, $flags, $unk) = @_;
	my $newrec = $rec;
	my $newflags = $flags;
	my $r;
	if ($rectype eq 'GMST') {
	    if ($opt_clean_gmsts) {
		my $type = $gmst_type{substr($id, 0, 1)};
		my $val = $srh->{$type}[0];
		my $hexval = unpack("H*", "$type $val");
		if (defined($EVIL_BM{$id}) and ($EVIL_BM{$id} eq $hexval)) {
		    print " Cleaned Evil GMST Bloodmoon: $id\n";
		    return;
		} elsif (defined($EVIL_TB{$id}) and ($EVIL_TB{$id} eq $hexval)) {
		    print " Cleaned Evil GMST Tribunal:  $id\n";
		    return;
		}
	    }
	} elsif ($rectype eq 'CELL') {
	    my $cleaned_ambi;
	    my $cleaned_whgt;
	    my $plug_srl;
	    if ($opt_clean_cell_objects) {
		# CLEAN CELL OBJECTS
		my($p_hdr, $p_objs, $p_objidx) = parse_cell_objects($rec);
		my @new_objs;
		foreach my $obj (@$p_objs) {
		    if ($obj eq 'NAM0') { push(@new_objs, $obj); next; }
		    my $object_body = $obj->[1];
		    my $cleaned_obj = 0;
		    foreach my $master (keys %{my_master}) {
			if (my $lref = $MASTER_ID->{$master}->{$id}->{CELL}) {
			    my($mast_srh, $mast_rec) = @{$lref};
			    my($m_hdr, $m_objs, $m_objidx) = parse_cell_objects($mast_rec);
			    if ($m_objidx->{$object_body}->[0] == $obj->[0]->[0]) { # compare master and plugin FRMR object indices
				$cleaned_obj++;
				last;
			    }
			}
		    }
		    if ($cleaned_obj) {
			my $obj_info = chop_nulls(parse_subrec_hash($obj->[1])->{NAME}[0]) . " FRMR:" . $obj->[0]->[0];
			print " Cleaned redundant object ($obj_info) from CELL: $id\n";
		    } else {
			push(@new_objs, $obj);
		    }
		}
		if (scalar(@new_objs) != scalar(@$p_objs)) {
		    $rec = assemble_cell_objects($p_hdr, \@new_objs);
		    $r = decode_rec($plugin, $rectype, $rec);
		    $plug_srl = parse_subrec_list($rec);
		}
	    }
	    # we check plugin against all masters, as we can't know with which masters the author created it
	    # and ideally, we don't want the result of cleaning to be dependent on load order.
	    foreach my $master (keys %{my_master}) {
		if (my $lref = $MASTER_ID->{$master}->{$id}->{CELL}) {
		    my($mast_srh, $mast_rec) = @{$lref};
		    if (is_interior($srh)) {
			if ($opt_clean_cell_params) { # check for redundant AMBI/WHGT
			    # CLEAN AMBI
			    $r ||= decode_rec($plugin, $rectype, $rec);
			    unless ($cleaned_ambi) {
				if (defined($srh->{AMBI}) and ($srh->{AMBI}[0] eq $mast_srh->{AMBI}[0])) {
				    $r = remove_subrec($r, 'AMBI');
				    $cleaned_ambi++;
				}
			    }
			    # CLEAN WHGT
			    # (some plugins, like Morrowind.esm, use an INTV subrecord instead of WHGT)
			    unless ($cleaned_whgt) {
				my $plugin_whgt = (defined($srh->{WHGT}) and $srh->{WHGT}[0]) ? unpack("f", $srh->{WHGT}[0]) : undef;
				my $whgt_type = 'WHGT';
				unless (defined $plugin_whgt) {
				    $plug_srl ||= parse_subrec_list($rec);
				    if ($plug_srl->[2]->[0] eq 'INTV') {
					# this would be unusual. I think INTV water heights must be from very old Construction Sets.
					$plugin_whgt = unpack("l", $plug_srl->[2]->[1]);
					$whgt_type = 'INTV';
				    }
				}
				my $master_whgt = ($mast_srh->{WHGT}[0]) ? unpack("f", $mast_srh->{WHGT}[0]) : undef;
				unless (defined $master_whgt) {
				    my $mast_srl = parse_subrec_list($mast_rec);
				    if ($mast_srl->[2]->[0] eq 'INTV') {
					$master_whgt = unpack("l", $mast_srl->[2]->[1]);
				    }
				}
				if (defined($plugin_whgt) and defined($master_whgt) and ($plugin_whgt == $master_whgt)) {
				    $r = remove_subrec($r, $whgt_type, 1);
				    $cleaned_whgt++;
				}
			    }
			}
		    }
		    if ($opt_clean_junk_cells) {
			if ((scalar keys %{$srh}) < 4) {
			    # junk cells always contain less than 4 subrecords
			    my $modified = 0;
			    for my $type (keys %{$srh}) {
				if (not $JUNKCELL_SUBTYPE{$type} or
				    $srh->{$type}[0] ne $mast_srh->{$type}[0]) {
				    # record contains subrecords or some modified data, so it isn't junk
				    $modified++;
				    last;
				}
			    }
			    unless ($modified) {
				print " Cleaned Junk CELL:  $id\n";
				return;
			    }
			}
		    }
		}
	    }
	    my @what;
	    push(@what, 'AMBI') if ($cleaned_ambi);
	    push(@what, 'WHGT') if ($cleaned_whgt);
	    if (@what) {
		print " Cleaned redundant " . join(',', @what) . " from CELL: $id\n";
	    }
	} elsif ($rectype eq 'TES3') {
	    foreach my $mast (@{$srh->{MAST}}) {
		my $master = chop_nulls($mast);
		$my_master{lc($master)}++;
		load_master($master);
	    }
	}
	if ($opt_clean_dups) {
	    foreach my $master (keys %{my_master}) {
		if (my $lref = $MASTER_ID->{$master}->{$id}->{$rectype}) {
		    my($mast_srh, $mast_rec, $mast_flags) = @{$lref};
		    if ($duptype{$rectype} and ($rec eq $mast_rec) and ($flags eq $mast_flags)) {
			print " Cleaned Duplicate $rectype:  $id\n";
			return;
		    }
		}
	    }
	}
	$newrec = encode_rec($rectype, $r) if ($r); # update record buffer if we have modified it
	return($newrec, $newflags);
    };
    if ($opt_clean_replace) {
	process_plugin_for_update($plugin, $fun);
    } else {
	process_plugin_for_update($plugin, $fun, undef, "Clean_");
    }
} # cmd_clean

sub cmd_dump {
    my($plugin) = @_;
    my $dump_banner;
    unless ($opt_no_banner) {
	$dump_banner = "\nPlugin: $plugin\n";
	$dump_banner = "#(Codec_Version: $TES3::Record::CODEC_VERSION)\n$dump_banner" if ($opt_dump_canon);
    }
    my $fun = sub {
	my($rectype, $rec, $flags, $unk, $rec_hdr, $wanted_ids, $wanted_types, $wanted_flags) = @_;
	my($rec_match, $tr, $print_rec) = rec_match($plugin, $rectype, $rec, $flags, $unk, $wanted_ids, $wanted_types, $wanted_flags);
	return unless ($rec_match);
	my $unkstr = (DBG) ? sprintf("  Unk:%04x", $unk) : '';
	my $id = $tr->id();
	if ($dump_banner) {
	    print $dump_banner;
	    $dump_banner = "";
	}
	if ($opt_dump_canon) {
	    # print new canonical dump format
	    my $flagstr = decode_flags($flags, \%REC_FLAGS);
	    my $dial_str = ($rectype eq 'INFO') ? " $CURRENT_DIAL" : '';
	    print qq{\nRecord: $rectype "$id"$dial_str Flags: $flagstr${unkstr}\n};
	    $tr->dump();
	} else {
	    # pretty print
	    $print_rec ||= $tr->tostr();
	    if ($opt_list) {
		if ($rectype eq 'CELL') {
		    my $objcnt = (defined $tr->{SH}->{FRMR}) ? scalar(@{$tr->{SH}->{FRMR}}) : 0;
		    printf "$rectype: %-45s\t%5d objects\n", $id, $objcnt;
		} else {
		    print "$rectype: $id\n";
		}
	    } elsif ($opt_dump_raw) {
		if ($opt_cell_object_match and ($rectype eq 'CELL')) {
		    my @frmr_data;
		    my $frmr_match = 0;
		    my @newrec = ();
		    my $first_frmr_seen = 0;
		    my $subrec_str = '';
		    my $tostr;
		    foreach my $tsr ($tr->subrecs()) {
			my $subtype = $tsr->subtype();
			$subrec_str .= $tsr->tostr();
			if ($first_frmr_seen) {
			    if ($subtype eq 'FRMR') {
				if ($subrec_str =~ /$opt_cell_object_match/i) {
				    $frmr_match++;
				    push(@newrec, @frmr_data);
				}
				$subrec_str = '';
				@frmr_data = (); # start a new group
			    }
			    push(@frmr_data, pack("a4L/a", $subtype, $tsr->getbuf()));
			} else {
			    if ($subtype eq 'FRMR') {
				$first_frmr_seen = 1;
				push(@frmr_data, pack("a4L/a", $subtype, $tsr->getbuf()));
			    } else {
				push(@newrec, pack("a4L/a", $subtype, $tsr->getbuf()));
			    }
			}
		    }
		    if ($subrec_str =~ /$opt_cell_object_match/i) {
			$frmr_match++;
			push(@newrec, @frmr_data);
		    }
		    if ($frmr_match) {
			my $newrec = join("", @newrec);
			print $RAWOUT pack("a4LLLa*", $rectype, length($newrec), $unk, $flags, $newrec);
		    }
		} else {
		    print $RAWOUT pack("a4LLLa*", $rectype, length($rec), $unk, $flags, $rec);
		}
	    } else {
		print "\n$print_rec\n" if ($print_rec);
	    }
	}
    };
    process_plugin_for_read($plugin, $fun, ($opt_dump_raw) ? TES3::Record::STASHBUF : undef);
} # cmd_dump

sub cmd_recover {
    my($plugin) = @_;
    my($inp, $out) = make_temp($plugin);
    my $typlen = $RECTYPE_LEN - 1;
    my $buff;
    my $buff_size = 4096;
    my $expected = "TES3";
    my $inp_len = sysseek($inp, 0, SEEK_END); # seek to end
    my $inp_offset = sysseek($inp, 0, SEEK_SET); # seek to start
    my $rectypes = join('|', keys %TES3::Record::RECTYPES);
    print qq{$plugin: length = $inp_len\n};
    my @removed;
  READREC:
    while ($inp_offset < $inp_len) {
	my($rectype, $rec, $flags, $unk);
	eval {
	    ($rectype, $rec, $flags, $unk) = read_rec($inp, $expected, $plugin);
	    $expected = undef;
	    die "Error, Invalid record type: $rectype\n" unless ($TES3::Record::RECTYPES{$rectype});
	    my $srh = parse_subrec_hash($rec);
	    foreach my $subtype (keys %$srh) {
		die qq{Error, Invalid record subtype: "$subtype"\n} unless ($TES3::Record::RECTYPES{$rectype}->{$subtype});
	    }
	    my $id = rec_id($srh, $rectype);
	    printf "Offset: %8d  Found: $rectype $id\n", $inp_offset if (DBG);
	};
	if ($@) {
	    warn $@;
	    # start a scan from last input offset for something that looks like a record header
	    my $start_offset = $inp_offset;
	    print qq{READ ERROR on record starting at: $start_offset\n};
	    $inp_offset = sysseek($inp, $inp_offset + 1, SEEK_SET);
	    print qq{Scanning for records from: $inp_offset\n};
	    while (1) {
		my $n_read = sysread($inp, $buff, $buff_size + $typlen);
		last READREC if ($n_read == 0); # EOF
		if (my($stuff, $rectype) = split(/($rectypes)/, $buff)) {
		    my $new_offset = $inp_offset + length($stuff);
		    print qq{Scan found $rectype at: $new_offset\n};
		    $inp_offset = sysseek($inp, $new_offset, SEEK_SET);
		    push(@removed, [$start_offset, $new_offset]);
		    last;
		} else {
		    # Just in case record header started at end boundary, back up by len of rec ID
		    $inp_offset = sysseek($inp,  0 - $typlen, SEEK_CUR) if ($n_read == ($buff_size + $typlen));
		}
	    }
	} else {
	    # everything was AOK
	    write_rec($out, $rectype, $rec, $flags, $unk);
	    $inp_offset = sysseek($inp, 0, SEEK_CUR); # set inp_offset to current seek position
	}
    }
    if (@removed) {
	my $n = scalar(@removed);
	print "Recovery removed $n section@{[($n > 1) ? 's' : '']} of bad data:\n";
	my $total = 0;
	foreach my $chunk (@removed) {
	    my $lost = $chunk->[1] - $chunk->[0];
	    printf "  From: %8d To: %8d  (lost %d bytes)\n",
		$chunk->[0], $chunk->[1], $lost;
	    $total += $lost;
	}
	if (scalar(@removed) > 1) {
	    print "Total bytes lost: $total\n";
	}
	fix_output($inp, $out, $plugin, 1);
    } else {
	print "Recovery found no bad data in $plugin\n";
	cleanup_temp($inp, $plugin);
    }
} # cmd_recover

sub cmd_shell {
    no strict;
    $| = 1;
    print "> ";
    my $perlstuff = '';
    my $done = 0;
    while (<>) {
	$perlstuff = join('', $perlstuff, $_);
	if (/^$/ or ($perlstuff =~ /^[^\n]*;$/)) {
	    my $result = eval($perlstuff);
	    if ($@) {
		print "psh ERROR: $@\n> ";
	    } else {
		print "\n==> $result\n" if ($result);
		print "> ";
	    }
	    # clear out buffer
	    $perlstuff = '';
	} else {
	    print "- ";
	}
    }
}

sub main {
    die $USAGE_ALL if ((scalar(@ARGV) == 0) or
		       (scalar(@ARGV) == 1 and $ARGV[0] =~ /help/i));
    my $cmd_ref;
    my $cmd_name = shift(@ARGV);
    die $USAGE_ALL unless ($cmd_ref = $CMDS{$cmd_name});
    my($cmd_getopts, $cmd, $type) = @{$cmd_ref};
    $cmd_getopts->();
    my @plugins;
    foreach my $arg (@ARGV) {
	if ($arg =~ /[$GLOBCHARS]/) {
	    push(@plugins, glob($arg));
	} else {
	    push(@plugins, $arg);
	}
    }
    if ($opt_output_dir and not -d $opt_output_dir) {
	eval { mkdir($opt_output_dir, 0755); };
	die $@ if ($@);
    }
    if ($type eq 'm') {
	# these commands process multiple plugins at once
	$cmd->(@plugins);
    } else {		    # type eq 's'
	# put plugins in load order
	@plugins = sort { -M $b <=> -M $a } @plugins;
	# these commands process a single plugin at a time
	die $USAGE_ALL if (scalar(@plugins) == 0);
	for my $plugin (@plugins) {
	    $cmd->($plugin);
	}
    }
} # main

main();
