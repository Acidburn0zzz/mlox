#!/usr/bin/perl
#Version: 0.2
# tes3cmd: command line tool to do various hackage on a TES3 plugin
# Copyright 2009 by John Moonsugar
# Distributed as part of the mlox project:
#   http://code.google.com/p/mlox/
# under the MIT License:
#   http://code.google.com/p/mlox/source/browse/trunk/License.txt

use Getopt::Std;
use strict;

BEGIN {
    # since perl will optimize out conditional branches that are never
    # reached, we define the following constants so that we only compile
    # debug/help code into the program when it it actually needed.
    use constant DBG => grep(/^(?:-D)$/, @ARGV);
}

my $COM_USAGE = q{Usage: tes3cmd common OPTIONS plugin1 plugin2

OPTIONS
 -D   turn on debug output

Prints the IDs of records that the 2 given plugins have in common.

Example:

# Show what is common between my plugin and Morrowind.esm:
tes3cmd common myplugin.esp Morrowind.esm
};

sub opts_com {
    $_[0] && do { warn $COM_USAGE; exit(0); };
    getopts('D') or die $COM_USAGE;
}


my $DUMP_USAGE = q{Usage: tes3cmd dump OPTIONS plugin...

OPTIONS
 -D        turn on debug output
 -i ids    only print out the ids matching the given comma-delimited list
           of regular expression patterns.
 -t types  only print out the records matching the given comma-delimted
           list of record types.

Dumps the plugin to stdout in text form for easy perusal. For large plugins,
the output can be voluminous.

Examples:

# Dump all records from a plugin:
tes3cmd dump plugin.esp

# Dump all records whos IDs match "foo":
tes3cmd dump -i foo plugin.esp

# Dump all the CELL records from a plugin:
tes3cmd dump -t cell plugin.esp
};

my %INFO_SCVR_type =
    ('0' => "Nothing",
     '1' => "Function",
     '2' => "Global",
     '3' => "Local",
     '4' => "Journal",
     '5' => "Item",
     '6' => "Dead",
     '7' => "Not ID",
     '8' => "Not Faction",
     '9' => "Not Class",
     'A' => "Not Race",
     'B' => "Not Cell",
     'C' => "Not Local");

my %INFO_SCVR_cmp =
    ('0' => '=',
     '1' => '!=',
     '2' => '>',
     '3' => '>=',
     '4' => '<',
     '5' => '<=');

my %SEX = (0 => "Male", 1 => "Female", 0xFF => "None");
my %SPECIALIZATION = (0 => "Combat", 1 => "Magic", 2 => "Stealth");

my %SKILL = ( 0 => "Block",
	      1 => "Armorer",
	      2 => "Medium Armor",
	      3 => "Heavy Armor",
	      4 => "Blunt Weapon",
	      5 => "Long Blade",
	      6 => "Axe",
	      7 => "Spear",
	      8 => "Athletics",
	      9 => "Enchant",
	     10 => "Destruction",
	     11 => "Alteration",
	     12 => "Illusion",
	     13 => "Conjuration",
	     14 => "Mysticism",
	     15 => "Restoration",
	     16 => "Alchemy",
	     17 => "Unarmored",
	     18 => "Security",
	     19 => "Sneak",
	     20 => "Acrobatics",
	     21 => "Light Armor",
	     22 => "Short Blade",
	     23 => "Marksman",
	     24 => "Mercantile",
	     25 => "SpeechCraft",
	     26 => "HandToHand");

my %ATTRIBUTE = (0 => "Strength",
		 1 => "Intelligence",
		 2 => "Willpower",
		 3 => "Agility",
		 4 => "Speed",
		 5 => "Endurance",
		 6 => "Personality",
		 7 => "Luck");

my @AUTOCALC_FLAGS = ([0x00001 => "Weapon"],
		      [0x00002 => "Armor"],
		      [0x00004 => "Clothing"],
		      [0x00008 => "Books"],
		      [0x00010 => "Ingredient"],
		      [0x00020 => "Picks"],
		      [0x00040 => "Probes"],
		      [0x00080 => "Lights"],
		      [0x00100 => "Apparatus"],
		      [0x00200 => "Repair"],
		      [0x00400 => "Misc"],
		      [0x00800 => "Spells"],
		      [0x01000 => "Magic Items"],
		      [0x02000 => "Potions"],
		      [0x04000 => "Training"],
		      [0x08000 => "Spellmaking"],
		      [0x10000 => "Enchanting"],
		      [0x20000 => "Repair Item"]);

sub list_autocalc_flags {
    my($flags) = @_;
    my @list = ();
    foreach my $ref (@AUTOCALC_FLAGS) {
	my($val, $name) = @$ref;
	push(@list, $name) if ($flags & $val);
    }
    return(join(", ", @list));
}

my $NREC;

my $DEFAULT_UNPACK = 
    sub { "hex:" . unpack("h*", $_[0]) . '  str:"' . substr((($_ = $_[0]) =~ tr/\000-\037\177-\377//d, $_), 0, 60) . '"' };
my %UNPACK =
    ("TES3.HEDR" => sub { my($ver, $unk, $auth, $desc, $nrec) = unpack("fLZ32Z256L", $_[0]);
			  $NREC = $nrec;
			  return(qq{  Ver:$ver  Unk:$unk\n\t\tAuthor:"$auth"\n\t\tDescription:"$desc"\n\t\tNRec:$NREC});
		      },
     "TES3.MAST" => sub { unpack("Z*", $_[0]) },
     "TES3.DATA" => sub {
	 my($l1, $l2) = unpack("LL", $_[0]);
	 my $size = $l1 + ($l2 << 32);
	 "Length:     $size";
     },
     "CELL.DATA" => sub {
	 if (length($_[0]) == 24) {
	     $DEFAULT_UNPACK->($_[0]);
	 } else {
	     my($flags, $fog_den_data) = unpack("Lx[L]f", $_[0]);
	     my @flags = ();
	     my $coord = "";
	     my $data_fog_str = "";
	     if ($flags & 0x01) {
		 push(@flags, "Interior");
		 $data_fog_str = sprintf "FogDensity: %0.2f ", $fog_den_data;
	     } else {
		 push(@flags, "Exterior");
		 my($x, $y) = unpack("x[L]ll", $_[0]);
		 $coord = "Coordinates: ($x, $y) ";
	     }
	     push(@flags, "Has Water") if ($flags & 0x02);
	     push(@flags, "Illegal to Sleep Here") if ($flags & 0x041);
	     push(@flags, "Behave like Exterior") if ($flags & 0x80);
	     my $flags_str = "Flags: @{[join(', ', @flags)]} ";
	     $coord . $data_fog_str . $flags_str;
	 }
     },
     "CLAS.CLDT" => sub { my($attr1, $attr2, $spec, $min1, $maj1, $min2, $maj2, $min3, $maj3, $min4, $maj4, $min5, $maj5, $flags, $autoflags) =
			    unpack("L15", $_[0]);
			return("  " . join("\n\t\t",
				    "Primary Attribute:   $ATTRIBUTE{$attr1}",
				    "Secondary Attribute: $ATTRIBUTE{$attr2}",
				    "Specialization: $SPECIALIZATION{$spec}",
				    "Major-Skill-1: $SKILL{$maj1}",
				    "Major-Skill-2: $SKILL{$maj2}",
				    "Major-Skill-3: $SKILL{$maj3}",
				    "Major-Skill-4: $SKILL{$maj4}",
				    "Major-Skill-5: $SKILL{$maj5}",
				    "Minor-Skill-1: $SKILL{$min1}",
				    "Minor-Skill-2: $SKILL{$min2}",
				    "Minor-Skill-3: $SKILL{$min3}",
				    "Minor-Skill-4: $SKILL{$min4}",
				    "Minor-Skill-5: $SKILL{$min5}",
				    "Flags: " . (($flags) ? "Playable" : "Non-playable"),
				    "AutoCalc Flags: " . list_autocalc_flags($autoflags)));
		    },
     "INFO.INAM" => sub { unpack("Z*", $_[0]) },
     "INFO.DATA" => sub { my($disp, $rank, $sex, $pcrank) = unpack("x[L]LCCC", $_[0]);
			  return("Disp:$disp  Rank:$rank  Sex:$SEX{$sex}  PCRank:$pcrank"); },
     "INFO.ANAM" => sub { "Cell:       " . unpack("Z*", $_[0]) },
     "INFO.BNAM" => sub { "Result:     " . unpack("Z*", $_[0]) },
     "INFO.CNAM" => sub { "Class:      " . unpack("Z*", $_[0]) },
     "INFO.DNAM" => sub { "PC Faction: " . unpack("Z*", $_[0]) },
     "INFO.FNAM" => sub { "Faction:    " . unpack("Z*", $_[0]) },
     "INFO.NAME" => sub { "Response:   " . unpack("Z*", $_[0]) },
     "INFO.NNAM" => sub { "Next ID:    " . unpack("Z*", $_[0]) },
     "INFO.ONAM" => sub { "Actor:      " . unpack("Z*", $_[0]) },
     "INFO.PNAM" => sub { "Prev ID:    " . unpack("Z*", $_[0]) },
     "INFO.RNAM" => sub { "Race:       " . unpack("Z*", $_[0]) },
     "INFO.SCVR" => sub { my($idx, $typ, $fun, $cmp, $nam) = unpack("aaa2aZ*", $_[0]);
			  return("Index:$idx  Type:$INFO_SCVR_type{$typ}  Fun:$fun  Cmp:$INFO_SCVR_cmp{$cmp}  Name:$nam");
		      },

     "LTEX.DATA" => sub { unpack("Z*", $_[0]) },

     # The following are common subrecord formats
     "SCPT.SCVR" => sub { "Script Variables: " . join(',', split(/\000/, unpack('a*', $_[0]))) },
     "SCPT.SCTX" => sub { "Script:\n" . unpack("Z*", $_[0]) },


     FLAG => sub { sprintf "0x%04x", unpack("L", $_[0]) },
     FLTV => sub { unpack("f", $_[0]) },
     FRMR => sub { unpack("L", $_[0]) },
     INDX => sub { unpack("L", $_[0]) },
     INTV => sub { unpack("l", $_[0]) },
     NAM0 => sub { unpack("L", $_[0]) },
     NPCO => sub { sprintf 'Count=%d  Name="%s"', unpack("lZ*", $_[0]) },
     XSCL => sub { unpack("f", $_[0]) },
    );

# add in defaults for all the fields that are simple strings
foreach (qw(
ANAM ASND AVFX BNAM BSND BVFX CNAM CSND CVFX DESC DNAM ENAM FNAM HSND HVFX ITEX
KNAM MODL NAME NPCS PTEX RGNN RNAM SCIP SCPT SCRI SNAM STRV TEXT TNAM WNAM
)) {
    $UNPACK{$_} = sub { unpack("Z*", $_[0]) };
}

sub opts_dump {
    $_[0] && do { warn $DUMP_USAGE; exit(0); };
    getopts('Dt:i:') or die $DUMP_USAGE;
}

my $REN_USAGE = q{Usage: tes3cmd rename OPTIONS RECTYPE.SUBTYPE FROM TO plugin...

This first form of the command renames all records of type RECTYPE, replacing
the Perl regular expression FROM with the value of TO (which may contain
backreferences). The rename only happens if the CELL.NAME subrecord matches
the given FROM regular expression. For more on regular expressions, see:
http://www.perl.com/doc/manual/html/pod/perlre.html

tes3cmd rename -l RECTYPE.SUBTYPE plugin...

When the -l switch is given, records of the given type are only listed.

OPTIONS
 -D   turn on debug output
 -i   only rename if the record is an interior CELL.
 -e   only rename if the record is an exterior CELL.
 -l   just list the records, do not rename them.
 -w   size of printable window for record contents printed with -l switch.

The original input file is never modified, the changes are made in a new file
"<plugin_name>_new.esp".

Examples:

# rename all exterior cells to the null string:
tes3cmd rename -e CELL.NAME '.*' '' plugin.esp

# do a caseless comparison:
tes3cmd rename cell.name '(?i)pelagaid' 'Pelagiad' plugin.esp
(This would rename any name that has the string "pelagaid" in it with any form
of capitalization, to "Pelagiad").

# substitute backreferences:
tes3cmd rename npc_.fnam '^(\S+)\s(\S+)$' '$2 $1' plugin.esp
(This would swap the first and last name of all NPCs).
};

my($REN_FROM, $REN_TO, $REN_TYPE, $REN_SUBTYPE);
my @ren_valid_types = qw(GMST.NAME CLAS.NAME CLAS.FNAM FACT.NAME FACT.FNAM RACE.NAME RACE.FNAM
		     SOUN.NAME SOUN.FNAM REGN.NAME REGN.FNAM BSGN.NAME BSGN.FNAM STAT.NAME
		     DOOR.NAME DOOR.FNAM MISC.NAME MISC.FNAM WEAP.NAME WEAP.FNAM CONT.NAME
		     CONT.FNAM SPEL.NAME SPEL.FNAM CREA.NAME CREA.FNAM LIGH.NAME LIGH.FNAM
		     ENCH.NAME NPC_.NAME NPC_.FNAM ARMO.NAME ARMO.FNAM CLOT.NAME CLOT.FNAM
		     REPA.NAME REPA.FNAM ACTI.NAME ACTI.FNAM APPA.NAME APPA.FNAM LOCK.NAME
		     LOCK.FNAM PROB.NAME PROB.FNAM INGR.NAME INGR.FNAM BOOK.NAME BOOK.FNAM
		     ALCH.NAME ALCH.FNAM LEVI.NAME CELL.NAME DIAL.NAME);
my %VALID_TYPES;
$VALID_TYPES{$_}++ foreach (@ren_valid_types);

sub opts_rename {
    $_[0] && do { warn $REN_USAGE; exit(0); };
    $::opt_v = 0;
    $::opt_l = 0;
    $::opt_i = 0;
    $::opt_e = 0;
    $::opt_w = 38;
    getopts('Deilvw:') or die $REN_USAGE;

    my $type = uc(shift(@ARGV)) or die "Missing required RECTYPE.SUBTYPE\n$REN_USAGE";
    die "Error: Invalid record type.subtype requested: $type\n\nI only know these:\n@ren_valid_types\n" unless ($VALID_TYPES{$type});
    ($REN_TYPE, $REN_SUBTYPE) = split(/\./, $type);

    unless ($::opt_l) {
	$REN_FROM = shift(@ARGV) or die "Missing required FROM\n$REN_USAGE";
	$REN_TO = shift(@ARGV) or die "Missing required TO\n$REN_USAGE";
    }
}

my $HDR_USAGE = q{Usage: tes3cmd header OPTIONS plugin...

OPTIONS
 -D      turn on debug output
 -a XXX  set the Author field to XXX
 -d YYY  set the Desciption field to YYY
 -m      multiline output for listing field contents.

When -a and -d are not given, the current Author/Description field contents
are printed.

Field values are normally replaced by the given string. But if the string
begins with a "+", the field is appended with the new value.

If a field value contains the string \\n, it will be replaced by a CRLF.

If the value supplied won't fit into the plugin header field, you will be
warned.

Examples:

# Show the Author/Description fields for a plugin:
tes3cmd header plugin.esp

# Set the Author field to "john.moonsugar":
tes3cmd header -a john.moonsugar plugin.esp

# Append " and friends" to the Author field:
tes3cmd header -a "+ and friends" plugin.esp

# Add a Version number to a plugin Description field:
tes3cmd header -d "+\nVersion: 1.0" plugin.esp
};

my $HDR_AUTH_OFFSET = 32;
my $HDR_AUTH_LENGTH = 32;
my $HDR_DESC_OFFSET = $HDR_AUTH_OFFSET + $HDR_AUTH_LENGTH;
my $HDR_DESC_LENGTH = 256;

sub opts_header {
    $_[0] && do { warn $HDR_USAGE; exit(0); };
    $::opt_v = 0;
    $::opt_a = "";
    $::opt_d = "";
    $::opt_m = undef;
    $::opt_v = 0.0;
    getopts('Da:d:mv:') or die $HDR_USAGE;
}

my %CMDS = ("rename" => [\&opts_rename, \&cmd_rename],
	    "header" => [\&opts_header, \&cmd_header],
	    "dump"   => [\&opts_dump, \&cmd_dump],
	    "common" => [\&opts_com, \&cmd_com],
	    "help"   => [\&opts_help, undef],
	   );

my $USAGE_ALL = qq{Usage: tes3cmd {@{[join('|', sort keys %CMDS)]}} OPTIONS plugins...

For help on subcommands: tes3cmd help subcommand

};
sub add_alias {
    my($name, $alias) = @_;
    $CMDS{$alias} = $CMDS{$name};
    $USAGE_ALL .= " $alias is an alias for subcommand: $name\n"
}
# add shortcut aliases for convenience
add_alias("header", "hdr");
add_alias("rename", "ren");
add_alias("common", "com");

sub opts_help {
    if (my $cmd_name = shift(@ARGV)) {
	if (my $cmd_ref = $CMDS{$cmd_name}) {
	    $cmd_ref->[0]->(1);	# exits
	} else {
	    die $USAGE_ALL;
	}
    }
    die $USAGE_ALL;
}

sub chop_nulls {
    my($str) = @_;
    $str =~ tr/\000//d;
    return($str);
}

sub write_header_field {
    my($plugin, $origval, $val, $label, $offset, $fieldlen) = @_;
    if ($val =~ /^\+(.*)$/) {
	$val = $origval . $1;
    }
    $val =~ s/(\\r|\r)?(\\n|\n)/\r\n/g;
    # create an empty null padded field
    my $valz = "\000" x $fieldlen;
    # truncate $val to fit in the field, if necessary
    my $origlen = length($val);
    $val = substr($val, 0, $fieldlen - 1);
    if (length($val) < $origlen) {
	warn "Warning, input $label truncated because it exceeded field length of: $fieldlen\n";
    }
    # and plop the given string value into it, with at least one ending null
    substr($valz, 0, length($val)) = $val;
    unless(seek(PLUG, $offset, 0)) {
	warn "$plugin: Error seeking to start of $label field at offset: $offset ($!)\n";
	return(undef);
    }
    my $len = length($valz);
    my $nwritten = syswrite(PLUG, $valz);
    if ($nwritten != $len) {
	warn "$plugin: Error incomplete write to $label field ( ($!)\n";
	return(undef);
    }
    print qq{$plugin: $label set to: "$val"\n};
    return(1);
}

my $hdr_size = 16;
sub read_rec {
    my($expected_type) = @_;
    my $rec_hdr = "";
    my $n_read = sysread(INP, $rec_hdr, $hdr_size);
    if ($n_read == 0) {		# EOF
	return(undef);
    }
    if ($n_read != $hdr_size) {
	warn "Error(hdr): asked for $hdr_size bytes, got $n_read\n";
	return(undef);
    }
    my($rec_type, $rec_len, $unk, $flags) = unpack("a4LLL", $rec_hdr);
    if (defined($expected_type) and $expected_type ne $rec_type) {
	warn "Error: Expected: $expected_type, got: $rec_type\n";
	return(undef);
    }
    my $rec = "";
    $n_read = sysread(INP, $rec, $rec_len);
    if ($n_read != $rec_len) {
	warn "Error(rec): asked for $rec_len bytes, got $n_read\n";
	return(undef);
    }
    return($rec_type, $rec, $unk, $flags);
}

sub write_rec {
    my($rec_type, $rec, $unk, $flags) = @_;
    print OUT pack("a4LLLa*", $rec_type, length($rec), $unk, $flags, $rec);
}

sub parse_subrec_list {
    my($rec) = @_;
    my $p = 0;
    my $rec_len = length($rec);
    my @subrecs = ();
    my $name_idx;
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$name_idx = scalar(@subrecs) if ((not defined $name_idx) and ($subrec_type eq $REN_SUBTYPE));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@subrecs, [$subrec_type, $val]) if (defined $val);
	$p += $subrec_len;
    }
    return(\@subrecs, $name_idx);
}

# this version takes a little longer to execute
sub parse_subrec_hash_long {
    my($rec) = @_;
    warn "DBG: calling parse_subrec_hash_long for rec=$rec\n" if (DBG);
    my %r = ();
    my $p = 0;
    my $rec_len = length($rec);
    while ($p < $rec_len) {
	my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	$p += 8;
	my $val = substr($rec, $p, $subrec_len);
	push(@{$r{$subrec_type}}, $val) if (defined $val);
	$p += $subrec_len;
    }
    return(\%r);
}

sub parse_subrec_hash {
    my($rec) = @_;
    my %r = ();
    my @parts = eval { unpack("(a4L/a*)*", $rec); };
    return(parse_subrec_hash_long($rec)) if ($@);
    while (@parts) {
	my $subrec_type = shift(@parts);
	my $subrec_val = shift(@parts);
	push(@{$r{$subrec_type}}, $subrec_val)
	    if (defined $subrec_val);
    }
    return(\%r);
}

sub new_rec {
    my($sub_recs) = @_;
    my @rec;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	my $len = length($val);
	push(@rec, pack("a4La*", $type, $len, $val));
    }
    return(join("", @rec));
}

sub allowed_cell_type {
    my($sub_recs) = @_;
    return 1 unless ($::opt_i or $::opt_e);
    my $data;
    foreach my $pair (@$sub_recs) {
	my($type, $val) = @$pair;
	if ($type eq "DATA") {
	    $data = $val;
	    last;
	}
    }
    my($flags) = unpack("L", $data);
    if ($::opt_i) {
	return($flags & 1);	# is interior
    } else {			# opt_e
	return(not($flags & 1)); # is exterior
    }
}

sub pprec {
    my($rec, $subtype) = @_;
    print "DBG: pprec($rec)\n" if (DBG);
    my $recstr = join(":", grep(!/[^[:print:]]/, map { s/[\000]+$//gm; tr/\r\n/ /; $_; } split(/\000?([A-Z][A-Z_][A-Z_][A-Z_\d])...\000/, $rec)));
    $recstr =~ s/^:$subtype:.*?:// if ($subtype);
    $recstr =~ s/:([A-Z][A-Z_][A-Z_][A-Z_\d])/|$1/g;
    return(substr($recstr, 0, $::opt_w));
}

sub open_input_plugin {
    my($plugin, $mode) = @_;
    unless(open(INP, "<$plugin")) {
	warn qq{Error opening "$plugin" for input ($!)\n};
	return;
    }
    unless (binmode(INP)) {
	warn "Error setting binmode on $plugin ($!)\n";
	close(INP);
	return;
    }
}

sub ext_cell_name {
    my($r) = @_;
    my($x, $y) = unpack("x[L]ll", $r->{DATA}[0]);
    my $rgnn = chop_nulls($r->{RGNN}[0]) || "Wilderness";
    return("$rgnn ($x, $y)", $x, $y);
}

sub rec_id {
    my($r, $rec_type) = @_;
    if ($rec_type eq "INFO") {
	return(chop_nulls($r->{INAM}[0]));
    } elsif ($rec_type eq "CELL") {
	my $name = chop_nulls($r->{NAME}[0]);
	my $data = $r->{DATA}[0];
	my($flags) = unpack("L", $data);
	if ($flags & 1) {	# interior
	    return($name);
	} else {		# exterior
	    my($xname, $x, $y) = ext_cell_name($r);
	    return(($name) ? "$name ($x, $y)" : $xname);
	}
    } elsif ($rec_type eq "SCPT") {
	my $script = $r->{SCTX}->[0];
	my $name = ($script =~ m!^[^;]*?\bbegin\s+(\S+)!im) ? $1 : "unknown";
	return(lc($name));
    } elsif (defined $r->{NAME}) {
	return(lc(chop_nulls($r->{NAME}->[0])));
    } elsif (defined $r->{INDX}) {
	return(unpack("L", $r->{INDX}->[0]));
    } elsif ($rec_type eq "LAND") {
	my($x, $y) = unpack("ll", $r->{INTV}->[0]);
	return("($x, $y)");
    }
    return(undef);
}

sub read_object_ids {
    my($plugin, $fun) = @_;
    open_input_plugin($plugin);
    my %plugin_id = ();
    while(my($rec_type, $rec, $flags) = read_rec(undef)) {
	last if not defined $rec_type;
	if ($flags & 0x1000) {
	    print "plugin($plugin) REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	if ($fun) {
	    $fun->($rec_type, $id);
	} else {
	    $plugin_id{$rec_type}->{$id} = 1 if (defined $id);
	}
    }
    close(INP);
    return(\%plugin_id) unless ($fun);
}

# find objects in common between 2 plugins
sub cmd_com {
    my($plugin1, $plugin2) = @_;
    # swap plugins if plugin1 is larger than plugin2
    ($plugin1, $plugin2) = ($plugin2, $plugin1)
	if (-s $plugin1 > -s $plugin2);
    # read objects from smaller plugin
    my $objects1 = read_object_ids($plugin1);
    # compare to objects second plugin
    my $compare_fun = sub {
	my($rec_type, $id) = @_;
	if ($objects1->{$rec_type}->{$id}) {
	    print "  $rec_type: $id\n";
	}
    };
    read_object_ids($plugin2, $compare_fun);
}

sub cmd_dump {
    my($plugin) = @_;
    #my $plugin = (split(m![\\/]!, $plugin))[-1];
    warn "### Scanning $plugin\n" if ($::opt_v);
    open_input_plugin($plugin);
    my $expected = "TES3";
    my $n = 0;
    my $wanted_ids;
    if ($::opt_i) {
	$wanted_ids = '(' . join('|', split(/,/, $::opt_i)) . ')';
    }
    my %wanted_types;
    my %wanted_subtypes;
    if ($::opt_t) {
	foreach (split(/,/, $::opt_t)) {
	    # TBD - validate types?
	    my($type, $subtype) = split(/\./, $_);
	    if (length($type) != 4) {
		warn qq{Invalid record type: "$_" (must be 4 characters long)\n};
		next;
	    }
	    $wanted_types{lc($type)}++;
	    if ($subtype) {
		if (length($subtype) == 4) {
		    $wanted_subtypes{lc("$type.$subtype")}++ if ($subtype);
		} else {
		    warn qq{Invalid record subtype: "$_" (must be 4 characters long)\n};
		    next;
		}
	    }
	}
    }
    print "\n$plugin:\n";
    while (my($rec_type, $rec, $flags) = read_rec($expected)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	if ($flags & 0x1000) {
	    print "REC=$rec_type flags=$flags (ignored)\n" if (DBG);
	    next;
	}
	if ($wanted_ids) {
	    my $id = rec_id(parse_subrec_hash($rec), $rec_type);
	    next if ($id !~ /$wanted_ids/i);
	}
	if (%wanted_types) {
	    next unless ($wanted_types{lc($rec_type)});
	}
	my $p = 0;
	my $rec_len = length($rec);
	my $name_idx;
	my $first = 1;
	while ($p < $rec_len) {
	    my($subrec_type, $subrec_len) = unpack("a4L", substr($rec, $p));
	    $p += 8;
	    my $subrec = substr($rec, $p, $subrec_len);
	    $p += $subrec_len;
	    if (defined $subrec) {
		my $full_type = "${rec_type}.${subrec_type}";
		if (not (%wanted_subtypes and not $wanted_subtypes{lc($full_type)})) {
		    my $unpack = $UNPACK{$full_type} || $UNPACK{$subrec_type}  || $DEFAULT_UNPACK;
		    my $subrec_str = $unpack->($subrec);
		    my $prefix = ($first) ? "\nRecord: $n\n   $full_type" : "        $subrec_type";
		    print "$prefix: $subrec_str\n";
		    $first = 0;
		}
	    } else {
		warn "$plugin: Error: malformed subrec $subrec_type\n";
	    }
	}
	$n++;
    }
    close(INP);
}

sub cmd_rename {
    my($plugin) = @_;
    my $newplugin = $plugin;
    $newplugin =~ s/(\.es[mp])$/_new$1/i;
    if ($newplugin eq $plugin) {
	warn "Error, $plugin name does not end in .esm or .esp?\n";
	return;
    }
    print "\n$plugin: RENAMING CELLS:\n" unless ($::opt_l);
    open_input_plugin($plugin);
    unless($::opt_l) {
	unless(open(OUT, ">$newplugin")) {
	    warn qq{Error opening "$newplugin" for output ($!)\n};
	    return;
	}
	unless(binmode(OUT, ':raw')) {
	    warn qq{Error setting binmode on "$newplugin" ($!)\n};
	    close(OUT);
	    return;
	}
    }
    my $expected = "TES3";
    while (my($rec_type, $rec, $unk, $flags) = read_rec($expected)) {
	$expected = undef;
	last if not defined $rec_type;
	print "REC=$rec_type flags=$flags\n" if (DBG);
	if ($rec_type eq $REN_TYPE) {
	    my $renamed = 0;
	    my($subrecs, $name_idx) = parse_subrec_list($rec);
	    if (defined($name_idx) and
		my $name = $subrecs->[$name_idx]->[1]) {
		$name = chop_nulls($name);
		if ($::opt_l) {	# only list records
		    my $recstr = pprec($rec, $REN_SUBTYPE);
		    printf qq{  $rec_type  %-30s [%s]\n}, $name, $recstr;
		} else {	# rename records
		    my $do_rename = 1;
		    $do_rename = 0 if ($rec_type eq "CELL" and not allowed_cell_type($subrecs));
		    if ($do_rename) {
			my $newname;
			eval qq{(\$newname = \$name) =~ s!$REN_FROM!$REN_TO!g};
			if ($name ne $newname) {
			    $subrecs->[$name_idx]->[1] = "$newname\000";
			    $renamed = 1;
			    printf qq{    Renaming: $REN_TYPE %-30s -> %-30s\n}, qq{"$name"}, qq{"$newname"};
			}
		    }
		}
	    } else {
		print "Error, Record has no $REN_SUBTYPE subrecord: $rec\n";
	    }
	    $rec = new_rec($subrecs) if $renamed;
	}
	write_rec($rec_type, $rec, $unk, $flags) unless($::opt_l);
    }
    close(INP);
    unless ($::opt_l) {
	close(OUT);
	print "Output saved in: $newplugin\n";
    }
}

sub cmd_header {
    my($plugin) = @_;
    unless(open(PLUG, "+<$plugin")) {
	warn qq{Error opening "$plugin" for read/write ($!)\n};
	return;
    }
    unless(binmode(PLUG)) {
	warn "Error setting binmode on $plugin ($!)\n";
	close(PLUG);
	return;
    }
    my $block;
    my $nread = read(PLUG, $block, 4096);
    if ($nread == 0) {
	warn "$plugin: Error on intial read ($!)\n";
	close(PLUG);
	return;
    }
    my $magic = substr($block, 0, 4);
    if ($magic eq "TES3") {
	if ($nread >= 362) { 	# minimum TES3 plugin size
	    my $auth = chop_nulls(substr($block, $HDR_AUTH_OFFSET, $HDR_AUTH_LENGTH));
	    my $desc = chop_nulls(substr($block, $HDR_DESC_OFFSET, $HDR_DESC_LENGTH));
	    if ($::opt_a or $::opt_d) {
		if ($::opt_a) {
		    if (not defined write_header_field($plugin, $auth, $::opt_a, "AUTHOR", $HDR_AUTH_OFFSET, $HDR_AUTH_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
		if ($::opt_d) {
		    if (not defined write_header_field($plugin, $desc, $::opt_d, "DESCRIPTION", $HDR_DESC_OFFSET, $HDR_DESC_LENGTH)) {
			close(PLUG);
			return;
		    }
		}
	    } else {
		if ($::opt_m) {
		    print "$plugin:\n  AUTH=$auth\n  DESC=$desc\n";
		} else {
		    print "$plugin: AUTH=$auth DESC=$desc\n";
		}
	    }
	}
    } elsif ($magic eq "TES4") {
	warn "This function is not yet implemented for TES4 files\n";
    } else {
	warn "$plugin: Error, this does not appear to be an elder scrolls plugin\n";
    }
    close(PLUG);
}

sub main {
    if (scalar(@ARGV) == 0) {
	print $USAGE_ALL;
	exit(0);
    }
    my $cmd_ref;
    my $cmd_name = shift(@ARGV);
    die $USAGE_ALL unless ($cmd_ref = $CMDS{$cmd_name});
    my($cmd_getopts, $cmd) = @{$cmd_ref};
    $cmd_getopts->();
    if ($cmd_name =~ /^com(mon)?$/i) {
	$cmd->(@ARGV);
    } else {
	for my $plugin (@ARGV) {
	    $cmd->($plugin);
	}
    }
}

main();
